/*******************************************************************************
* FILENAME:             get_mpe_product_state.c
* NUMBER OF MODULES:    1
* GENERAL INFORMATION:
*   MODULE 1:           derive_field_dependencies ( static )
* DESCRIPTION:          For a given MPE product derives all products which
*                       are needed to produce it.
*   MODULE 2:           get_mpe_product_state
* DESCRIPTION:          Indicates whether a given MPE product will or will
*                       not be generated by MPE FieldGen.
*
* ORIGINAL AUTHOR:      Bryon Lawrence
* CREATION DATE:        September 28, 2004
* ORGANIZATION:         OHD-11, HSEB
* MACHINE:              IBM PC, LINUX
* MODIFICATION HISTORY:
*   MODULE #        DATE         PROGRAMMER        DESCRIPTION/REASON
*          2        9/28/04      Bryon Lawrence    First Coding
*          2        11/10/04     Bryon Lawrence    Fixed a bug that
*                                                  could result in
*                                                  unresolved dependencies
*          2        11/10/04     Bryon Lawrence    Added check of the
*                                                  mpe_del_gage_zeros token.
*          2        10/04/05     Bryon Lawrence    Added the check of the token
*                                                  which determines which
*                                                  radar mosaic is used
*                                                  as the base of all of the
*                                                  MPE mosaics.
*                    4/2010       P Tilles         Added array entries for 3
*                                                  new local fields to
*                                                  mpe_qpe_fields and
*                                                  mpe_qpe_dependencies 
*                    2/4/2015      C Gobs          DR 17069 - mpe_generate_list - token value too short
********************************************************************************
*/
#include <stdlib.h>
#include <string.h>

#include "GeneralUtil.h"
#include "get_mpe_product_state.h"
#include "mpe_log_utils.h"
#include "mpe_fieldgen.h"


/* Define the MPE base radar mosaic list. */
const static char * mpe_base_radar_mosaics [ NUM_BASE_RADAR_MOSAICS ] =
                                     { "RMOSAIC",
                                       "AVGRMOSAIC",
                                       "MAXRMOSAIC" };
const static char * mpe_base_radardp_mosaics [ NUM_BASE_RADAR_MOSAICS ] =
                                     { "RDMOSAIC",
                                       "AVGRDMOSAIC",
                                       "MAXRDMOSAIC" };

/* Define the MPE product generation rules. */
const static char * mpe_qpe_fields [ NUM_BEST_PRODUCTS ] =
                                     { "RMOSAIC",
                                       "AVGRMOSAIC",
                                       "MAXRMOSAIC",
                                       "BMOSAIC",
                                       "LMOSAIC",
                                       "GAGEONLY",
                                       "MMOSAIC",
                                       "MLMOSAIC",
                                       "SATPRE",
                                       "LSATPRE",
                                       "SRMOSAIC",
                                       "SGMOSAIC",
                                       "SRGMOSAIC",
                                       "P3LMOSAIC",
                                       "RFCMOSAIC",
                                       "RFCBMOSAIC",
                                       "RFCMMOSAIC",
                                       "QMOSAIC",
                                       "LQMOSAIC",
				       "MLQMOSAIC",    
                                       "RDMOSAIC",
                                       "AVGRDMOSAIC",
                                       "MAXRDMOSAIC",
                                       "BDMOSAIC",
                                       "LDMOSAIC",
                                       "MDMOSAIC",
                                       "MLDMOSAIC",
                                       "SRDMOSAIC",
                                       "SRDGMOSAIC",
				       "LOCALFIELD1",    
				       "LOCALFIELD2",    
				       "LOCALFIELD3" };

const static char * mpe_qpe_dependencies [ NUM_BEST_PRODUCTS ] =
                                        {
                                          "", //"RMOSAIC",
                                          "", //  "AVGRMOSAIC",
                                          "",//"MAXRMOSAIC",
                                          "RMOSAIC", //   "BMOSAIC",
                                          "RMOSAIC" ,//   "LMOSAIC",
                                          "RMOSAIC",//   "GAGEONLY",
                                          "RMOSAIC,BMOSAIC" ,//    "MMOSAIC",
                                          "RMOSAIC,LMOSAIC" ,//      "MLMOSAIC",
                                          "" ,//   "SATPRE",
                                          "RMOSAIC,SATPRE",//    "LSATPRE",
                                          "LSATPRE,LMOSAIC",//     "SRMOSAIC",
                                          "LSATPRE",//    "SGMOSAIC",
                                          "SRMOSAIC",//      "SRGMOSAIC",
                                          "RMOSAIC",//    "P3LMOSAIC",
                                          "",//  "RFCMOSAIC",
                                          "RMOSAIC",//   "RFCBMOSAIC",
                                          "RMOSAIC,RFCBMOSAIC",//  "RFCMMOSAIC",
					  "",//   "QMOSAIC",
					  "QMOSAIC",//  "LQMOSAIC",
					  "QMOSAIC,LQMOSAIC",   //   "MLQMOSAIC",
					  "",   //  "RDMOSAIC",
					  "",   //  "AVGRDMOSAIC",
					  "",   //  "MAXRDMOSAIC",
                      "RDMOSAIC",//  "BDMOSAIC",
                      "RDMOSAIC", // "LDMOSAIC",

                      "", // "MDMOSAIC",
                      "", // "MLDMOSAIC",

                      "", //"SRDMOSAIC",
                      "", // "SRDGMOSAIC",

                      "",//  "LOCALFIELD1",
                      "",//   "LOCALFIELD2",
					  ""//  "LOCALFIELD3"
                                          };



/* GageOnly Generation rule in case mpe_del_gage_zeros token is OFF. */
const static char * gageonly_del_gages_off = "" ;

#define MPE_GENERATE_LIST_REPLY_LEN 512

/*******************************************************************************
* MODULE NUMBER: 1
* MODULE NAME:   derive_field_dependencies
* PURPOSE:       For a given MPE product and the dependency grammar,
*                this routine derives all depencies needed to create that
*                product.
*
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME             DESCRIPTION/UNITS
*   Input  int         verbose          0 = Do not output to stdout or stderr.
*                                       1 = Do output to stdout and stderr.
*   Input  int         index            This corresponds to the
*                                       MpeBestProdList enumeration.
*   I/O    int [ ]     mpe_field_states This contains an element for each
*                                       type in the MpeBestProdList
*                                       enumeration (except for the
*                                       NUM_BEST_PRODUCTS type).  The
*                                       index argument is used with this
*                                       array to indicate which product
*                                       dependencies need to be derived for.
*                                       Also, this array contains the
*                                       state (0=OFF,1=ON) of each
*                                       supported product.
*
* RETURNS:
*   DATA TYPE     DESCRIPTION
*   int           The return status of this routine.  0 = Ok. A nonzero value
*                 means an error was encountered.
* APIs UTILIZED:
*   Only  C Library APIs are called.
*
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME          DESCRIPTION
*   char *     pChar          Points to the next ',' character.
*   char *     pDependencies  Points to MPE products the MPE product being
*                             processed is dependent on.
*   char *     pEnd           Used to point to the end of the dependency
*                             string.
*   char *     pString        Used to point to the start of the dependency
*                             string.
*   char *     pToken         Used to point to the current MPE product being
*                             processed in the list of dependencies.
*   int i                     A loop index.
*   int request_len           The length of the string pointed to by pToken.
*   int status                Contains return codes for testing.
*
* DATA FILES AND/OR DATABASE:
*   None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0                                      This routine worked.
*    Non Zero                               Something went wrong.
********************************************************************************
*/

/* Contains the value of the mpe_del_gage_zeros token.  If the value of
   this token is "ON", then when creating the GageOnly field, ignore gage
   values of 0 if the corresponding grid bin in the RMOSAIC has a value
   greather than 0.

   If the value of the mpe_del_gage_zeros token is "OFF", then do not use the
   RMOSAIC in the creation of the GageOnly Field. */

static int mpe_del_gage_zeros = 0 ;

static int derive_field_dependencies ( int verbose, int index,
                                       int mpe_field_states
                                                    [ NUM_BEST_PRODUCTS ] )
{
   char * pChar = NULL ;
   const char * pDependencies = NULL ;
   char * pEnd = NULL ;
   char * pString = NULL ;
   char * pToken = NULL ;
   int i ;
   int request_len ;
   int status = 0 ;

   /* Check if this is the GageOnly field.  Whether or not the GageOnly
      field depends on RMOSIAC is determined by the mpe_del_gage_zeros
      token. */
   if ( ( index == GAGEONLY ) && ( mpe_del_gage_zeros == 0 ) )
   {
      /* Dependency rules without RMOSAIC. */
      pDependencies = gageonly_del_gages_off ;
   }
   else
   {
      /* Dependency rules with RMOSAIC. */
      pDependencies = mpe_qpe_dependencies [ index ] ;
   }

   request_len = strlen ( pDependencies ) ;

   /* An empty product dependency list indicates no dependencies
      need to be checked. If the dependency list is empty, then
      stop recursion. */
   if ( request_len > 0 )
   {
      /* Make a local copy of the product dependency list. */
      pString = ( char * ) malloc ( sizeof ( char ) * request_len + 1 ) ;

      if ( pString == NULL )
      {
         /* Dynamic memory allocation failure. */
         /* Error message. */
         if ( verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                               "Failed to allocate %d bytes of memory.\n" ,
                               ( sizeof ( char ) * request_len + 1 ) ) ;
         }

         return -1 ;
      }

      memset ( pString , '\0' , request_len + 1 ) ;
      strcpy ( pString , pDependencies ) ;

      pToken = pString ;
      pEnd = pString + request_len ;

      while ( pToken < pEnd )
      {
         pChar = strchr ( pToken , ',' ) ;

         if ( pChar != NULL )
         {
            * pChar = '\0';
         }
         else
         {
            pChar = pEnd - 1 ;
         }

         /* Skip the RMOSAIC dependencies.  The value (or default value)
            of the mpe_base_radar_mosaic token guarantees that there
            will be a radar mosaic to be the base of all of the MPE
            products. */
         status = strcmp ( pToken, "RMOSAIC" );

         if ( status != 0 )
         {
            for ( i = 0 ; i <  NUM_BEST_PRODUCTS ; ++ i )
            {
               status = strcmp ( pToken , mpe_qpe_fields [ i ] ) ;

               if ( status == 0 )
               {
                  if ( mpe_field_states [ i ] != 1 )
                  {
                     mpe_field_states [ i ] = 1 ;

                     /* Log a message. */
                     if ( verbose == 1 )
                     {
                        flogMessage ( stderr , "\nIn 'get_mpe_product_state':\n"
                                           "%s must be generated to support\n"
                                           "field %s.\n" ,
                                           mpe_qpe_fields [ i ] ,
                                           mpe_qpe_fields [ index ] ) ;
                     }

                     /* Recursively call the derive_field_dependencies
                        routine. */
                     status = derive_field_dependencies ( verbose , i,
                                                          mpe_field_states );

                     if ( status != 0 )
                     {
                        if ( pString != NULL )
                        {
                           free ( pString ) ;
                           pString = NULL ;
                        }

                        return status ;
                     }
                  }

                  break ;
               }
            }
         }

         pToken = pChar + 1 ;
      }

      if ( pString != NULL )
      {
         free ( pString ) ;
         pString = NULL ;
      }
   }

   return 0 ;
}

/*******************************************************************************
* MODULE NUMBER: 2
* MODULE NAME:   get_mpe_product_state
* PURPOSE:       Indicates whether a given MPE product will or will not
*                be generated by MPE FieldGen.
*
*                This routine uses the following two tokens to accomplish
*                this task:
*
*                mpe_qpe_fieldtype - Indicates which MPE field should be
*                                    stored as the Best Estimate field.
*                mpe_generate_list - A comma separated list of MPE products
*                                    which MPE FieldGen should generate.
*
*                The following names are used to represent the products in the
*                mpe_generate_list and mpe_qpe_fieldtype tokens:
*
*                BMOSAIC              (field bias mosaic)
*                GAGEONLY             (gage only analysis)
*                LMOSAIC              (local bias mosaic)
*                LSATPRE              (local bias satellite precip field)
*                MLMOSAIC             (local bias multisensor mosaic)
*                MMOSAIC              (multisensor mosaic)
*                RMOSAIC              (radar mosaic)
*                SATPRE               (satellite precipitation)
*                SRMOSAIC             (sateliite-radar mosaic)
*                SGMOSAIC             (sateliite-gage  mosaic)
*                SRGMOSAIC            (sateliite-radar-gage mosaic)
*                RFCBMOSAIC           (RFC bias-corrected radar mosaic)
*                RFCMMOSAIC           (RFC bias-corrected multisensor mosaic)
*
*                The Best Estimate QPE (formerly xmrg) field is always
*                created so it is not part of this list.
*
*                This routine checks the Best Estimate QPE field specified
*                by the user in the mpe_qpe_fieldtype token.   It then checks
*                the mpe_generate_list to make sure that all products are
*                which are necessary to create the Best Estimate QPE are
*                specified.  If the mpe_generate_list token does not
*                contain all the necessary products, this routine will add
*                them.
*
*                The product dependencies are as follows:
*
*                Best QPE       Minimum set of products specified
*                               in mpe_generate_list token.
*                --------       ---------------------------------
*                BMOSAIC    -   RMOSAIC, BMOSAIC
*                GAGEONLY   -   RMOSAIC, GAGEONLY*
*                LMOSAIC    -   RMOSAIC, LMOSAIC
*                LSATPRE    -   RMOSAIC, SATPRE,  LSATPRE
*                MLMOSAIC   -   RMOSAIC, LMOSAIC, MLMOSAIC
*                MMOSAIC    -   RMOSAIC, BMOSAIC, MMOSAIC
*                RMOSAIC    -   RMOSAIC
*                SATPRE     -   SATPRE
*
*                Note if the Best QPE is GAGEONLY, RMOSAIC is only a
*                dependency if the mpe_del_gage_zeros token is
*                "ON".
*
*                If the user-specified Best QPE is not valid, then it
*                defaults to MMOSAIC.  Any invalid entries in the
*                the mpe_generate_list token are ignored.
*
*                The first call to this routine checks the tokens and
*                stores the results.  This information is statically buffered
*                so that subsequent calls to this function are quick and
*                efficient.
*
*                The user passes in the name of the field to check the state
*                off.  The function returns the state in the state variable.
*                A state of 0 means that the product will not be created
*                by MPE FieldGen.  A state of 1 means that the product will be
*                created by MPE FieldGen
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME          DESCRIPTION/UNITS
*   Input  char *      product       The MPE product to check.
*   Input  int *       product_len   The length of the product string.
*   Input  int *       verbose       Output the contents of the
*                                    mpe_generate_list, mpe_qpe_fieldtype,
*                                    and mpe_del_gage_zeros tokens to stdout.
*                                    Output error messages to stderr.
*                                    0 = no verbose, 1 = yes verbose.
*   Output int *       state         The state of the MPE product derived
*                                    from the mpe_qpe_fieldtype and
*                                    mpe_generate_list tokens.  0 means it
*                                    will not be generated by MPE FieldGen.
*                                    1 means it will be.
*   Output int *       exit_status   Contains the error code of this routine.
*
*
* RETURNS:
*   None.
*
* APIs UTILIZED:
*   NAME                HEADER FILE    DESCRIPTION
*   chglower            GeneralUtil.h  Changes all the characters in a string
*                                      to lower case.
*   chgupper            GeneralUtil.h  Changes all the characters in a string
*                                      to upper case.
*   derive_field_dependencies static   For each product specified by the
*                                      mpe_qpe_fieldtype and mpe_generate_list
*                                      tokens, make sure all dependencies
*                                      are met.  This function is called
*                                      recursively.
*   get_apps_defaults   GeneralUtil.h  Retrieves the values of application
*                                      control tokens.
*   strip_lblanks       GeneralUtil.h  Removes leading blank spaces from a
*                                      string.
*   strip_tblanks       GeneralUtil.h  Removes trailing blank spaces from a
*                                      string.
*
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                         DESCRIPTION
*   char [ ]   mpe_del_gage_zeros_reply     Contains the value of the
*                                           mpe_del_gage_zeros token.
*   char *     mpe_del_gage_zeros_token     Contains the name of the
*                                           mpe_del_gage_zeros_token.
*   char [ ]   mpe_generate_list_reply      Contains the value of the
*                                           mpe_generate_list token.
*   char [ ]   mpe_generate_list_token      Contains the name of the
*                                           mpe_generate_list token.
*   char [ ]   mpe_qpe_fieldtype            Contains the value of the
*                                           mpe_qpe_fieldtype token.
*   char *     pChar                        Used to point to string tokens
*                                           created by strtok.
*   char *     pString                      Used to point to dynamically
*                                           allocated strings.
*   int        first_call                   Indicates if this is the first
*                                           time this routine has been called.
*   int        i                            Loop indexing variable.
*   int [ ]    mpe_field_states             Array of flags indicating which
*                                           mpe products will be created
*                                           by MPE FieldGen.
*   int        mpe_qpe_fieldtype_len        The length of the type
*                                           in the mpe_qpe_fieldtype array.
*   int        request_len                  The length of a request sent
*                                           to get_apps_defaults.
*   int        reply_len                    The length of a reply from
*                                           get_apps_defaults.
*   int        status                       Used for testing string comparison
*                                           results.
*   enum MpeBestProdList best_prod          The MPE product to use as
*                                           the best estimate QPE.
*   enum MpeBestProdList base_prod          The MPE radar mosaic used
*                                           as the base for all other MPE
*                                           products.
*
* DATA FILES AND/OR DATABASE:
*   None.
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    This routine was able to function
*                                           until completion.
*    -1                                     This routine terminated due to
*                                           an unrecoverable error.  This
*                                           is either a memory allocation
*                                           error or the bestfield array
*                                           is not large enough to contain
*                                           the best qpe field name.
*    -2                                     The supplied product is not
*                                           recognized.
*    ( These values are returned in the exit_status parameter)
********************************************************************************
*/

/* The best product specified by the mpe_qpefield_type token.  Set to
   the multisensor mosaic by default. */
static enum MpeBestProdList best_prod = MMOSAIC ;
static enum MpeBestProdList base_prod = RMOSAIC ;

void get_mpe_product_state ( const char * product , const int * product_len ,
			     const int * verbose , int * state ,
			     int * exit_status )
{
   static char mpe_base_radar_field [ BESTFIELD_LEN ] = { '\0' };
   static char mpe_base_radardp_field [ BESTFIELD_LEN ] = { '\0' };
   static char * mpe_del_gage_zeros_token = MPE_DEL_GAGE_ZEROS_TOKEN ;
   char mpe_del_gage_zeros_reply [ MPE_PRODUCT_REPLY_LEN ] = { '\0' } ;
   char mpe_generate_areal_qpe_reply [ MPE_PRODUCT_REPLY_LEN ] = {'\0'};
   static char * mpe_generate_list_token = MPE_GENERATE_LIST_TOKEN ;
   char mpe_generate_list_reply [ MPE_GENERATE_LIST_REPLY_LEN ] = { '\0' } ;
   static char mpe_qpe_fieldtype [ BESTFIELD_LEN] = { '\0' } ;
   char * pChar = NULL ;
   char * pString = NULL ;
   static int first_call = 1 ;
   int i ;
   static int mpe_field_states [ NUM_BEST_PRODUCTS ] = { 0 } ;
   int mpe_base_radar_len = BESTFIELD_LEN;
   int mpe_base_radardp_len = BESTFIELD_LEN;
   int mpe_qpe_fieldtype_len = BESTFIELD_LEN ;
   int request_len ;
   int reply_len ;
   int status ;

   * exit_status = 0 ;
   * state = 0 ;

   /* The first time this routine is called, process the mpe_generate_list
      and the mpe_qpe_fieldtype tokens. Resolve all product dependencies. */
   if ( first_call == 1 )
   {
      first_call = 0 ;
      memset ( mpe_generate_list_reply , '\0' , MPE_PRODUCT_REPLY_LEN ) ;

      /* Get the value of the mpe_qpe_fieldtype token. */
      get_mpe_qpe_fieldtype ( verbose , mpe_qpe_fieldtype ,
                              & mpe_qpe_fieldtype_len , exit_status ) ;

      if ( ( * exit_status ) != 0 )
      {
         * exit_status = -1 ;
         return ;
      }

      /* Set the best qpe product in the mpe field states array to ON. */
      mpe_field_states [ best_prod ] = 1 ;


      /* Get the radar mosaic the user has chosen as the base for the
         MPE radar SP derived products. */
      get_mpe_base_radar ( verbose , mpe_base_radar_field ,
                           & mpe_base_radar_len , exit_status );
      if ( ( * exit_status ) != 0 )
      {
         * exit_status = -1 ; 
         return ;
      }

      /* Get the radar mosaic the user has chosen as the base for the 
         MPE radar DP derived products. */
      get_mpe_base_radardp ( verbose , mpe_base_radardp_field , 
                           & mpe_base_radardp_len , exit_status );

      if ( ( * exit_status ) != 0 )
      {
         * exit_status = -1 ;
         return ;
      }


      /* Set the mpe_product_states array to reflect that this
         product must be generated. */
      mpe_field_states [ base_prod ] = 1;


      /* Get the value of the mpe_generate_list token. */
      request_len = strlen ( mpe_generate_list_token ) ;
      status = get_apps_defaults ( mpe_generate_list_token ,
                                   & request_len ,
                                   mpe_generate_list_reply ,
                                   & reply_len ) ;

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         /* Clear out the mpe_generate_list reply array. */
         /* Error message. */
         if ( * verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the MPE generate product list to\n"
                               "empty.\n" , mpe_generate_list_token ) ;
         }

         memset ( mpe_generate_list_reply , '\0' , MPE_GENERATE_LIST_REPLY_LEN ) ;
      }
      printf("get_mpe_product_state(): mpe_generate_list_reply = :%s: characters in mpe_generate_list_reply = %d  max = %d\n", mpe_generate_list_reply,
    		  strlen(mpe_generate_list_reply), MPE_GENERATE_LIST_REPLY_LEN);

      /* Get the value of the mpe_del_gage_zeros token. */
      request_len = strlen ( mpe_del_gage_zeros_token ) ;
      status = get_apps_defaults ( mpe_del_gage_zeros_token ,
                                   & request_len ,
                                   mpe_del_gage_zeros_reply ,
                                   & reply_len ) ;

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         /* No value for mpe_del_gage_zeros found.  Print a message.
            Turn off mpe_del_gage_zeros. */
         if ( * verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the mpe delete gage zeros to 'Off'.\n",
                               mpe_del_gage_zeros_token ) ;
         }
      }
      else
      {

         chgupper ( mpe_del_gage_zeros_reply ) ;
         status = strcmp ( mpe_del_gage_zeros_reply , "ON" ) ;

         if ( status == 0 )
         {
            mpe_del_gage_zeros = 1 ;
         }
      }

      /* Log the values of the mpe_qpe_fieldtype, mpe_del_gage_zeros,
         mpe_base_radar_mosaic, and mpe_generate_list tokens. */
      if ( * verbose == 1 )
      {
         flogMessage ( stdout, "\nmpe_qpe_fieldtype token: %s\n" ,
	   	           mpe_qpe_fieldtype ) ;
         flogMessage ( stdout, "\nmpe_generate_list token: %s\n" ,
	   	           mpe_generate_list_reply ) ;
         flogMessage ( stdout, "\nmpe_base_radar_field: %s\n" ,
                           mpe_base_radar_field ) ;
         flogMessage ( stdout, "\nmpe_del_gage_zeros token: %s\n" ,
   		           mpe_del_gage_zeros_reply ) ;
      }

      /* Process the mpe_generate_list token fields. */
      /* Make sure that these are upper case. Removed leading and trailing
         spaces. Make sure they are valid. */
      pChar = strtok ( mpe_generate_list_reply , "," ) ;

      while ( pChar != NULL )
      {

         request_len = strlen ( pChar ) ;
         pString = ( char * ) malloc ( sizeof ( char ) * request_len + 1 ) ;

         if ( pString == NULL )
         {
             /* Memory allocation error.  Error Message. */
             if ( * verbose == 1 )
             {
                flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                                   "Failed to allocate %d bytes of memory.\n" ,
                                   ( sizeof ( char ) * request_len + 1 ) ) ;
             }

             * exit_status = -1 ;
             return ;
         }

         memset ( pString , '\0' , request_len + 1 ) ;
         strcpy ( pString , pChar ) ;

         /* Remove leading and trailing spaces. */
         strip_tblanks ( pString ) ;
         strip_lblanks ( pString ) ;
         chgupper ( pString ) ;

         for ( i = 0 ; i <  NUM_BEST_PRODUCTS ; ++ i )
         {
            status = strcmp ( pString , mpe_qpe_fields [ i ] ) ;

            if ( status == 0 )
            {
               mpe_field_states [ i ] = 1 ;
               break ;
            }
         }

         if ( status != 0 )
         {
            /* One of the fields in the mpe_generate_list token is
               invalid. */
            /* Error Message. */
            if ( * verbose == 1 )
            {
               flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                                  "token %s in token %s is invalid. Ignored.\n",
                                  mpe_generate_list_token , pString ) ;
            }
         }

         if ( pString != NULL )
         {
            free ( pString ) ;
            pString = NULL ;
         }

         pChar = strtok ( NULL , "," ) ;
      }

      /* Need to handle the RFCMOSAIC in a special way.  It
         only works if the mpe_generate_areal_qpe token is set to
         'ON'. */
      request_len = strlen ("mpe_generate_areal_qpe");

      get_apps_defaults ("mpe_generate_areal_qpe", &request_len,
                         mpe_generate_areal_qpe_reply, &reply_len);

      if (reply_len > 0)
      {
         status = strcasecmp (mpe_generate_areal_qpe_reply, "ON");

         if (status == 0)
         {
            mpe_field_states [ RFCMOSAIC ] = 1;
         }
         else
         {
            mpe_field_states [ RFCMOSAIC ] = 0;
         }
      }
      else
      {
         mpe_qpe_fields [ RFCMOSAIC ] = 0;
      }

      /* For each field which is specified by the mpe_generate_list and
         mpe_qpe_fieldtype tokens make sure all dependencies are
         generated as well. */
      for ( i = 0; i < NUM_BEST_PRODUCTS; ++ i )
      {
         if ( mpe_field_states [ i ] == 1 )
         {
            /* Derive the dependencies. */
            * exit_status = derive_field_dependencies ( * verbose, i,
                                                        mpe_field_states ) ;

            if ( * exit_status != 0 )
            {
               * exit_status = -1 ;

               if ( * verbose == 1 )
               {
                  flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                                     "Could not derive product "
                                     "dependencies.\n" );
               }

               return ;
            }
         }
      }
   }

   /* The product string is immutable.  Must make a local copy of it here. */
   pString = ( char * ) malloc ( sizeof ( char ) * ( * product_len ) + 1 ) ;

   if ( pString == NULL )
   {
      /* Memory allocation failure.  Report Error. */
     if ( * verbose == 1 )
     {
        flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                           "Failed to allocated %d bytes of memory.\n" ,
                           ( sizeof ( char ) * ( * product_len  ) + 1 ) ) ;
     }

     * exit_status = -1 ;
   }

   memset ( pString , '\0' , ( * product_len ) + 1 ) ;
   strncpy ( pString , product , * product_len ) ;

   /* Trim any leading and trailing spaces off of it. */
   strip_tblanks ( pString ) ;
   strip_lblanks ( pString ) ;

   /* Make sure that the product is all uppercase. */
   chgupper ( pString ) ;

   for ( i = 0 ; i < NUM_BEST_PRODUCTS ; ++ i )
   {
      status = strcmp  ( pString , mpe_qpe_fields [ i ] ) ;

      if ( status == 0 )
      {
         break ;
      }
   }

   if ( status == 0 )
   {
      * state = mpe_field_states [ i ] ;
   }
   else
   {
      * exit_status = -2 ;
   }

   if ( pString != NULL )
   {
      free ( pString ) ;
      pString = NULL ;
   }

   return ;
}

/*******************************************************************************
* MODULE NUMBER: 3
* MODULE NAME:   get_mpe_qpe_fieldtype
* PURPOSE:       Returns the value of the mpe_qpe_fieldtype token.
*                The first call to this routine calls get_apps_defaults
*                and stores the value of this token in a static variable.
*                Subsequent calls to this routine do not call
*                get_apps_defaults.  They simply return the value of the
*                static variable.
*
*                If there is no value in the mpe_qpe_fieldtype token,
*                then best mpe qpe field defaults to RMOSAIC.
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME          DESCRIPTION/UNITS
*   In     int *       verbose       Verbose output flag. 0 = no output to
*                                    stdout or stderr.  1 = output to stdout
*                                    stderr.
*   In/Out char *      bestfield     The user supplied array into which this
*                                    routine writes the mpe_qpe_fieldtype
*                                    token contents.
*   In/Out int *       bestfield_len The user passes in the capacity of the
*                                    bestfield array using this parameter.
*                                    The length of the mpe qpe fieldname
*                                    is returned in this parameter.
*   Out    int *       exit_status   Contains success or error code.
*
* RETURNS:
*   None
*
* APIs UTILIZED:
*   NAME               HEADER FILE      DESCRIPTION
*   get_apps_defaults  GeneralUtil.h    Returns the value of an application
*                                       control token.
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                     DESCRIPTION
*  char [ ]    mpe_qpe_fieldtype_reply  Contains the value of the
*                                       mpe_qpe_fieldtype token.
*  char *      mpe_qpe_fieldtype_token  Contains the name of the
*                                       mpe_qpe_fieldtype token.
*  int         first_call               Indicates if this is the first time
*                                       this routine has been called.
*  int         i                        Loop indexing variable.
*  int         reply_len                The length of the token
*                                       value returned by call to
*                                       get_apps_defaults.
*  int         request_len              The length of the token name
*                                       supplied to get_apps_defaults.
*  int         status                   Contains the return status of
*                                       get_apps_defaults.
*
* DATA FILES AND/OR DATABASE:
* None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    Routine ran successfully
*    -1                                     Routine failed because
*                                           bestfield array is too small
*                                           to contain best qpe field.
********************************************************************************
*/
void get_mpe_qpe_fieldtype ( const int * verbose , char * bestfield ,
                             int * bestfield_len , int * exit_status )
{
   static char * mpe_qpe_fieldtype_token = MPE_QPE_FIELDTYPE_TOKEN ;
   static char mpe_qpe_fieldtype_reply [ MPE_PRODUCT_REPLY_LEN ] = { '\0' } ;
   static int first_call = 1 ;
   int i ;
   int reply_len ;
   int request_len ;
   int status ;

   * exit_status = 0 ;

   if ( first_call == 1 )
   {
      first_call = 0 ;

      /* Get the value of the mpe_generate_list token. */
      request_len = strlen ( mpe_qpe_fieldtype_token ) ;
      status = get_apps_defaults ( mpe_qpe_fieldtype_token ,
                                   & request_len ,
                                   mpe_qpe_fieldtype_reply ,
                                   & reply_len ) ;

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         if ( * verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_qpe_fieldtype':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the MPE qpe field type to MMOSAIC.\n" ,
                               mpe_qpe_fieldtype_token ) ;
         }

         memset ( mpe_qpe_fieldtype_reply , '\0' , MPE_PRODUCT_REPLY_LEN ) ;
         strcpy ( mpe_qpe_fieldtype_reply , "MMOSAIC" ) ;
         best_prod = MMOSAIC ;
      }
      else
      {
         /* Test to make sure the mpe_qpe_fieldtype is valid. */
         for ( i = 0 ; i < NUM_BEST_PRODUCTS ; ++ i )
         {
            status = strcmp ( mpe_qpe_fieldtype_reply ,
                              mpe_qpe_fields [ i ] ) ;

            if ( status == 0 )
            {
               /* Remember the index of the qpe_fieldtype. */
               best_prod = ( enum MpeBestProdList ) i ;
               break ;
            }
         }

         if ( status != 0 )
         {
            /* The user has supplied an unrecognized field type. */
            if ( * verbose == 1 )
            {
               flogMessage ( stderr , "\nIn routine 'get_mpe_product_state':\n"
                                  "The value of token %s, '%s', is invalid.\n"
                                  "The best estimate qpe type is being set to\n"
                                  "MMOSAIC.\n" , mpe_qpe_fieldtype_token ,
                                   mpe_qpe_fieldtype_reply ) ;
            }

            memset ( mpe_qpe_fieldtype_reply , '\0' , MPE_PRODUCT_REPLY_LEN ) ;
            strcpy ( mpe_qpe_fieldtype_reply , "MMOSAIC" ) ;
            best_prod = MMOSAIC ;
         }
      }
   }

   /* Check to make sure the user-supplied bestfield array is large
      enough to contain the best qpe field name. */
   request_len = strlen ( mpe_qpe_fieldtype_reply ) ;

   if ( ( request_len + 1 ) > ( * bestfield_len ) )
   {
      /* The bestfield array is not large enough. */
      if ( * verbose == 1 )
      {
         flogMessage ( stderr , "\nIn routine 'get_qpe_fieldtype':\n"
                            "The user-supplied bestfield array has capacity\n"
                            "%d. This is too small to contain the best qpe\n"
                            "field name, %s, plus a terminating NULL, length\n"
                            "%d.\n", * bestfield_len , mpe_qpe_fieldtype_reply ,
                            ( request_len + 1 ) ) ;
      }

      * bestfield_len = 0 ;
      * exit_status = -1 ;
   }
   else
   {
      /* The bestfield array is of an acceptable size.  Copy the
         mpe qpe field type into the best array.  Return the length
         of the mpq qpe field type. */
      memset ( bestfield , '\0' , * bestfield_len ) ;
      strcpy ( bestfield , mpe_qpe_fieldtype_reply ) ;
      * bestfield_len = strlen ( bestfield ) ;
   }

   return ;
}

/*******************************************************************************
* MODULE NUMBER: 4
* MODULE NAME:   get_mpe_fields_array
* PURPOSE:       This routine returns
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME                 DESCRIPTION/UNITS
*
* RETURNS:
*   DATA TYPE   NAME                        DESCRIPTION
*
* APIs UTILIZED:
*   NAME                                    HEADER FILE DESCRIPTION
*
* LOCAL DATA ELEMENTS (OPTIONAL):
*   DATA TYPE  NAME                         DESCRIPTION
*
* DATA FILES AND/OR DATABASE:
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*
********************************************************************************
*/
const char ** get_qpe_fields_array ( )
{
   return mpe_qpe_fields ;
}

/*******************************************************************************
* MODULE NUMBER: 4
* MODULE NAME:   get_mpe_base_radar
* PURPOSE:       Returns the value of the mpe_base_radar_mosaic token.
*                The first call to this routine calls get_apps_defaults
*                and stores the value of this token in a static variable.
*                Subsequent calls to this routine do not call
*                get_apps_defaults.  They simply return the value of the
*                static variable.
*
*                If there is no value in the mpe_base_radar_mosaic token,
*                then base radar mosaic defaults to RMOSAIC.
*
* ARGUMENTS:
*   TYPE   DATA TYPE NAME             DESCRIPTION/UNITS
*   In     int *     verbose          Verbose output flag. 0 = no output to
*                                     stdout or stderr.  1 = output to stdout
*                                     stderr.
*   In/Out char *    base_radar_field The user supplied array into which this
*                                     routine writes the mpe_base_radar_mosaic
*                                     token contents.
*   In/Out int *     basefield_len    The user passes in the capacity of the
*                                     bestfield array using this parameter.
*                                     The length of the mpe qpe fieldname
*                                     is returned in this parameter.
*   Out    int *     exit_status      Contains success or error code.
*
* RETURNS:
*   None
*
* APIs UTILIZED:
*   NAME               HEADER FILE      DESCRIPTION
*   get_apps_defaults  GeneralUtil.h    Returns the value of an application
*                                       control token.
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                     DESCRIPTION
*  char [ ]    mpe_qpe_fieldtype_reply  Contains the value of the
*                                       mpe_qpe_fieldtype token.
*  char *      mpe_qpe_fieldtype_token  Contains the name of the
*                                       mpe_qpe_fieldtype token.
*  int         first_call               Indicates if this is the first time
*                                       this routine has been called.
*  int         i                        Loop indexing variable.
*  int         reply_len                The length of the token
*                                       value returned by call to
*                                       get_apps_defaults.
*  int         request_len              The length of the token name
*                                       supplied to get_apps_defaults.
*  int         status                   Contains the return status of
*                                       get_apps_defaults.
*
* DATA FILES AND/OR DATABASE:
* None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    Routine ran successfully
*    -1                                     Routine failed because
*                                           bestfield array is too small
*                                           to contain best qpe field.
********************************************************************************
*/
void get_mpe_base_radar ( const int * verbose , char * base_radar_field ,
                          int * baseradar_len , int * exit_status )
{
   static char * mpe_base_radar_mosaic_token = MPE_BASE_RADAR_MOSAIC_TOKEN ;
   static char mpe_base_radar_mosaic_reply [ MPE_PRODUCT_REPLY_LEN ] = {'\0'} ;
   static int first_call = 1 ;
   int i ;
   int reply_len ;
   int request_len ;
   int status ;

   * exit_status = 0 ;

   if ( first_call == 1 )
   {
      first_call = 0 ;

      /* Get the value of the mpe_generate_list token. */
      request_len = strlen ( mpe_base_radar_mosaic_token ) ;
      status = get_apps_defaults ( mpe_base_radar_mosaic_token ,
                                   & request_len ,
                                   mpe_base_radar_mosaic_reply ,
                                   & reply_len ) ;

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         if ( * verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_base_radar':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the MPE base radar mosaic to "
                               "RMOSAIC.\n", mpe_base_radar_mosaic_token ) ;
         }

         memset ( mpe_base_radar_mosaic_reply , '\0' , MPE_PRODUCT_REPLY_LEN ) ;
         strcpy ( mpe_base_radar_mosaic_reply , "RMOSAIC" ) ;
         base_prod = RMOSAIC;
      }
      else
      {
         /* Test to make sure the mpe_base_radar_mosaic_reply is valid. */
         for ( i = 0 ; i < NUM_BASE_RADAR_MOSAICS ; ++ i )
         {
            status = strcmp ( mpe_base_radar_mosaic_reply ,
                              mpe_base_radar_mosaics [ i ] ) ;

            if ( status == 0 )
            {
               break ;
            }
         }

         if ( status != 0 )
         {
            /* The user has supplied an unrecognized base radar mosaic. */
            if ( * verbose == 1 )
            {
               flogMessage ( stderr , "\nIn routine 'get_mpe_base_radar':\n"
                                  "The value of token %s, '%s', is invalid.\n"
                                  "The base radar mosaic is being set to\n"
                                  "RMOSAIC.\n" , mpe_base_radar_mosaic_token ,
                                   mpe_base_radar_mosaic_reply ) ;
            }

            memset ( mpe_base_radar_mosaic_reply , '\0' ,
                     MPE_PRODUCT_REPLY_LEN ) ;
            strcpy ( mpe_base_radar_mosaic_reply , "RMOSAIC" ) ;
            base_prod = RMOSAIC ;
         }
         else
         {
            /* Find the index of this product in the main list of MPE
               qpe products. */
            for ( i = 0 ; i < NUM_BEST_PRODUCTS ; ++ i )
            {
               status = strcmp ( mpe_base_radar_mosaic_reply ,
                                 mpe_qpe_fields [ i ] ) ;

               if ( status == 0 )
               {
                  /* Remember the index of the qpe_fieldtype. */
                  base_prod = ( enum MpeBestProdList ) i ;
                  break ;
               }
            }
         }
      }
   }

   /* Check to make sure the user-supplied base_radar_field array is large
      enough to contain the base radar product name. */
   request_len = strlen ( mpe_base_radar_mosaic_reply ) ;

   if ( ( request_len + 1 ) > ( * baseradar_len ) )
   {
      /* The base_radar_field array is not large enough. */
      if ( * verbose == 1 )
      {
         flogMessage ( stderr , "\nIn routine 'get_mpe_base_radar':\n"
                            "The user-supplied base_radar_field array has "
                            "capacity %d. This is too small to contain the\n"
                            "base field name, %s, plus a terminating "
                            "NULL, length %d.\n", * baseradar_len ,
                            mpe_base_radar_mosaic_reply ,
                            ( request_len + 1 ) ) ;
      }

      * baseradar_len = 0 ;
      * exit_status = -1 ;
   }
   else
   {
      /* The baseradar_field array is of an acceptable size.  Copy the
         mpe qpe field type into the best array.  Return the length
         of the mpq qpe field type. */
      memset ( base_radar_field , '\0' , * baseradar_len ) ;
      strcpy ( base_radar_field , mpe_base_radar_mosaic_reply ) ;
      * baseradar_len = strlen ( base_radar_field ) ;
   }

   return ;

}

void get_mpe_base_radardp ( const int * verbose , char * base_radar_field , 
                          int * baseradar_len , int * exit_status )
{
   static char * mpe_base_radardp_mosaic_token = MPE_BASE_RADARDP_MOSAIC_TOKEN ;
   static char mpe_base_radar_mosaic_reply [ MPE_PRODUCT_REPLY_LEN ] = {'\0'} ;
   static int firstdp_call = 1 ;
   int i ;
   int reply_len ;
   int request_len ;
   int status ;
   
   * exit_status = 0 ;

   if ( firstdp_call == 1 )
   {
      firstdp_call = 0 ;

      /* Get the value of the mpe_base_radardp_mosaic_token token */
      request_len = strlen ( mpe_base_radardp_mosaic_token ) ;
      status = get_apps_defaults ( mpe_base_radardp_mosaic_token ,
                                   & request_len ,
                                   mpe_base_radar_mosaic_reply ,
                                   & reply_len ) ; 

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         if ( * verbose == 1 )
         {
            flogMessage ( stderr , "\nIn routine 'get_mpe_base_radardp':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the MPE base radar mosaic to "
                               "RDMOSAIC.\n", mpe_base_radardp_mosaic_token ) ;
         }
         
         memset ( mpe_base_radar_mosaic_reply , '\0' , MPE_PRODUCT_REPLY_LEN ) ;
         strcpy ( mpe_base_radar_mosaic_reply , "RDMOSAIC" ) ;
         base_prod = RDMOSAIC;
      }
      else
      {
         /* Test to make sure the mpe_base_radar_mosaic_reply is valid. */
         for ( i = 0 ; i < NUM_BASE_RADAR_MOSAICS ; ++ i )
         {
            status = strcmp ( mpe_base_radar_mosaic_reply ,  
                              mpe_base_radardp_mosaics [ i ] ) ;

            if ( status == 0 )
            {
               break ;
            }
         }

         if ( status != 0 )
         {
            /* The user has supplied an unrecognized base radar mosaic. */
            if ( * verbose == 1 )
            {
               flogMessage ( stderr , "\nIn routine 'get_mpe_base_radardp':\n"
                                  "The value of token %s, '%s', is invalid.\n"
                                  "The base radar mosaic is being set to\n"
                                  "RDMOSAIC.\n" , mpe_base_radardp_mosaic_token ,
                                   mpe_base_radar_mosaic_reply ) ;
            }

            memset ( mpe_base_radar_mosaic_reply , '\0' , 
                     MPE_PRODUCT_REPLY_LEN ) ;
            strcpy ( mpe_base_radar_mosaic_reply , "RDMOSAIC" ) ;
            base_prod = RDMOSAIC ; 
         }
         else
         {

            printf("get_mpe_base_radardp(): mpe_base_radar_mosaic_reply = :%s:\n", mpe_base_radar_mosaic_reply);

            /* Find the index of this product in the main list of MPE
               qpe products. */
            for ( i = 0 ; i < NUM_BEST_PRODUCTS ; ++ i )
            {
               status = strcmp ( mpe_base_radar_mosaic_reply ,  
                                 mpe_qpe_fields [ i ] ) ;
   
               if ( status == 0 )
               {
                  /* Remember the index of the qpe_fieldtype. */
                  base_prod = ( enum MpeBestProdList ) i ;
    
                  printf("get_mpe_base_radardp(): base_prod = %d\n", base_prod);

                  break ;
               }
            }
         }
      }
   }

   /* Check to make sure the user-supplied base_radar_field array is large 
      enough to contain the base radar product name. */ 
   request_len = strlen ( mpe_base_radar_mosaic_reply ) ;
   
/*
   sprintf ( message , "In get_mpe_base_radardp\n");
   printMessage( message, logFile );

   sprintf ( message , "baseradar_len = %d\n", * baseradar_len);
   printMessage( message, logFile );

   sprintf ( message , "request_len = %d\n", request_len);
   printMessage( message, logFile );
*/

   if ( ( request_len + 1 ) > ( * baseradar_len ) )
   {
      /* The base_radar_field array is not large enough. */
      if ( * verbose == 1 )
      {
         flogMessage ( stderr , "\nIn routine 'get_mpe_base_radardp':\n"
                            "The user-supplied base_radardp_field array has "
                            "capacity %d. This is too small to contain the\n"
                            "base field name, %s, plus a terminating "
                            "NULL, length %d.\n", * baseradar_len , 
                            mpe_base_radar_mosaic_reply ,
                            ( request_len + 1 ) ) ;
      }

      * baseradar_len = 0 ;
      * exit_status = -1 ;
   }
   else
   {
      /* The baseradar_field array is of an acceptable size.  Copy the
         mpe qpe field type into the best array.  Return the length
         of the mpq qpe field type. */
      memset ( base_radar_field , '\0' , * baseradar_len ) ;
      strcpy ( base_radar_field , mpe_base_radar_mosaic_reply ) ;
      * baseradar_len = strlen ( base_radar_field ) ; 
   }

/*
   sprintf ( message , "base_radar_field = %s\n",base_radar_field);
   printMessage( message, logFile );

   sprintf ( message , "baseradar_len = %d\n", * baseradar_len);
   printMessage( message, logFile );

   sprintf ( message , "exit_status = %d\n", * exit_status);
   printMessage( message, logFile );
*/

   return ;

}

/*
 * This is a simpler version of get_mpe_product_state()
 * Returns non-zero to mean true
 */
int isInGenerateList(const char * qpeFieldName)
{
    int inGenerateList = 0;

    int length = strlen(qpeFieldName);
    int verbose = 1;
    int result_status;

    //void get_mpe_product_state ( const char * product , const int * product_len ,
    //const int * verbose , int * state ,
    //int * exit_status )

    get_mpe_product_state(qpeFieldName, &length, &verbose,
                      &inGenerateList, &result_status) ;

    return inGenerateList;


/*  ==============  Statements containing RCS keywords:  */
{static char rcs_id1[] = "$Source: /fs/hseb/ob9e/ohd/pproc_lib/src/MPEUtil/RCS/get_mpe_product_state.c,v $";
 static char rcs_id2[] = "$Id: get_mpe_product_state.c,v 1.14 2012/05/30 19:12:24 pst Exp $";}
/*  ===================================================  */

}
