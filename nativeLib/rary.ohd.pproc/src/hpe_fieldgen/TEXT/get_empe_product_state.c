/*******************************************************************************
* FILENAME:             get_empe_product_state.c
* NUMBER OF MODULES:    1
* GENERAL INFORMATION:
*   MODULE 1:           derive_field_dependencies ( static )
* DESCRIPTION:          For a given EMPE product derives all products which
*                       are needed to produce it.
*   MODULE 2:           get_empe_product_state
* DESCRIPTION:          Indicates whether a given EMPE product will or will
*                       not be generated by EMPE FieldGen. 
*
* ORIGINAL AUTHOR:      Bryon Lawrence
* CREATION DATE:        September 28, 2004
* ORGANIZATION:         OHD-11, HSEB
* MACHINE:              IBM PC, LINUX
* MODIFICATION HISTORY:
*   MODULE #        DATE         PROGRAMMER        DESCRIPTION/REASON
*          2        9/28/04      Bryon Lawrence    First Coding
*          2        11/10/04     Bryon Lawrence    Fixed a bug that 
*                                                  could result in
*                                                  unresolved dependencies
*          2        11/10/04     Bryon Lawrence    Added check of the
*                                                  empe_del_gage_zeros token.
*          2        10/04/05     Bryon Lawrence    Added the check of the token
*                                                  which determines which 
*                                                  radar mosaic is used 
*                                                  as the base of all of the
*                                                  EMPE mosaics.
********************************************************************************
*/
#include <stdlib.h>
#include <string.h>

#include "get_empe_product_state.h"
#include "GeneralUtil.h"

/* Define the EMPE base radar mosaic list. */
const static char * empe_base_radar_mosaics [ NUM_EMPE_BASE_RADAR_MOSAICS ] =
                                     { "ERMOSAIC",
                                       "AVGERMOSAIC",
                                       "MAXERMOSAIC" };

/* Define the EMPE product generation rules. */
const static char * empe_qpe_fields [ NUM_EMPE_BEST_PRODUCTS ] =
                                     { "DHRMOSAIC",
                                       "BDHRMOSAIC",
                                       "ERMOSAIC",
                                       "AVGERMOSAIC",
                                       "MAXERMOSAIC",
                                       "P3LMOSAIC",
                                       "MMOSAIC",
                                       "EBMOSAIC",
                                       "LMOSAIC",
                                       "MLMOSAIC",
                                       "GAGEONLY",
                                       "SATPRE",
                                       "LSATPRE" 
                                        } ;


const static char * empe_qpe_dependencies [ NUM_EMPE_BEST_PRODUCTS ] =
                                        { "",
                                          "DHRMOSAIC",
                                          "",
                                          "",
                                          "",
                                          "ERMOSAIC", 
                                          "ERMOSAIC,EBMOSAIC" ,
                                          "ERMOSAIC" ,
                                          "ERMOSAIC" ,
                                          "ERMOSAIC,LMOSAIC" ,
                                          "ERMOSAIC",
                                          "" ,
                                          "ERMOSAIC,SATPRE"
                                           } ;


/* GageOnly Generation rule in case empe_del_gage_zeros token is OFF. */
const static char * gageonly_del_gages_off = "" ;


/*******************************************************************************
* MODULE NUMBER: 1
* MODULE NAME:   derive_field_dependencies
* PURPOSE:       For a given EMPE product and the dependency grammar,
*                this routine derives all depencies needed to create that
*                product.
*                
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME             DESCRIPTION/UNITS
*   Input  int         verbose          0 = Do not output to stdout or stderr.
*                                       1 = Do output to stdout and stderr.
*   Input  int         index            This corresponds to the
*                                       MpeBestProdList enumeration. 
*   I/O    int [ ]     empe_field_states This contains an element for each
*                                       type in the MpeBestProdList 
*                                       enumeration (except for the 
*                                       NUM_EMPE_BEST_PRODUCTS type).  The
*                                       index argument is used with this
*                                       array to indicate which product
*                                       dependencies need to be derived for.
*                                       Also, this array contains the
*                                       state (0=OFF,1=ON) of each 
*                                       supported product.
*
* RETURNS:
*   DATA TYPE     DESCRIPTION
*   int           The return status of this routine.  0 = Ok. A nonzero value
*                 means an error was encountered.
* APIs UTILIZED:
*   Only  C Library APIs are called.
*   
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME          DESCRIPTION
*   char *     pChar          Points to the next ',' character.
*   char *     pDependencies  Points to EMPE products the EMPE product being
*                             processed is dependent on.
*   char *     pEnd           Used to point to the end of the dependency 
*                             string.
*   char *     pString        Used to point to the start of the dependency 
*                             string.
*   char *     pToken         Used to point to the current EMPE product being
*                             processed in the list of dependencies. 
*   int i                     A loop index.
*   int request_len           The length of the string pointed to by pToken.
*   int status                Contains return codes for testing.
*
* DATA FILES AND/OR DATABASE:
*   None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0                                      This routine worked.
*    Non Zero                               Something went wrong.
********************************************************************************
*/

/* Contains the value of the hpe_del_gage_zeros token.  If the value of
   this token is "ON", then when creating the GageOnly field, ignore gage
   values of 0 if the corresponding grid bin in the ERMOSAIC has a value 
   greather than 0. 

   If the value of the hpe_del_gage_zeros token is "OFF", then do not use the
   ERMOSAIC in the creation of the GageOnly Field. */ 
   
static int empe_del_gage_zeros = 0 ;

static int derive_field_dependencies ( int verbose, int index, 
                                       int empe_field_states 
                                                    [ NUM_EMPE_BEST_PRODUCTS ] )
{
   char * pChar = NULL ;
   const char * pDependencies = NULL ;
   char * pEnd = NULL ;
   char * pString = NULL ;
   char * pToken = NULL ;
   int i ;
   int request_len ;
   int status = 0 ;

   /* Check if this is the GageOnly field.  Whether or not the GageOnly 
      field depends on RMOSIAC is determined by the hpe_del_gage_zeros
      token. */ 
   if ( ( index == GAGEONLY ) && ( empe_del_gage_zeros == 0 ) )
   {
      /* Dependency rules without ERMOSAIC. */
      pDependencies = gageonly_del_gages_off ;
   }
   else
   {
      /* Dependency rules with ERMOSAIC. */
      pDependencies = empe_qpe_dependencies [ index ] ;
   }
        
   request_len = strlen ( pDependencies ) ; 

   /* An empty product dependency list indicates no dependencies
      need to be checked. If the dependency list is empty, then
      stop recursion. */
   if ( request_len > 0 )
   {
      /* Make a local copy of the product dependency list. */
      pString = ( char * ) malloc ( sizeof ( char ) * request_len + 1 ) ;

      if ( pString == NULL )
      {
         /* Dynamic memory allocation failure. */
         /* Error message. */
         if ( verbose == 1 )
         {
            fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                               "Failed to allocate %d bytes of memory.\n" ,
                               ( sizeof ( char ) * request_len + 1 ) ) ; 
         }

         return -1 ;
      }

      memset ( pString , '\0' , request_len + 1 ) ;
      strcpy ( pString , pDependencies ) ;

      pToken = pString ;  
      pEnd = pString + request_len ;
      
      while ( pToken < pEnd ) 
      {
         pChar = strchr ( pToken , ',' ) ;

         if ( pChar != NULL )
         { 
            * pChar = '\0';
         }
         else
         {
            pChar = pEnd - 1 ;
         } 

         /* Skip the ERMOSAIC dependencies.  The value (or default value)
            of the empe_base_radar_mosaic token guarantees that there
            will be a radar mosaic to be the base of all of the EMPE
            products. */
         status = strcmp ( pToken, "ERMOSAIC" );
  
         if ( status != 0 )
         {
            for ( i = 0 ; i <  NUM_EMPE_BEST_PRODUCTS ; ++ i )
            {
               status = strcmp ( pToken , empe_qpe_fields [ i ] ) ;

               if ( status == 0 )
               {
                  if ( empe_field_states [ i ] != 1 ) 
                  {
                     empe_field_states [ i ] = 1 ;
                  
                     /* Log a message. */
                     if ( verbose == 1 )
                     {
                        fprintf ( stderr , "\nIn 'get_hpe_product_state':\n"
                                           "%s must be generated to support\n"
                                           "field %s.\n" ,
                                           empe_qpe_fields [ i ] ,
                                           empe_qpe_fields [ index ] ) ; 
                     }

                     /* Recursively call the derive_field_dependencies
                        routine. */
                     status = derive_field_dependencies ( verbose , i, 
                                                          empe_field_states );

                     if ( status != 0 )
                     {
                        if ( pString != NULL )
                        {
                           free ( pString ) ;
                           pString = NULL ;
                        }
                   
                        return status ;
                     }
                  }

                  break ;
               }
            }
         }

         pToken = pChar + 1 ;
      }

      if ( pString != NULL )
      {
         free ( pString ) ;
         pString = NULL ;
      }
   }
   
   return 0 ;
}

/*******************************************************************************
* MODULE NUMBER: 2
* MODULE NAME:   get_empe_product_state
* PURPOSE:       Indicates whether a given HPE product will or will not
*                be generated by EMPE FieldGen.
*
*                This routine uses the following two tokens to accomplish 
*                this task: 
*
*                empe_qpe_fieldtype - Indicates which EMPE field should be 
*                                    stored as the Best Estimate field.
*                empe_generate_list - A comma separated list of EMPE products
*                                    which EMPE FieldGen should generate.
*
*                The following names are used to represent the products in the
*                empe_generate_list and empe_qpe_fieldtype tokens:
*
*                EBMOSAIC              (field bias mosaic)
*                GAGEONLY             (gage only analysis)
*                LMOSAIC              (local bias mosaic)
*                LSATPRE              (local bias satellite precip field)
*                MLMOSAIC             (local bias multisensor mosaic)
*                MMOSAIC              (multisensor mosaic)
*                ERMOSAIC              (radar mosaic)
*                SATPRE               (satellite precipitation)
*                DHRMOSAIC            (dhr radar mosaic)
*                BDHRMOSAIC           (field bias dhr radar mosaic)
*
*                The Best Estimate QPE (formerly xmrg) field is always
*                created so it is not part of this list.
*
*                This routine checks the Best Estimate QPE field specified
*                by the user in the empe_qpe_fieldtype token.   It then checks
*                the empe_generate_list to make sure that all products are 
*                which are necessary to create the Best Estimate QPE are 
*                specified.  If the empe_generate_list token does not 
*                contain all the necessary products, this routine will add 
*                them. 
*
*                The product dependencies are as follows:
*
*                Best QPE       Minimum set of products specified 
*                               in empe_generate_list token.
*                --------       ---------------------------------
*                EBMOSAIC    -   ERMOSAIC, EBMOSAIC
*                GAGEONLY   -   ERMOSAIC, GAGEONLY*
*                LMOSAIC    -   ERMOSAIC, LMOSAIC
*                LSATPRE    -   ERMOSAIC, SATPRE,  LSATPRE   
*                MLMOSAIC   -   ERMOSAIC, LMOSAIC, MLMOSAIC
*                MMOSAIC    -   ERMOSAIC, EBMOSAIC, MMOSAIC
*                ERMOSAIC    -   ERMOSAIC
*                SATPRE     -   SATPRE
*
*                Note if the Best QPE is GAGEONLY, ERMOSAIC is only a 
*                dependency if the empe_del_gage_zeros token is
*                "ON".
*
*                If the user-specified Best QPE is not valid, then it
*                defaults to ERMOSAIC.  Any invalid entries in the
*                the empe_generate_list token are ignored.
*
*                The first call to this routine checks the tokens and
*                stores the results.  This information is statically buffered
*                so that subsequent calls to this function are quick and
*                efficient.
*
*                The user passes in the name of the field to check the state
*                off.  The function returns the state in the state variable.
*                A state of 0 means that the product will not be created
*                by EMPE FieldGen.  A state of 1 means that the product will be
*                created by EMPE FieldGen
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME          DESCRIPTION/UNITS
*   Input  char *      product       The EMPE product to check.     
*   Input  int *       product_len   The length of the product string.
*   Input  int *       verbose       Output the contents of the
*                                    empe_generate_list, empe_qpe_fieldtype,
*                                    and empe_del_gage_zeros tokens to stdout.
*                                    Output error messages to stderr.
*                                    0 = no verbose, 1 = yes verbose.
*   Output int *       state         The state of the EMPE product derived
*                                    from the empe_qpe_fieldtype and
*                                    empe_generate_list tokens.  0 means it
*                                    will not be generated by EMPE FieldGen.
*                                    1 means it will be.
*   Output int *       exit_status   Contains the error code of this routine. 
*
*
* RETURNS:
*   None.
*
* APIs UTILIZED:
*   NAME                HEADER FILE    DESCRIPTION
*   chglower            GeneralUtil.h  Changes all the characters in a string
*                                      to lower case.
*   chgupper            GeneralUtil.h  Changes all the characters in a string
*                                      to upper case.
*   derive_field_dependencies static   For each product specified by the
*                                      empe_qpe_fieldtype and empe_generate_list
*                                      tokens, make sure all dependencies 
*                                      are met.  This function is called
*                                      recursively.
*   get_apps_defaults   GeneralUtil.h  Retrieves the values of application
*                                      control tokens.
*   strip_lblanks       GeneralUtil.h  Removes leading blank spaces from a
*                                      string.
*   strip_tblanks       GeneralUtil.h  Removes trailing blank spaces from a
*                                      string.
*
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                         DESCRIPTION
*   char [ ]   empe_del_gage_zeros_reply    Contains the value of the 
*                                           empe_del_gage_zeros token. 
*   char *     empe_del_gage_zeros_token     Contains the name of the 
*                                           empe_del_gage_zeros_token. 
*   char [ ]   empe_generate_list_reply      Contains the value of the 
*                                           empe_generate_list token.
*   char [ ]   empe_generate_list_token      Contains the name of the
*                                           empe_generate_list token.     
*   char [ ]   empe_qpe_fieldtype            Contains the value of the
*                                           empe_qpe_fieldtype token.
*   char *     pChar                        Used to point to string tokens
*                                           created by strtok.
*   char *     pString                      Used to point to dynamically
*                                           allocated strings.
*   int        first_call                   Indicates if this is the first
*                                           time this routine has been called.
*   int        i                            Loop indexing variable. 
*   int [ ]    empe_field_states             Array of flags indicating which
*                                           empe products will be created
*                                           by EMPE FieldGen.    
*   int        empe_qpe_fieldtype_len        The length of the type
*                                           in the empe_qpe_fieldtype array.    
*   int        request_len                  The length of a request sent
*                                           to get_apps_defaults.
*   int        reply_len                    The length of a reply from
*                                           get_apps_defaults.
*   int        status                       Used for testing string comparison
*                                           results.
*   enum MpeBestProdList best_prod          The EMPE product to use as 
*                                           the best estimate QPE.
*   enum MpeBestProdList base_prod          The EMPE radar mosaic used
*                                           as the base for all other EMPE
*                                           products. 
*
* DATA FILES AND/OR DATABASE:
*   None.
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    This routine was able to function
*                                           until completion.
*    -1                                     This routine terminated due to
*                                           an unrecoverable error.  This
*                                           is either a memory allocation
*                                           error or the bestfield array
*                                           is not large enough to contain
*                                           the best qpe field name.
*    -2                                     The supplied product is not
*                                           recognized.
*    ( These values are returned in the exit_status parameter)
********************************************************************************
*/

/* The best product specified by the empe_qpefield_type token.  Set to
   the multisensor mosaic by default. */
static enum EmpeBestProdList best_prod = ERMOSAIC ;
static enum EmpeBestProdList base_prod = ERMOSAIC ;

void get_empe_product_state ( const char * product , const int * product_len ,
			     const int * verbose , int * state , 
			     int * exit_status )
{
   static char empe_base_radar_field [ BESTFIELD_LEN ] = { '\0' };
   static char * empe_del_gage_zeros_token = EMPE_DEL_GAGE_ZEROS_TOKEN ;
   char empe_del_gage_zeros_reply [ EMPE_PRODUCT_REPLY_LEN ] = { '\0' } ;
   static char * empe_generate_list_token = EMPE_GENERATE_LIST_TOKEN ;
   char empe_generate_list_reply [ EMPE_PRODUCT_REPLY_LEN ] = { '\0' } ;
   static char empe_qpe_fieldtype [ BESTFIELD_LEN] = { '\0' } ;
   char * pChar = NULL ;
   char * pString = NULL ;
   static int first_call = 1 ;
   int i ;
   static int empe_field_states [ NUM_EMPE_BEST_PRODUCTS ] = { 0 } ;
   int empe_base_radar_len = BESTFIELD_LEN;
   int empe_qpe_fieldtype_len = BESTFIELD_LEN ;
   int request_len ;
   int reply_len ;
   int status ;

   * exit_status = 0 ;
   * state = 0 ;

   /* The first time this routine is called, process the empe_generate_list
      and the empe_qpe_fieldtype tokens. Resolve all product dependencies. */
   if ( first_call == 1 )
   {
      first_call = 0 ;
      memset ( empe_generate_list_reply , '\0' , EMPE_PRODUCT_REPLY_LEN ) ;

      /* Get the value of the empe_qpe_fieldtype token. */ 
      get_empe_qpe_fieldtype ( verbose , empe_qpe_fieldtype , 
                              & empe_qpe_fieldtype_len , exit_status ) ;

      if ( ( * exit_status ) != 0 )
      {
         * exit_status = -1 ; 
         return ;
      }

      /* Set the best qpe product in the empe field states array to ON. */
      empe_field_states [ best_prod ] = 1 ;


      /* Get the radar mosaic the user has chosen as the base for the 
         EMPE radar derived products. */
      get_empe_base_radar ( verbose , empe_base_radar_field , 
                           & empe_base_radar_len , exit_status );

      if ( ( * exit_status ) != 0 )
      {
         * exit_status = -1 ; 
         return ;
      }


      /* Set the empe_product_states array to reflect that this
         product must be generated. */
      empe_field_states [ base_prod ] = 1;


      /* Get the value of the empe_generate_list token. */
      request_len = strlen ( empe_generate_list_token ) ;
      status = get_apps_defaults ( empe_generate_list_token ,
                                   & request_len ,
                                   empe_generate_list_reply ,
                                   & reply_len ) ; 

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         /* Clear out the empe_generate_list reply array. */
         /* Error message. */
         if ( * verbose == 1 )
         {
            fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the HPE generate product list to\n"
                               "empty.\n" , empe_generate_list_token ) ; 
         }

         memset ( empe_generate_list_reply , '\0' , EMPE_PRODUCT_REPLY_LEN ) ;
      }

      /* Get the value of the empe_del_gage_zeros token. */
      request_len = strlen ( empe_del_gage_zeros_token ) ;
      status = get_apps_defaults ( empe_del_gage_zeros_token ,
                                   & request_len ,
                                   empe_del_gage_zeros_reply ,
                                   & reply_len ) ;

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         /* No value for empe_del_gage_zeros found.  Print a message.
            Turn off empe_del_gage_zeros. */
         if ( * verbose == 1 )
         {
            fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the hpe delete gage zeros to 'Off'.\n",
                               empe_del_gage_zeros_token ) ; 
         }
      }
      else
      {
         
         chgupper ( empe_del_gage_zeros_reply ) ;
         status = strcmp ( empe_del_gage_zeros_reply , "ON" ) ;   
       
         if ( status == 0 )
         {
            empe_del_gage_zeros = 1 ; 
         }
      }

      /* Log the values of the empe_qpe_fieldtype, empe_del_gage_zeros,
         empe_base_radar_mosaic, and empe_generate_list tokens. */
      if ( * verbose == 1 )
      {
         fprintf ( stdout, "\nhpe_qpe_fieldtype token: %s\n" , 
	   	           empe_qpe_fieldtype ) ;
         fprintf ( stdout, "\nhpe_generate_list token: %s\n" ,
	   	           empe_generate_list_reply ) ;
         fprintf ( stdout, "\nhpe_base_radar_field: %s\n" ,
                           empe_base_radar_field ) ;
         fprintf ( stdout, "\nhpe_del_gage_zeros token: %s\n" ,
   		           empe_del_gage_zeros_reply ) ;
      }

      /* Process the empe_generate_list token fields. */
      /* Make sure that these are upper case. Removed leading and trailing
         spaces. Make sure they are valid. */
      pChar = strtok ( empe_generate_list_reply , "," ) ;  

      while ( pChar != NULL )
      {

         request_len = strlen ( pChar ) ;
         pString = ( char * ) malloc ( sizeof ( char ) * request_len + 1 ) ;

         if ( pString == NULL )
         {
             /* Memory allocation error.  Error Message. */
             if ( * verbose == 1 )
             {
                fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                                   "Failed to allocate %d bytes of memory.\n" ,
                                   ( sizeof ( char ) * request_len + 1 ) ) ; 
             }

             * exit_status = -1 ;
             return ;
         }

         memset ( pString , '\0' , request_len + 1 ) ;
         strcpy ( pString , pChar ) ;
 
         /* Remove leading and trailing spaces. */
         strip_tblanks ( pString ) ;
         strip_lblanks ( pString ) ;
         chgupper ( pString ) ; 

         for ( i = 0 ; i <  NUM_EMPE_BEST_PRODUCTS ; ++ i )
         {
            status = strcmp ( pString , empe_qpe_fields [ i ] ) ;

            if ( status == 0 )
            {
               empe_field_states [ i ] = 1 ;    
               break ;
            }
         }

         if ( status != 0 )
         {
            /* One of the fields in the empe_generate_list token is 
               invalid. */ 
            /* Error Message. */
            if ( * verbose == 1 )
            {
               fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                                  "token %s in token %s is invalid. Ignored.\n",
                                  empe_generate_list_token , pString ) ; 
            }
         }

         if ( pString != NULL )
         {
            free ( pString ) ;
            pString = NULL ;
         }

         pChar = strtok ( NULL , "," ) ;
      }

      /* For each field which is specified by the empe_generate_list and
         empe_qpe_fieldtype tokens make sure all dependencies are 
         generated as well. */ 
      for ( i = 0; i < NUM_EMPE_BEST_PRODUCTS; ++ i )
      {
         if ( empe_field_states [ i ] == 1 )
         {
            /* Derive the dependencies. */
            * exit_status = derive_field_dependencies ( * verbose, i, 
                                                        empe_field_states ) ;
            
            if ( * exit_status != 0 )
            {
               * exit_status = -1 ;
            
               if ( * verbose == 1 )
               {
                  fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                                     "Could not derive product "
                                     "dependencies.\n" );
               }

               return ;
            }
         }
      }
   }

   /* The product string is immutable.  Must make a local copy of it here. */
   pString = ( char * ) malloc ( sizeof ( char ) * ( * product_len ) + 1 ) ;  
  
   if ( pString == NULL )
   {
      /* Memory allocation failure.  Report Error. */
     if ( * verbose == 1 )
     {
        fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                           "Failed to allocated %d bytes of memory.\n" ,
                           ( sizeof ( char ) * ( * product_len  ) + 1 ) ) ;
     }

     * exit_status = -1 ;
   }

   memset ( pString , '\0' , ( * product_len ) + 1 ) ;
   strncpy ( pString , product , * product_len ) ;

   /* Trim any leading and trailing spaces off of it. */
   strip_tblanks ( pString ) ;
   strip_lblanks ( pString ) ;

   /* Make sure that the product is all uppercase. */
   chgupper ( pString ) ;

   for ( i = 0 ; i < NUM_EMPE_BEST_PRODUCTS ; ++ i )
   {
      status = strcmp  ( pString , empe_qpe_fields [ i ] ) ;

      if ( status == 0 )
      {
         break ;
      }
   }

   if ( status == 0 )
   {
      * state = empe_field_states [ i ] ;
   }
   else
   {
      * exit_status = -2 ;
   }

   if ( pString != NULL )
   {
      free ( pString ) ;
      pString = NULL ;
   }

   return ;
}

/*******************************************************************************
* MODULE NUMBER: 3
* MODULE NAME:   get_empe_qpe_fieldtype
* PURPOSE:       Returns the value of the empe_qpe_fieldtype token.
*                The first call to this routine calls get_apps_defaults
*                and stores the value of this token in a static variable.
*                Subsequent calls to this routine do not call
*                get_apps_defaults.  They simply return the value of the
*                static variable.
*
*                If there is no value in the empe_qpe_fieldtype token,
*                then best empe qpe field defaults to ERMOSAIC.
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME          DESCRIPTION/UNITS
*   In     int *       verbose       Verbose output flag. 0 = no output to
*                                    stdout or stderr.  1 = output to stdout
*                                    stderr.
*   In/Out char *      bestfield     The user supplied array into which this
*                                    routine writes the empe_qpe_fieldtype
*                                    token contents.
*   In/Out int *       bestfield_len The user passes in the capacity of the
*                                    bestfield array using this parameter.
*                                    The length of the empe qpe fieldname
*                                    is returned in this parameter.
*   Out    int *       exit_status   Contains success or error code.
*
* RETURNS:
*   None
*   
* APIs UTILIZED:
*   NAME               HEADER FILE      DESCRIPTION
*   get_apps_defaults  GeneralUtil.h    Returns the value of an application
*                                       control token.
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                     DESCRIPTION
*  char [ ]    empe_qpe_fieldtype_reply  Contains the value of the 
*                                       empe_qpe_fieldtype token.
*  char *      empe_qpe_fieldtype_token  Contains the name of the
*                                       empe_qpe_fieldtype token.
*  int         first_call               Indicates if this is the first time
*                                       this routine has been called.
*  int         i                        Loop indexing variable.
*  int         reply_len                The length of the token
*                                       value returned by call to
*                                       get_apps_defaults.
*  int         request_len              The length of the token name
*                                       supplied to get_apps_defaults.
*  int         status                   Contains the return status of
*                                       get_apps_defaults. 
*
* DATA FILES AND/OR DATABASE:
* None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    Routine ran successfully
*    -1                                     Routine failed because
*                                           bestfield array is too small
*                                           to contain best qpe field.
********************************************************************************
*/
void get_empe_qpe_fieldtype ( const int * verbose , char * bestfield , 
                             int * bestfield_len , int * exit_status )
{
   static char * empe_qpe_fieldtype_token = EMPE_QPE_FIELDTYPE_TOKEN ;
   static char empe_qpe_fieldtype_reply [ EMPE_PRODUCT_REPLY_LEN ] = { '\0' } ;
   static int first_call = 1 ;
   int i ;
   int reply_len ;
   int request_len ;
   int status ;
   
   * exit_status = 0 ;

   if ( first_call == 1 )
   {
      first_call = 0 ;

      /* Get the value of the empe_generate_list token. */
      request_len = strlen ( empe_qpe_fieldtype_token ) ;
      status = get_apps_defaults ( empe_qpe_fieldtype_token ,
                                   & request_len ,
                                   empe_qpe_fieldtype_reply ,
                                   & reply_len ) ; 

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         if ( * verbose == 1 )
         {
            fprintf ( stderr , "\nIn routine 'get_hpe_qpe_fieldtype':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the HPE qpe field type to ERMOSAIC.\n" ,
                               empe_qpe_fieldtype_token ) ;
         }
         
         memset ( empe_qpe_fieldtype_reply , '\0' , EMPE_PRODUCT_REPLY_LEN ) ;
         strcpy ( empe_qpe_fieldtype_reply , "ERMOSAIC" ) ;
         best_prod = ERMOSAIC ; 
      }
      else
      {
         /* Test to make sure the empe_qpe_fieldtype is valid. */
         for ( i = 0 ; i < NUM_EMPE_BEST_PRODUCTS ; ++ i )
         {
            status = strcmp ( empe_qpe_fieldtype_reply ,  
                              empe_qpe_fields [ i ] ) ;

            if ( status == 0 )
            {
               /* Remember the index of the qpe_fieldtype. */
               best_prod = ( enum EmpeBestProdList ) i ;
               break ;
            }
         }

         if ( status != 0 )
         {
            /* The user has supplied an unrecognized field type. */
            if ( * verbose == 1 )
            {
               fprintf ( stderr , "\nIn routine 'get_hpe_product_state':\n"
                                  "The value of token %s, '%s', is invalid.\n"
                                  "The best estimate qpe type is being set to\n"
                                  "ERMOSAIC.\n" , empe_qpe_fieldtype_token ,
                                   empe_qpe_fieldtype_reply ) ;
            }

            memset ( empe_qpe_fieldtype_reply , '\0' , EMPE_PRODUCT_REPLY_LEN ) ;
            strcpy ( empe_qpe_fieldtype_reply , "ERMOSAIC" ) ;
            best_prod = ERMOSAIC ; 
         }
      }
   }

   /* Check to make sure the user-supplied bestfield array is large 
      enough to contain the best qpe field name. */ 
   request_len = strlen ( empe_qpe_fieldtype_reply ) ;
   
   if ( ( request_len + 1 ) > ( * bestfield_len ) )
   {
      /* The bestfield array is not large enough. */
      if ( * verbose == 1 )
      {
         fprintf ( stderr , "\nIn routine 'get_qpe_fieldtype':\n"
                            "The user-supplied bestfield array has capacity\n"
                            "%d. This is too small to contain the best qpe\n"
                            "field name, %s, plus a terminating NULL, length\n"
                            "%d.\n", * bestfield_len , empe_qpe_fieldtype_reply ,
                            ( request_len + 1 ) ) ;
      }

      * bestfield_len = 0 ;
      * exit_status = -1 ;
   }
   else
   {
      /* The bestfield array is of an acceptable size.  Copy the
         empe qpe field type into the best array.  Return the length
         of the mpq qpe field type. */
      memset ( bestfield , '\0' , * bestfield_len ) ;
      strcpy ( bestfield , empe_qpe_fieldtype_reply ) ;
      * bestfield_len = strlen ( bestfield ) ; 
   }

   return ;
}

/*******************************************************************************
* MODULE NUMBER: 4
* MODULE NAME:   get_empe_fields_array
* PURPOSE:       This routine returns 
*
* ARGUMENTS:
*   TYPE   DATA TYPE   NAME                 DESCRIPTION/UNITS
*
* RETURNS:
*   DATA TYPE   NAME                        DESCRIPTION
*
* APIs UTILIZED:
*   NAME                                    HEADER FILE DESCRIPTION
*
* LOCAL DATA ELEMENTS (OPTIONAL):
*   DATA TYPE  NAME                         DESCRIPTION
*
* DATA FILES AND/OR DATABASE:
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*
********************************************************************************
*/
const char ** get_empe_qpe_fields ( )
{
   return empe_qpe_fields ;
}

/*******************************************************************************
* MODULE NUMBER: 4
* MODULE NAME:   get_empe_base_radar
* PURPOSE:       Returns the value of the empe_base_radar_mosaic token.
*                The first call to this routine calls get_apps_defaults
*                and stores the value of this token in a static variable.
*                Subsequent calls to this routine do not call
*                get_apps_defaults.  They simply return the value of the
*                static variable.
*
*                If there is no value in the empe_base_radar_mosaic token,
*                then base radar mosaic defaults to ERMOSAIC.
*
* ARGUMENTS:
*   TYPE   DATA TYPE NAME             DESCRIPTION/UNITS
*   In     int *     verbose          Verbose output flag. 0 = no output to
*                                     stdout or stderr.  1 = output to stdout
*                                     stderr.
*   In/Out char *    base_radar_field The user supplied array into which this
*                                     routine writes the empe_base_radar_mosaic
*                                     token contents.
*   In/Out int *     basefield_len    The user passes in the capacity of the
*                                     bestfield array using this parameter.
*                                     The length of the empe qpe fieldname
*                                     is returned in this parameter.
*   Out    int *     exit_status      Contains success or error code.
*
* RETURNS:
*   None
*   
* APIs UTILIZED:
*   NAME               HEADER FILE      DESCRIPTION
*   get_apps_defaults  GeneralUtil.h    Returns the value of an application
*                                       control token.
* LOCAL DATA ELEMENTS:
*   DATA TYPE  NAME                     DESCRIPTION
*  char [ ]    empe_qpe_fieldtype_reply  Contains the value of the 
*                                       empe_qpe_fieldtype token.
*  char *      empe_qpe_fieldtype_token  Contains the name of the
*                                       empe_qpe_fieldtype token.
*  int         first_call               Indicates if this is the first time
*                                       this routine has been called.
*  int         i                        Loop indexing variable.
*  int         reply_len                The length of the token
*                                       value returned by call to
*                                       get_apps_defaults.
*  int         request_len              The length of the token name
*                                       supplied to get_apps_defaults.
*  int         status                   Contains the return status of
*                                       get_apps_defaults. 
*
* DATA FILES AND/OR DATABASE:
* None
*
* ERROR HANDLING:
*    ERROR CODE                             DESCRIPTION
*    0					    Routine ran successfully
*    -1                                     Routine failed because
*                                           bestfield array is too small
*                                           to contain best qpe field.
********************************************************************************
*/
void get_empe_base_radar ( const int * verbose , char * base_radar_field , 
                          int * baseradar_len , int * exit_status )
{
   static char * empe_base_radar_mosaic_token = EMPE_BASE_RADAR_MOSAIC_TOKEN ;
   static char empe_base_radar_mosaic_reply [ EMPE_PRODUCT_REPLY_LEN ] = {'\0'} ;
   static int first_call = 1 ;
   int i ;
   int reply_len ;
   int request_len ;
   int status ;
   
   * exit_status = 0 ;

   if ( first_call == 1 )
   {
      first_call = 0 ;

      /* Get the value of the empe_generate_list token. */
      request_len = strlen ( empe_base_radar_mosaic_token ) ;
      status = get_apps_defaults ( empe_base_radar_mosaic_token ,
                                   & request_len ,
                                   empe_base_radar_mosaic_reply ,
                                   & reply_len ) ; 

      if ( ( status != 0 ) || ( reply_len == 0 ) )
      {
         if ( * verbose == 1 )
         {
            fprintf ( stderr , "\nIn routine 'get_hpe_base_radar':\n"
                               "No value retrieved for token %s.\n"
                               "Setting the EMPE base radar mosaic to "
                               "ERMOSAIC.\n", empe_base_radar_mosaic_token ) ;
         }
         
         memset ( empe_base_radar_mosaic_reply , '\0' , EMPE_PRODUCT_REPLY_LEN ) ;
         strcpy ( empe_base_radar_mosaic_reply , "ERMOSAIC" ) ;
         base_prod = ERMOSAIC;
      }
      else
      {
         /* Test to make sure the empe_base_radar_mosaic_reply is valid. */
         for ( i = 0 ; i < NUM_EMPE_BASE_RADAR_MOSAICS ; ++ i )
         {
            status = strcmp ( empe_base_radar_mosaic_reply ,  
                              empe_base_radar_mosaics [ i ] ) ;

            if ( status == 0 )
            {
               break ;
            }
         }

         if ( status != 0 )
         {
            /* The user has supplied an unrecognized base radar mosaic. */
            if ( * verbose == 1 )
            {
               fprintf ( stderr , "\nIn routine 'get_hpe_base_radar':\n"
                                  "The value of token %s, '%s', is invalid.\n"
                                  "The base radar mosaic is being set to\n"
                                  "ERMOSAIC.\n" , empe_base_radar_mosaic_token ,
                                   empe_base_radar_mosaic_reply ) ;
            }

            memset ( empe_base_radar_mosaic_reply , '\0' , 
                     EMPE_PRODUCT_REPLY_LEN ) ;
            strcpy ( empe_base_radar_mosaic_reply , "ERMOSAIC" ) ;
            base_prod = ERMOSAIC ; 
         }
         else
         {
            /* Find the index of this product in the main list of EMPE
               qpe products. */
            for ( i = 0 ; i < NUM_EMPE_BEST_PRODUCTS ; ++ i )
            {
               status = strcmp ( empe_base_radar_mosaic_reply ,  
                                 empe_qpe_fields [ i ] ) ;
   
               if ( status == 0 )
               {
                  /* Remember the index of the qpe_fieldtype. */
                  base_prod = ( enum EmpeBestProdList ) i ;
                  break ;
               }
            }
         }
      }
   }

   /* Check to make sure the user-supplied base_radar_field array is large 
      enough to contain the base radar product name. */ 
   request_len = strlen ( empe_base_radar_mosaic_reply ) ;
   
   if ( ( request_len + 1 ) > ( * baseradar_len ) )
   {
      /* The base_radar_field array is not large enough. */
      if ( * verbose == 1 )
      {
         fprintf ( stderr , "\nIn routine 'get_hpe_base_radar':\n"
                            "The user-supplied base_radar_field array has "
                            "capacity %d. This is too small to contain the\n"
                            "base field name, %s, plus a terminating "
                            "NULL, length %d.\n", * baseradar_len , 
                            empe_base_radar_mosaic_reply ,
                            ( request_len + 1 ) ) ;
      }

      * baseradar_len = 0 ;
      * exit_status = -1 ;
   }
   else
   {
      /* The baseradar_field array is of an acceptable size.  Copy the
         empe qpe field type into the best array.  Return the length
         of the mpq qpe field type. */
      memset ( base_radar_field , '\0' , * baseradar_len ) ;
      strcpy ( base_radar_field , empe_base_radar_mosaic_reply ) ;
      * baseradar_len = strlen ( base_radar_field ) ; 
   }

   return ;
}
