/*=========================================================================*/
/*                         FILE NAME:  draw_precip_poly_RFCW.c             */
/*                                                                         */
/*  FUNCTIONS CONTAINED IN THIS FILE:   setup_draw_precip_RFCW             */
/*                                      exit_draw_precip_RFCW              */
/*                                      raise_draw_precip_value_RFCW       */
/*                                      show_display_edit_precip_polyDS    */
/*                                      setSubPrecipValueRFCW              */
/*                                      read_draw_precip_value_RFCW        */
/*                                      write_draw_precip_data_RFCW        */
/*                                                                         */
/*  MODIFICATION HISTORY:                                                  */
/*  November 2, 2004  Bryon Lawrence    Added the code necessary to        */
/*                                      allow data from the local bias     */
/*                                      multisensor mosaic and the local   */
/*                                      bias satellite precipitation       */
/*                                      estimate to be substituted into a  */
/*                                      polygon.                           */
/*  November 10, 2004 Bryon Lawrence    Added the code necessary to        */
/*                                      desensitize buttons on the         */
/*                                      edit precip polygon GUI based on   */
/*                                      the products being generated by    */
/*                                      MPE FieldGen.                      */
/*  October 14, 2005  Bryon Lawrence    Fixed problem with graying out     */
/*                                      of buttons on edit precip polygon  */
/*                                      GUI.                               */
/*=========================================================================*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <Xm/AtomMgr.h>
#include <Xm/Protocols.h>
#include <Xm/Scale.h>
#include <Xm/ToggleBG.h>
#include <Xm/Xm.h>
#include <X11/cursorfont.h>

#include "polygon_RFCW.h"
#include "delete_polygons_show.h"
#include "display_edit_precip_poly.h"
#include "display_field_data_RFCW.h"
#include "display_precip_data.h"
#include "drawa.h"
#include "draw_precip_poly_RFCW.h"
#include "get_mpe_product_state.h"
#include "List.h"
#include "map_library.h"
#include "mpe_log_utils.h"

#include "post_functions.h"
#include "rfcwide.h"
#include "rfcwide_interface.h"
#include "stage3.h"
#include "stage3_globals.h"
#include "TSutils.h"

static enum DisplayFieldData subPrecip = display_rMosaic;
static Widget shell = NULL;

extern int draw_poly_flag;
extern int addition_flag;

/* Array into which to read fields that will be used to 
 substitute values into polygons. */
static int ** temp_array = NULL;
static int rows = 0;
static int cols = 0;

rubber_poly_data polydata;

/***************************************************************************/
/*  FUNCTION NAME:   show_display_edit_precip_polyDS                       */
/*       FUNCTION:   popup slider bar for defining precip value for each   */
/*                   polygon drawn on main window                          */
/***************************************************************************

 Function type:
 void
 Called by function:
 start_end_rubber_poly_RFCW

 ******************** BEGIN show_display_edit_precip_polyDS *****************/

void show_display_edit_precip_polyDS(Widget w)
{
    const char * pProduct = NULL;
    const char ** pQpeFields = NULL;
    int bottomOffset;
    int i;
    int length;
    int mpe_product_state;
    int subFactor;
    Dimension shellHeight;
    Dimension toggleButtonHeight;
    int status;
    int topOffset;
    int unmanagedWidgetCount = 0;
    const int verbose = 1;
    
    Widget * editPrecipToggleButtons [NUM_BEST_PRODUCTS ] = { &rMosaicTB,
            &avgRMosaicTB, &maxRMosaicTB, &bMosaicTB, &lMosaicTB, &gageOnlyTB,
            &mMosaicTB, &locMMosaicTB, &satPrecipTB, &locSatPrecipTB,
            &srMosaicTB, &sgMosaicTB, &srgMosaicTB, &p3LMosaicTB, &rfcMosaicTB,
            &rfcBMosaicTB, &rfcMMosaicTB };

    static enum DisplayFieldData fieldNames [NUM_BEST_PRODUCTS ] = {
            display_rMosaic, display_avgrMosaic, display_maxrMosaic,
            display_bMosaic, display_lMosaic, display_gageOnly,
            display_mMosaic, display_mlMosaic, display_satPrecip,
                    display_lsatPrecip, display_srMosaic, display_sgMosaic,
                    display_srgMosaic, display_p3Mosaic, display_rfcMosaic,
                    display_rfcbMosaic, display_rfcmMosaic };

    if ( (display_edit_precip_polyDS == NULL )
            || !XtIsManaged(display_edit_precip_polyDS) )
    {

        /* Create the display for editing precip polygon GUI. */
        create_display_edit_precip_polyDS(GetTopShell(w) ) ;

        /* Add the callbacks to the display editing precip polygon GUI widgets. */
        display_edit_precip_poly_callbacks() ;
        polydata.shell = adjust_precip_valSC;

        /* Determine which products are being generated by MPE Fieldgen.
         Unmanage buttons corresponding to products which are not being
         produced. */

        /* Note that the Best Estimate QPE is always ON. */
        pQpeFields = get_qpe_fields_array() ;

        XtVaGetValues(display_edit_precip_polyDS, XmNheight, &shellHeight, NULL);

        for (i = ( int ) RMOSAIC; i < ( int ) NUM_BEST_PRODUCTS; ++i)
        {
            pProduct = pQpeFields [ i ];
            length = strlen(pProduct) ;
            get_mpe_product_state(pProduct, &length, &verbose,
                    &mpe_product_state, &status) ;

            if (mpe_product_state == 0)
            {
                XtUnmanageChild( *editPrecipToggleButtons [ i ]);
                ++unmanagedWidgetCount;
            }

        }

        if (unmanagedWidgetCount > 0)
        {
            XtVaGetValues(rMosaicTB, XmNheight, &toggleButtonHeight, NULL);
            subFactor = unmanagedWidgetCount * toggleButtonHeight;

            XtVaGetValues(display_edit_precip_polyDS, XmNheight, &shellHeight,
                    NULL);
            shellHeight -= subFactor;
            XtVaSetValues(display_edit_precip_polyDS, XmNmaxHeight,
                    shellHeight, XmNminHeight, shellHeight, XmNheight,
                    shellHeight, XmNbaseHeight, shellHeight,
                    XmNallowShellResize, FALSE, NULL);
            XtVaSetValues(display_edit_precip_polyFO, XmNmaxHeight,
                    shellHeight, XmNminHeight, shellHeight, XmNheight,
                    shellHeight, XmNbaseHeight, shellHeight, XmNresizePolicy,
                    XmRESIZE_NONE, XmNnoResize, TRUE, XmNautoUnmanage, FALSE,
                    NULL);

            XtVaGetValues(edit_precip_polySubPB, XmNbottomOffset,
                    &bottomOffset, XmNtopOffset, &topOffset, NULL);
            XtUnmanageChild(edit_precip_polySubPB);
            bottomOffset += subFactor;
            topOffset -= subFactor;
            XtVaSetValues(edit_precip_polySubPB, XmNbottomOffset, bottomOffset,
                    XmNbottomAttachment, XmATTACH_OPPOSITE_FORM, XmNtopOffset,
                    topOffset, XmNtopAttachment, XmATTACH_FORM, NULL);
            XtManageChild(edit_precip_polySubPB);

            XtVaGetValues(edit_precip_polySP, XmNbottomOffset, &bottomOffset,
                    XmNtopOffset, &topOffset, NULL);
            XtUnmanageChild(edit_precip_polySP);
            bottomOffset += subFactor;
            topOffset -= subFactor;
            XtVaSetValues(edit_precip_polySP, XmNbottomOffset, bottomOffset,
                    XmNbottomAttachment, XmATTACH_OPPOSITE_FORM, XmNtopOffset,
                    topOffset, XmNtopAttachment, XmATTACH_FORM, NULL);
            XtManageChild(edit_precip_polySP);

            XtVaGetValues(edit_precip_polyClosePB, XmNbottomOffset,
                    &bottomOffset, XmNtopOffset, &topOffset, NULL);
            XtUnmanageChild(edit_precip_polyClosePB);
            bottomOffset += subFactor;
            topOffset -= subFactor;
            XtVaSetValues(edit_precip_polyClosePB, XmNbottomOffset,
                    bottomOffset, XmNbottomAttachment, XmATTACH_OPPOSITE_FORM,
                    XmNtopOffset, topOffset, XmNtopAttachment, XmATTACH_FORM,
                    NULL);
            XtManageChild(edit_precip_polyClosePB);
        }
        

        for (i = ( int ) RMOSAIC; i < ( int ) NUM_BEST_PRODUCTS; ++i)
        {
            /* Toggle a button by default.  This is set up so the first button
             on the Edit Precipitation GUI which is sensitive is chosen. */
            if (XtIsManaged( *editPrecipToggleButtons [ i ])
                    && XtIsSensitive( *editPrecipToggleButtons [ i ]) )
            {
                XmToggleButtonSetState( *editPrecipToggleButtons[i], True, True);
                break;
            }
        }

        /* Set the persistent flag based on the state of the persistent
         toggle button. */
        polydata.persistent = XmToggleButtonGetState(persistentTB);
    }
    else
    {
        for (i = ( int ) RMOSAIC; i < ( int ) NUM_BEST_PRODUCTS; ++i)
        {
            if (XtIsManaged( *editPrecipToggleButtons[i])
                    && XmToggleButtonGetState( *editPrecipToggleButtons[i]))
            {
                subPrecip = fieldNames [ i ];
                break;
            }
        }

        if (i == NUM_BEST_PRODUCTS)
        {
            if (XtIsManaged(xmrgTB) && XmToggleButtonGetState(xmrgTB) )
            {
                subPrecip = display_Xmrg;
            }
            else if (XtIsManaged(xmrgTB) && XmToggleButtonGetState(rfcMosaicTB) )
            {
                subPrecip = display_rfcMosaic;
            }
        }

    }

    /* Manage the form and the dialog shell which make up the
     display editing precip polygon GUI. */
    XtManageChild(display_edit_precip_polyFO) ;
    XtManageChild(display_edit_precip_polyDS) ;

    XtPopup(display_edit_precip_polyDS, XtGrabNone) ;
    shell = display_edit_precip_polyDS;

    /* Force the slider value to be 0.00. */
    XtVaSetValues(adjust_precip_valSC, XmNvalue, 0, NULL);

    return;
}

/******************** END show_display_edit_precip_polyDS *****************/

/***************************************************************************/
/*  FUNCTION NAME:   set_persistent_flag_RFCW                              */
/*       FUNCTION:                                                         */
/*                                                                         */
/***************************************************************************
 Function type:
 void

 Called by function:
 callback from persistent toggle button.

 ************************BEGIN set_persistent_flag_RFCW *****************/
static void set_persistent_flag_RFCW(Widget w, XtPointer clientdata,
        XtPointer calldata)
{
    rubber_poly_data * pPolygonNode = NULL;
    XmToggleButtonCallbackStruct * pCalldata = NULL;

    pPolygonNode = ( rubber_poly_data * ) clientdata ;
    pCalldata = ( XmToggleButtonCallbackStruct * ) calldata;

    if (pPolygonNode != NULL)
    {
        pPolygonNode->persistent = ( Boolean ) pCalldata->set;
    }

    return;
}

/************************ END set_persistent_flag_RFCW *****************/

static void close_display_edit_precip(Widget w, XtPointer clientdata,
        XtPointer calldata)
{
    draw_precip_value_popup_RFCW_Up = 0; /* Set Precip Value GUI False */
    XtPopdown(display_edit_precip_polyDS) ;
    return;
}

void display_edit_precip_poly_callbacks()
{
    Atom atom;

    /* Window manager callback. */
    atom = XmInternAtom(XtDisplay(display_edit_precip_polyDS),
            "WM_DELETE_WINDOW", False);
    XmAddWMProtocolCallback(display_edit_precip_polyDS, atom,
            close_display_edit_precip, NULL);
    XmAddWMProtocolCallback(display_edit_precip_polyDS, atom,
            exit_draw_precip_RFCW, NULL);

    /* Callbacks for the radio buttons. */
    XtAddCallback(rMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_rMosaic ) ;
    XtAddCallback(avgRMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            (XtPointer) display_avgrMosaic );
    XtAddCallback(maxRMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            (XtPointer) display_maxrMosaic );
    XtAddCallback(bMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_bMosaic ) ;
    XtAddCallback(lMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_lMosaic ) ;
    XtAddCallback(gageOnlyTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_gageOnly ) ;
    XtAddCallback(mMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_mMosaic ) ;
    XtAddCallback(locMMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_mlMosaic ) ;
    XtAddCallback(satPrecipTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_satPrecip ) ;
    XtAddCallback(locSatPrecipTB, XmNvalueChangedCallback,
            setSubPrecipValueRFCW, ( XtPointer ) display_lsatPrecip ) ;
    XtAddCallback(srMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_srMosaic ) ;
    XtAddCallback(sgMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_sgMosaic ) ;
    XtAddCallback(srgMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_srgMosaic ) ;
    XtAddCallback(p3LMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_p3Mosaic );
    XtAddCallback(xmrgTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_Xmrg ) ;
    XtAddCallback(rfcBMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_rfcbMosaic ) ;
    XtAddCallback(rfcMMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_rfcmMosaic ) ;
    XtAddCallback(rfcMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_rfcMosaic ) ;
    XtAddCallback(locMMosaicTB, XmNvalueChangedCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_mlMosaic ) ;

    /* Close button callbacks. */
    XtAddCallback(edit_precip_polyClosePB, XmNactivateCallback,
            close_display_edit_precip, &polydata) ;
    XtAddCallback(edit_precip_polyClosePB, XmNactivateCallback,
            exit_draw_precip_RFCW, &polydata);

    /* Snow button callbacks. */
    XtAddCallback(adjust_snowPB, XmNactivateCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_subValue ) ;
    XtAddCallback(adjust_snowPB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata) ;

    /* Set button callbacks. */
    XtAddCallback(adjust_setPB, XmNactivateCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_subValue ) ;
    XtAddCallback(adjust_setPB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata) ;

    /* Raise button callbacks. */
    XtAddCallback(adjust_raisePB, XmNactivateCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_subValue ) ;
    XtAddCallback(adjust_raisePB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata) ;

    /* Lower button callbacks. */
    XtAddCallback(adjust_lowerPB, XmNactivateCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_subValue ) ;
    XtAddCallback(adjust_lowerPB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata) ;

    /* Scale button callbacks. */
    XtAddCallback(adjust_scalePB, XmNactivateCallback, setSubPrecipValueRFCW,
            ( XtPointer ) display_subValue ) ;
    XtAddCallback(adjust_scalePB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata) ;

    /* Set Focus to the Set button by default. */
    XtSetKeyboardFocus(display_edit_precip_polyFO, adjust_setPB);

    /* Substitute button callback. */
    XtAddCallback(edit_precip_polySubPB, XmNactivateCallback,
            process_draw_precip_value_RFCW, &polydata);

    /* Callback for the make persistent toggle button. */
    XtAddCallback(persistentTB, XmNvalueChangedCallback,
            set_persistent_flag_RFCW, &polydata);

}

/***************************************************************************/
/*  FUNCTION NAME:   read_draw_precip_value_RFCW                           */
/*       FUNCTION:   read precip value to be assigned to bins within       */
/*                   the draw precip polygon from the slider bar           */
/***************************************************************************

 Function type:
 void

 Called by function:
 (callback) Set, Raise, Lower or Scale button

 ************************************ BEGIN read_draw_precip_value_RFCW*****/

void read_draw_precip_value_RFCW(Widget w, XtPointer clientdata,
        XtPointer calldata)
{
    int value;
    rubber_poly_data * pPolygonNode = ( rubber_poly_data * ) clientdata ;

    if (pPolygonNode == NULL)
    {
        flogMessage(stderr, "In routine 'read_draw_precip_value_RFCW':\n"
            "No polydata structure passed into this routine.\n");
    }
    else
    {
        XmScaleGetValue(adjust_precip_valSC, &value) ;
        pPolygonNode->draw_precip_value = ( float ) value / 100;
    }
}
/******************************************** END read_draw_precip_value*****/

/***************************************************************************/
/*  FUNCTION NAME:   setSubPrecipValueRFCW                                 */
/*       FUNCTION:   set precip type to be substituted to bins within      */
/*                   the draw precip polygon from the radio box            */
/***************************************************************************

 Function type:
 void

 Called by function:
 (callback) show_display_edit_precip_polyDS

 *************************BEGIN setSubPrecipValueRFCW**********************/

void setSubPrecipValueRFCW(Widget w, XtPointer client_data, XtPointer call_data)
{
    enum DisplayFieldData display_field = ( enum DisplayFieldData ) client_data ;

    if (display_field == display_subValue)
    {
        polydata.draw_source = display_field;
    }
    else
    {
        subPrecip = ( enum DisplayFieldData ) client_data ;
    }
}

/************************END read_draw_precip_value************************/

/***************************************************************************/
/*  FUNCTION NAME:   InOutPoly()                                           */
/*       FUNCTION:   returns a 1 or 0 to define if an HRAP bin is located  */
/*                    inside or outside a polygon for draw precip function */
/***************************************************************************

 Function type:
 int

 Called by function:
 write_draw_precip_data

 Functions called:
 none

 *************************************** BEGIN InOutPoly *******************/

int InOutPoly(int x, int y, const rubber_poly_data * data)
{
    int in, nc, i, ii;
    float m, b;

    in = 0;
    nc = 0;
    
    for (i=0; i < data->npoints; i++)
    {
        ii = i-1;
        
        if (ii < 0)
        {
            ii = data->npoints - 1;
        }
        
        /* The 'if' tests to determine if the x coord of the HRAP point in consideration
         * is between the x coords of the previous and current points of the polygon.*/
        if (( (float)x >= data->hrap[i].x && (float)x < data->hrap[ii].x) || 
            ( (float)x < data->hrap[i].x && (float)x >= data->hrap[ii].x))
        {
            /* Use the line equation to determine if the HRAP grid
             * cell is inside or outside the polygon.
             */
            m = (data->hrap[i].y - data->hrap[ii].y) /
                    (data->hrap[i].x - data->hrap[ii].x);
            b = data->hrap[i].y - ( m * data->hrap[i].x);
            
            if ((float)y <= (b + m*x))
            {
                nc++;
            }
        }
        
    }
    
    if (nc > 2*(nc/2))
    {
        in = 1;
    }
    
    return in;
}

/*************************************** END InOutPoly *******************/

Boolean InOutPolyNew(int x, int y, Region region)
{
    Boolean isInRegion;
    int i;
    int j;
    int xCoord;
    int yCoord;
       
    /* All four corners of the HRAP box must be in the
     * area.
     */ 
    for ( i = 0; i < 2; ++ i)
    {
        for ( j = 0; j < 2; ++j )
        {
            xCoord = ( x + i ) * REGION_SCALE_FACTOR ;
            yCoord = ( y + j ) * REGION_SCALE_FACTOR ;
            
            isInRegion = XPointInRegion ( region, xCoord, yCoord );
            
            if ( isInRegion == False)
            {
                return False;
            }
        }
        
    }
    
    return True;
}

/***************************************************************************/
/*  FUNCTION NAME:   setup_draw_precip_RFCW                                */
/*       FUNCTION:   setup arrays, set flags and setup event               */
/*                   handlers for drawing precip on main window            */
/***************************************************************************

 Function type:
 void

 Called by function:
 callback from Draw Polygons button

 Functions called:

 ********************************* BEGIN setup_draw_precip_RFCW *****************/

void setup_draw_precip_RFCW(Widget w, XtPointer clientdata, XtPointer calldata)
{
    extern int display_7x7_flag;
    extern int add_pseudo_flag;

    if (draw_poly_flag != 1)
    {

        /*-----------------------------------------------------------*/
        /*  define draw_poly_flag                                   */
        /*  = 0 -- mouse click on Hydromap (Zoom option)             */
        /*  = 1 -- Draw Polygons menu item  chosen from Control menu */
        /*-----------------------------------------------------------*/

        display_7x7_flag = 0;
        add_pseudo_flag = 0;
        draw_poly_flag = 1;

        /*-------------------------------------------------*/
        /*   if draw precip variables not initialized,     */
        /*   then initialize draw precip variables         */
        /*-------------------------------------------------*/

        num_draw_precip_poly = 0;

        polydata.npoints = 0;

        /*----------------------------------------*/
        /*    setup DrawPrecip buttons            */
        /*----------------------------------------*/

        polydata.gc = xs_create_xor_gc(rad_data[0].w);

        /* Set the polygon to be visible. */
        polydata.visible = True;
    }
}

/********************************* END setup_draw_precip_RFCW *****************/

/***************************************************************************/
/*  FUNCTION NAME:   snow_draw_precip_value_RFCW                            */
/*       FUNCTION:                                                         */
/*                                                                         */
/***************************************************************************
 Function type:
 void

 Called by function:
 callback from Set button

 ************************BEGIN snow_draw_precip_value_RFCW *****************/

void process_draw_precip_value_RFCW(Widget w, XtPointer clientdata,
        XtPointer calldata)
{
    rubber_poly_data * pPolygonNode = NULL;

    pPolygonNode = ( rubber_poly_data * ) clientdata ;

    if (pPolygonNode == NULL)
    {
        flogMessage(stderr, "\nIn routine 'process_draw_precip_value_RFCW':\n"
            "No polygon data can be found.\n") ;
        return;
    }

    /* Make certain that the polygon is closed. */
    closePolygon(pPolygonNode);

    /* Based on the source of this event,
     * set the polygon action. */
    if (w == adjust_snowPB)
    {
        pPolygonNode->snow_flag = True;
    }
    else if (w == adjust_setPB)
    {
        pPolygonNode->set_flag = True;
    }
    else if (w == adjust_raisePB)
    {
        pPolygonNode->raise_flag = True;
    }
    else if (w == adjust_lowerPB)
    {
        pPolygonNode->lower_flag = True;
    }
    else if (w == adjust_scalePB)
    {
        pPolygonNode->scale_flag = True;
    }
    else if (w == edit_precip_polySubPB)
    {
        pPolygonNode->draw_source = subPrecip;
    }
    else
    {
        flogMessage(stderr, "In routine 'process_draw_precip_value_RFCW':\n"
            "Couldn't identify polygon action.\n");
    }

    /* Read the value on the slider bar. */
    read_draw_precip_value_RFCW(w, clientdata, calldata);

    /* Apply the polygon and save it to the Polygon file. */
    write_draw_precip_data_RFCW(w, clientdata, calldata);
}

/************************ END snow_draw_precip_value_RFCW *****************/

void get_poly_action(const rubber_poly_data * pPolyNode, char * action,
        char * value)
{
    const char ** field_names = NULL;
    
    sprintf ( value, "%6.2f", pPolyNode->draw_precip_value );

    /* Initialize the polygon action. */
    if (pPolyNode->raise_flag == True)
    {
        strcpy(action, "Raise");
    }
    else if (pPolyNode->lower_flag == True)
    {
        strcpy(action, "Lower");
    }
    else if (pPolyNode->scale_flag == True)
    {
        strcpy(action, "Scale");
    }
    else if (pPolyNode->snow_flag == True)
    {
        strcpy(action, "Snow");
    }
    else if (pPolyNode->set_flag == True)
    {
        strcpy(action, "Set");
    }
    else
    {
        field_names = get_mpe_field_names();
        strcpy(action, "Sub");
        strcpy(value, field_names [ pPolyNode->draw_source ]);
    }
}

/***************************************************************************/
/*  FUNCTION NAME:   exit_draw_precip_RFCW                                 */
/*       FUNCTION:   change EventHandlers back to normal and exit          */
/*                   draw precip mode                                      */
/***************************************************************************

 Function type:
 void

 Called by function:
 callback from Close button of Edit Precipitation form 


 ********************************* BEGIN exit_draw_precip_RFCW *****************/

void exit_draw_precip_RFCW(Widget w, XtPointer clientdata, XtPointer calldata)
{
    rubber_poly_data * data = (rubber_poly_data *) clientdata ;

    XtRemoveEventHandler(rad_data[0].w, ButtonPressMask, FALSE,
            select_poly_for_edit, &data) ;

    draw_poly_flag = 0;

    /* Force the display to update. Right now polygon drawing is limited
     to Map 0.  So, only update map 0. */
    mUpdateMap( 0);
}

/********************************* END exit_draw_precip_RFCW *****************/

static void apply_edit_polygon(const rubber_poly_data * pPolyNode,
        int ** data_array, const date_struct * pDate, double scale,
        double factor, int num_rows, int num_columns, int xorigin,
        int yorigin, int add_flag)
{
    float precip_val;
    float scale_val;
    int i;

    if (pPolyNode->draw_source != display_subValue)
    {
        if (temp_array == NULL)
        {
            rows = num_rows;
            cols = num_columns;

            /* Allocate memory for the temporary array.
             Data from the substitute field will be read into this array. */
            temp_array = ( int ** ) malloc( (num_columns ) * sizeof(int * ));

            if (temp_array == NULL)
            {
                flogMessage(stderr, "\nIn routine 'apply_edit_polygon':\n"
                    "Could not allocate memory for the "
                    "temporary_array.\n");
                return;
            }

            for (i = 0; i < num_columns; ++i)
            {
                temp_array [ i ] = ( int * ) malloc(num_rows * sizeof(int));

                if (temp_array [ i ] == NULL)
                {
                    flogMessage(stderr, "\nIn routine 'apply_edit_polygon':\n"
                        "Could not allocate memory for the "
                        "temporary_array.\n");
                    return;
                }
            }
        }

        display_field_data_RFCW(
                ( enum DisplayFieldData ) pPolyNode->draw_source, temp_array,
                (date_struct ) * pDate, ( int ) add_flag , num_rows, num_columns );
    }

    /*-----------------------------------------------------------*/
    /*     determine HRAP coordinates bounded by polygon         */
    /*     update field  array                                   */
    /*-----------------------------------------------------------*/
    precip_val = pPolyNode->draw_precip_value * factor * scale;
    scale_val = pPolyNode->draw_precip_value;
    
    /* Create the region for testing the Polygon */
    for ( i = 0; i < pPolyNode->npoints; ++i )
    {
        int x_adj = pPolyNode->hrap[i].x - xorigin;
        int y_adj = pPolyNode->hrap[i].y - yorigin;

        switch (pPolyNode->draw_source)
        {
            case display_rMosaic:
            case display_avgrMosaic:
            case display_maxrMosaic:
            case display_bMosaic:
            case display_lMosaic:
            case display_mMosaic:
            case display_mlMosaic:
            case display_gageOnly:
            case display_satPrecip:
            case display_lsatPrecip:
            case display_sgMosaic:
            case display_srMosaic:
            case display_srgMosaic:
            case display_p3Mosaic:
            case display_rfcMosaic:
            case display_rfcbMosaic:
            case display_rfcmMosaic:
            case display_Xmrg:
            case display_lqMosaic:
            case display_qMosaic:
            case display_mlqMosaic:

                data_array[x_adj][y_adj] = temp_array[x_adj][y_adj];

                break;

            case display_subValue:

                if (pPolyNode->raise_flag == True)
                {
                    if (data_array[x_adj][y_adj] < precip_val)
                        data_array[x_adj][y_adj] = precip_val;
                }
                else if (pPolyNode->lower_flag == True)
                {
                    if (data_array[x_adj][y_adj] > precip_val)
                        data_array[x_adj][y_adj] = precip_val;
                }
                else if (pPolyNode->scale_flag == True)
                {
                    data_array[x_adj][y_adj] *= scale_val;
                }
                else if (pPolyNode->snow_flag == True)
                {
                    data_array[x_adj][y_adj] = precip_val;
                }
                else if (pPolyNode->set_flag == True)
                {
                    data_array[x_adj][y_adj] = precip_val;
                }

                break;

            default:

                flogMessage(stderr,
                        "In routine 'write_draw_precip_data_RFCW':\n"
                            "Unsupported enum DisplayFieldData type\n"
                            "Value: %d\n", pPolyNode->draw_source) ;
                return;
        }
    }
    
    return;
}

/***************************************************************************/
/*  FUNCTION NAME:   write_draw_precip_data_RFCW                           */
/*       FUNCTION:   write polygon info from draw precip mode into file    */
/***************************************************************************

 Function type:
 void

 Called by function:
 (callback) Set, Raise, Lower, Scale or Substitute button

 Functions called:
 InOutPoly
 fill_pixmap

 ************************************ BEGIN write_draw_precip_data_RFCW ****/

void write_draw_precip_data_RFCW(Widget w, XtPointer clientdata,
        XtPointer calldata)
{
    rubber_poly_data * pPolyCopy = (rubber_poly_data * ) clientdata ;
    rubber_poly_data * pPolyNode = (rubber_poly_data * ) clientdata ;

    static Cursor watch_cursor = (Cursor) NULL;

    if (pPolyNode == NULL)
    {
        flogMessage(stderr, "\nIn routine 'write_draw_precip_data_RFCW':\n"
            "No polygon data was passed in.  Check the\n"
            "clientdata argument.\n") ;
        return;
    }

    /*--------------------------------------------------------------*/
    /*   display watch cursor                                       */
    /*--------------------------------------------------------------*/

    if (watch_cursor == (Cursor) NULL)
    {
        watch_cursor = XCreateFontCursor(XtDisplay(rad_data[0].w), XC_watch);
    }

    XDefineCursor(XtDisplay(rad_data[0].w), XtWindow(rad_data[0].w),
            watch_cursor);
    XFlush(XtDisplay(rad_data[0].w));

    /*-----------------------------------------------------------------*/
    /* Retrieve the most recently created polygon.  This will be the*/
    /* last one in the rubber_poly_data linked list.                */
    /*--------------------------------------------------------------*/

    /* Apply the polygon to the MPE product here. */
    apply_edit_polygon(pPolyNode, rad_data[0].data_array, &date_st3,
            scale_factor, units_factor, rad_data[0].maximum_rows,
            rad_data[0].maximum_columns, 0, 0, addition_flag);

    /* Make a copy of the draw polygon.  This must be done to preserve
     the polygon. */
    pPolyCopy = ( rubber_poly_data * ) malloc(sizeof(rubber_poly_data));

    if (pPolyCopy == NULL)
    {
        flogMessage(stderr, "\nIn routine 'write_draw_precip_data_RFCW':\n"
            "Could not allocate memory for the "
            "copy of the draw polygon.\n");
        return;

    }

    
    memcpy(pPolyCopy, pPolyNode, sizeof(rubber_poly_data));

    pPolyCopy->hrap = ( HRAP * ) malloc(pPolyCopy->npoints * sizeof(HRAP));

    if (pPolyCopy->hrap == NULL)
    {
        flogMessage(stderr, "\nIn routine 'write_draw_precip_data_RFCW':\n"
            "Could not allocate memory for the copy of the "
            "array of polygon points.\n.");
        return;
    }

    memcpy(pPolyCopy->hrap, pPolyNode->hrap, pPolyNode->npoints
            * sizeof(HRAP));

    /*--------------------------------------------*/
    /*  write polygon info to DrawPrecip file     */
    /*  polygon points are stored in HRAP coord   */
    /*  pPolyCopy is deallocated by this call.    */
    /*--------------------------------------------*/
    add_polygon(pPolyCopy);

    /*--------------------------------------------*/
    /*  redraw main window with drawn in precip   */
    /*--------------------------------------------*/
    XUndefineCursor(XtDisplay(rad_data[0].w), XtWindow(rad_data[0].w));
}

/***************************** END write_draw_precip_data_RFCW ****/

/* When an MPE product is loaded, this routine determines if there are
 Polygons which must be loaded onto the field.  If there are, then it
 loads the polygons in order of their polygon number in the polygon
 file. */

void apply_edit_polygons(int ** precip_data_array, const char * cdate,
        int year, int month, int day, int hour, double scale, double factor,
        enum DisplayFieldData field, int num_rows, int num_cols, int xorigin,
        int yorigin, int add_flag, int draw_only_persistent)
{
    date_struct date;
    List PolyList;
    rubber_poly_data * pPolygonHead = NULL;
    rubber_poly_data * pPolygonNode = NULL;

    /* Build the date struct. */
    date.year = year;
    date.month = month;
    date.day = day;
    date.hour = hour;
    memset(date.cdate, '\0', 11);
    strncpy(date.cdate, cdate, 10);

    /* Determine if there is a polygon file for the field. */
    get_polygons(field, &PolyList, date.cdate);

    pPolygonHead = ( rubber_poly_data * ) ListFirst( &PolyList);

    if (pPolygonHead != NULL)
    {
        /* There are polygons to process. */
        pPolygonNode = pPolygonHead;

        while (pPolygonNode != NULL)
        {
            /* Load the field that will be used to substitute data into the
             polygon if another field is to be substituted into this 
             polygon. */

            if (pPolygonNode->visible == True)
            {
                if ( (draw_only_persistent == 0 ) || (pPolygonNode->persistent
                        == True ))
                {

                    apply_edit_polygon(pPolygonNode, precip_data_array, &date,
                            scale, factor, num_rows, num_cols, xorigin,
                            yorigin, add_flag);
                }
            }

            pPolygonNode
                    = ( rubber_poly_data * ) ListNext( &pPolygonNode->node);
        }

        /* Free the linked list of polygon information. */
        free_polygon_list(pPolygonHead);
        pPolygonHead = NULL;
    }

    return;
}

/******************************************************************/
/*  FUNCTION NAME:   popdown_draw_precip_value_RFCW               */
/*       FUNCTION:   popdown draw_precip_value slider bar popup   */
/*******************************************************************

 Function type:
 void

 Called by function:
 (callback) cancel button

 Functions called:
 none

 **************** BEGIN popdown_draw_precip_value_RFCW ******************/

void popdown_draw_precip_value_RFCW(Widget w, XtPointer clientdata,
        XtPointer calldata)
{

    Widget shell = ( Widget ) clientdata ;
    XtPopdown(shell) ;
    draw_precip_value_popup_RFCW_Up = 0; /* Set Precip Value GUI False */

    /* Free the temporary substitute polygon array. */
    free_poly_temp();
}
/*************** END popdown_draw_precip_value_RFCW *******************/

/***************************************************************************/
/*  FUNCTION NAME:   popdown_draw_precip_value_gui                         */
/*       FUNCTION:   "Pops Down" the draw precip value gui.  This is the   */
/*                   routine that the world outside of this file uses to   */
/*                   "pop down" the draw precip value gui.                 */
/***************************************************************************/

void popdown_draw_precip_value_gui()
{
    /* Check to make sure that the GUI actually exists. */
    if (draw_precip_value_popup_RFCW_Up == 1)
    {
        /* Popdown the GUI. */
        popdown_draw_precip_value_RFCW(shell, ( XtPointer ) shell ,
                ( XtPointer ) NULL ) ;
    }
}

/*************** END popdown_draw_precip_value_gui *******************/

void free_polygon_list(rubber_poly_data * pPolyHead)
{
    rubber_poly_data * pPolyNode = NULL;
    rubber_poly_data * pPolyTemp = NULL;

    pPolyNode = pPolyHead;

    while (pPolyNode != NULL)
    {
        pPolyTemp = ( rubber_poly_data * ) ListNext( &pPolyNode->node) ;

        /* Make sure that the array of polygon points are freed as well. */
        if (pPolyNode->hrap != NULL)
        {
            free(pPolyNode->hrap);
            pPolyNode->hrap = NULL;
        }

        free(pPolyNode) ;
        pPolyNode = pPolyTemp;
    }
}

void free_poly_temp()
{
    int i;

    if (temp_array == NULL)
    {
        for (i = 0; i < cols; ++i)
        {
            free(temp_array [ i ]);
            temp_array [ i ] = NULL;
        }

        free(temp_array);
        temp_array = NULL;
    }

    /*  ==============  Statements containing RCS keywords:  */
    {
        static char
                rcs_id1[] =
                        "$Source: /fs/hseb/ob90/ohd/pproc_lib/src/MPEGui/RCS/draw_precip_poly_RFCW.c,v $";
        static char rcs_id2[] =
                "$Id: draw_precip_poly_RFCW.c,v 1.32 2008/03/27 18:00:17 lawrence Exp $";
    }
    /*  ===================================================  */

}
