C MEMBER FCNRCF
C  (from old member FCSPRP26)
C
      SUBROUTINE FCNRCF(VALUE,MAXCHR,CHAR,NUMDEC,NFILL,IST)
C
C  THIS SUBROUTINE CONVERTS REAL VALUES TO THEIR CHARACTER
C  REPRESENTATIONS.
C  THE RANGE OF REAL VALUES THAT CAN BE INPUT IS ABS(VAL) LT 2**31.
C  THE MAXIMUM NUMBER OF DECIMAL PLACES THAT CAN BE REQUESTED IS 9.
C
C  THIS SUBROUTINE ORIGINALLY PROGRAMMED BY
C         GEORGE F. SMITH - HRL - APRIL 1983.
C
C         MODIFIED BY DAVID TRAN - HRL - OCTOBER 1995
C         REPLACE CALL FCONIC WITH UFI2A
C
C-----------------------------------------------------------------------
C
C  ARGUMENT LIST
C
C   VALUE - INPUT  - THE REAL VALUE TO BE CONVERTED.
C  MAXCHR - INPUT  - THE MAXIMUM NUMBER OF CHARACTERS THAT
C                    CHAR CAN HOLD.
C    CHAR - OUTPUT - THE ARRAY CONTAINING THE CHARACTER
C                    REPRESENTATION OF VALUE.
C  NUMDEC - INPUT  - THE NUMBER OF DECIMAL PLACES TO BE FILLED IN CHA
C                      THE MAX VALUE OF NUMDEC IS 9.
C                      IF NUMDEC = 0 THE DECIMAL POINT IS THE
C                      RIGHTMOST CHARACTER IN CHAR.
C                      IF NUMDEC = -1 NO DECIMAL POINT IS
C                      STORED IN CHAR.
C   NFILL - OUTPUT - THE TOTAL NUMBER OF CHARACTERS FILLED
C                    IN CHAR.
C     IST - OUTPUT - STATUS CODE.
C                      =0, ALL OK.
C                      =1, MAXCHR NOT LARGE ENOUGH TO HOLD VALUE.
C                      =2, NUMDEC GT 9 - NUMDEC RESET TO 9
C                          AND CHAR FILLED.
C                      =3, VALUE OUT OF VALID RANGE
C                          I.E., ABS(VALUE) GE 2**31
C
C-----------------------------------------------------------------------
C
      EQUIVALENCE (Z,L1Z(1)),(ZERO,L1ZFIL(1))
      LOGICAL*4 NEGA
      LOGICAL*1 BLNK,DOT,MINUS,L1Z(4),L1ZFIL(4)
      CHARACTER*1 CHAR
      CHARACTER*100 TEMP,TDEC,TWHOLE,TEMPX
      DIMENSION CHAR(MAXCHR)
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcinit_res/RCS/fcnrcf.f,v $
     . $',                                                             '
     .$Id: fcnrcf.f,v 1.2 1996/01/17 22:02:47 page Exp $
     . $' /
C    ===================================================================
C
      DATA ZERO/4H0XXX/,Z/4HXXXX/
      DATA BLNK/1H /,DOT/1H./,MINUS/1H-/
C
      NEGA=.FALSE.
      IF(VALUE.LT.0.)NEGA=.TRUE.
C
      VAL=VALUE
      IF(NEGA)VAL=-VALUE
C
      MXCHR=MAXCHR
      NFILL=0
C
C  FILL CHAR WITH BLANKS
C
      IST=0
      IF(MXCHR.GT.0)GO TO 10
      IST=1
      GO TO 240
C
10    DO 20 I=1,MXCHR
20    CHAR(I)=' '
C
C  CHECK NUMBER OF DECIMAL PLACES REQUESTED
C
      IF(NUMDEC)30,40,60
C
30    CONTINUE
C
C  LESS THAN ZERO - NUMBER MUST BE -1 OR IT IS AN ERROR
C
      IF(NUMDEC.EQ.-1)GO TO 50
      IST=1
      GO TO 240
C
C  NUMDEC IS -1 .. WANT NO DECIMAL PLACES WITHOUT A DECIMAL POINT AS
C  THE RIGHTMOST CHARACTER
C
40    CONTINUE
C
C  EQUAL TO ZERO .. WANT NO DECIMAL PLACES WITH A DECIMAL POINT AS
C  THE RIGHTMOST CHARACTER
C
      CHAR(MXCHR)='.'
      MXCHR=MXCHR-1
      NFILL=NFILL+1
C
C  ROUND VAL TO NEAREST WHOLE NUMBER
C
50    VAL=VAL+0.5
      GO TO 160
C
60    CONTINUE
C
C  GREATER THAN ZERO .. WANT NUMDEC DECIMAL PLACES
C  CHECK THAT NUMDEC IS LT MXCHR
C
      IF(NUMDEC.LT.MXCHR)GO TO 70
      IST=1
      GO TO 240
C
C  MAXIMUM NUMBER OF DECIMAL PLACES ALLOWED IS 9.
C  ALGORITHM TO COMPUTE CHARACTERS FOR DECIMAL PORTION
C  BREAKS DOWN BECAUSE LARGEST ALLOWABLE INTEGER IS
C  APPROX 2*10E10 AND ALLOWING 10 DECIMAL PLACES MAY EXCEED THIS.
C
70    IF(NUMDEC.LT.10)GO TO 80
      IST=2
      NUMDEC=9
C
C  EXTRACT NUMBER OF DECIMAL PLACES WANTED AS AN INTEGER
C  AND USE UFI2A TO PACK INTO THE RIGHTMOST CHARACTERS
C  OF ARRAY TDEC
C
C  ROUND VAL BY ADDING .5 AT DECIMAL PLACE TO THE RIGHT OF
C  THE LAST ONE WANTED
C
80    VAL=VAL+0.501*10.**(-NUMDEC)
C
C  VAL MUST BE LT 2**31 TO BE A VALID INTEGER .. CHECK FOR THIS
C
      IMAX=2147483647
      IF(VAL.LE.IMAX)GO TO 90
C
      IST=3
      GO TO 240
C
90    IDECML=IFIX((VAL-IFIX(VAL))*10**NUMDEC)
      ISTDEC=MXCHR-NUMDEC+1
      TDEC=' '
      CALL UFI2A(IDECML,TDEC,1,MAXCHR,0,6,ISTAT)
      INIT=0
      DO 100 IG=1,MAXCHR
         IF (TDEC(IG:IG).NE.' ') INIT=INIT+1
100   CONTINUE
      IF (IDECML.EQ.0.AND.INIT.EQ.1) THEN
         DO 110 ID=1,NUMDEC-1
            TDEC(MAXCHR-ID:MAXCHR-ID)='0'
110      CONTINUE
         ENDIF
      IPOS=0
      DO 120 IA=1,MAXCHR
         IF (TDEC(IA:IA).NE.' ') THEN
            IPOS=IA
            GOTO 130
            ENDIF
120   CONTINUE
130   IF (IPOS.NE.0) THEN
         TEMPX=' '
         IC=0
         DO 140 IB=IPOS,MAXCHR
            TEMPX(IC+1:IC+1)=TDEC(IB:IB)
            IC=IC+1
140      CONTINUE
         TDEC=' '
         TDEC=TEMPX
         LDEC=0
         CALL ULENTH(TDEC,MAXCHR,LDEC)
         ENDIF
C
      IF (ISTAT.EQ.0) GOTO 150
      IST=1
      GO TO 240
C
150   CONTINUE
C
C  NOW PACK THE WHOLE NUMBER PORTION OF VAL INTO TWHOLE
C
160   CONTINUE
C
      IWHOLE=IFIX(VAL)
      CALL UFI2A(IWHOLE,TWHOLE,1,MAXCHR,0,6,ISTAT)
      IF (ISTAT.NE.0) THEN
         IST=1
         GOTO 240
         ENDIF
      IPOS=0
      DO 170 IA=1,MAXCHR
         IF (TWHOLE(IA:IA).NE.' ') THEN
            IPOS=IA
            GOTO 180
            ENDIF
170   CONTINUE
180   IF (IPOS.NE.0) THEN
         TEMPX=' '
         IC=0
         DO 190 IB=IPOS,MAXCHR
            TEMPX(IC+1:IC+1)=TWHOLE(IB:IB)
            IC=IC+1
190      CONTINUE
         TWHOLE=' '
         TWHOLE=TEMPX
         LWHOLE=0
         CALL ULENTH(TWHOLE,MAXCHR,LWHOLE)
         ENDIF
      TEMP=' '
C
      IF (NUMDEC.GT.0) GOTO 210
C
      IF (NUMDEC.LT.0) GOTO 200
C
         TEMP(1:LWHOLE)=TWHOLE(1:LWHOLE)
         TEMP(LWHOLE+1:LWHOLE+1)='.'
         NFILL=LWHOLE+1
         IF (NEGA) THEN
            TEMP(1:1)='-'
            TEMP(2:LWHOLE+1)=TWHOLE(1:LWHOLE)
            TEMP(LWHOLE+2:LWHOLE+2)='.'
            NFILL=LWHOLE+2
            ENDIF
         GOTO 220
C
200   CONTINUE
         TEMP(1:LWHOLE)=TWHOLE(1:LWHOLE)
         NFILL=LWHOLE
         IF (NEGA) THEN
            TEMP(1:1)='-'
            TEMP(2:LWHOLE+1)=TWHOLE(1:LWHOLE)
            NFILL=LWHOLE+1
            ENDIF
         GOTO 220
C
210   IF (.NOT.NEGA) THEN
         IF (LDEC+LWHOLE.LE.MAXCHR-1) THEN
            TEMP(1:LWHOLE)=TWHOLE(1:LWHOLE)
            TEMP(LWHOLE+1:LWHOLE+1)='.'
            TEMP(LWHOLE+2:LWHOLE+2+LDEC)=TDEC(1:LDEC)
            ENDIF
         ENDIF
C
      IF (NEGA) THEN
         IF (LDEC+LWHOLE.LE.MAXCHR-2) THEN
            TEMP(1:1)='-'
            TEMP(2:LWHOLE+1)=TWHOLE(1:LWHOLE)
            TEMP(LWHOLE+2:LWHOLE+2)='.'
            TEMP(LWHOLE+3:LWHOLE+3+LDEC)=TDEC(1:LDEC)
            ENDIF
         ENDIF
C
      CALL ULENTH(TEMP,MAXCHR,LTEMP)
      NFILL=LTEMP
C
C  CHECK IF DIMENSION EXCEEDS MAXCHR
C
220   IF (NFILL.GT.MAXCHR) THEN
         IST=1
         GOTO 240
         ENDIF
C
C  MOVE CHRACTER REPRESENTATION INTO CHAR
C
      CALL ULENTH(TEMP,MAXCHR,LTEMP)
C
C
      JCOUNT=MAXCHR
      DO 230 IZ=LTEMP,1,-1
         CHAR(JCOUNT)=TEMP(IZ:IZ)
         JCOUNT=JCOUNT-1
230   CONTINUE
C
240   RETURN
      END
