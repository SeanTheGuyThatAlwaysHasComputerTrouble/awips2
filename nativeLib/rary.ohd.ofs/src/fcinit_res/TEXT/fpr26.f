C MODULE FPR26
C-----------------------------------------------------------------------
C
      SUBROUTINE FPR26(PO,IOUNIT)
C
C  SUBROUTINE DECODES AND PRINTS THE RESERVOIR COMMAND LANGUAGE STORE
C  THE P ARRAY FOR THE RESERVOIR OPERATION.
C
      CHARACTER*8 STRNG
C
      DOUBLE PRECISION COMB,LGVDP,KWDSDP,CMPVDP,UTILDP,SCHMDP,FUNCDP
      EQUIVALENCE (LGV(1,1),LGVDP(1,1)),(KWDS(1,1),KWDSDP(1,1)),
     1 (FUNC(1,1),FUNCDP(1,1)),(CMPV(1,1),CMPVDP(1,1)),
     2 (UTIL(1,1),UTILDP(1,1)),(SCHM(1,1),SCHMDP(1,1))
      LOGICAL*1 CVALUE
C
      DIMENSION LGV(4,10),LGVDP(2,10),KWDS(4,19),KWDSDP(2,19),CMPV(4,7),
     1 CMPVDP(2,7),UTIL(4,12),UTILDP(2,12),SCHM(4,15),SCHMDP(2,15),
     2 RCL(20),COMB(3),NCOMB(3),NLGV(10),NKWDS(19),NCMPV(7),NUTIL(12),
     3 NSCHM(15),FUNC(4,2),FUNCDP(2,2),NFUNC(2),OPER(6),OPR(7),NBR(9),
     4 PO(1),CNAME(3),LP(20),LC(3,10),LCMB(10),CVALUE(12),
     5 KOR(10),CCOMB(2),ISTACK(50)
C
      COMMON/CNVP26/CONV1,CONV2,CONV3,CONV4,CONV5,UNT1,UNT2,UNT3,UNT4,
     . UNT5
      INCLUDE 'common/fdbug'
      INCLUDE 'common/ionum'
      REAL*8 HANDLE
      LOGICAL ONLHS
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcinit_res/RCS/fpr26.f,v $
     . $',                                                             '
     .$Id: fpr26.f,v 1.4 2001/06/13 10:10:02 mgm Exp $
     . $' /
C    ===================================================================
C
C***********************************************************************
      DATA BLNK,AMP/4H    ,4H   &/
      DATA NBR/4H(1) ,4H(2) ,4H(3) ,4H(4) ,4H(5) ,
     &         4H(6) ,4H(7) ,4H(8) ,4H(9) /
      DATA OPR/4H+   ,4H-   ,4H*   ,4H/   ,4H(   ,4H)   ,4H=   /
      DATA OPER/4H.GT.,4H.LE.,4H.GE.,4H.LT.,4H.NE.,4H.EQ./
      DATA COMB/8H.AND.   ,8H.OR.    ,8H.NOT.   /
      DATA NCOMB/5,4,5/
      DATA NLGV/5,9,8,7,6,10,8,8,6,7/
      DATA NCMPV/2,2,4,7,3,3,3/
      DATA NKWDS/3,3*0,2,3*0,6,2,4,4,6,5*0,5/
      DATA NSCHM/8,4,4,9,9,8,5,7,4,4,9,8,8,5,5/
      DATA NUTIL/7,6,8,6,8,6,4,8,6,6,7,8/
      DATA NFUNC/4,4/
C
      DATA HANDLE,NUMOP/8HRES-SNGL,26/
      DATA CCOMB/4HAND ,4HOR  /
C
      DATA FUNCDP  /8HRULE    ,8H        , 8HMAXQ    ,8H        /
C
      DATA LGVDP /8HFLOOD   ,8H        , 8HSURCHARG,8HE       ,
     1            8HFORECAST,8H        , 8HGOFLASH ,8H        ,
     2            8HNFLOOD  ,8H        , 8HNSURCHAR,8HGE      ,
     3            8HOBSERVED,8H        , 8HNGOFLASH,8H        ,
     4            8HRISING  ,8H        , 8HFALLING ,8H        /
C
      DATA CMPVDP/8HQO      ,8H        , 8HQI      ,8H        ,
     1            8HPOOL    ,8H        , 8HSTORAGE ,8H        ,
     2            8HDAY     ,8H        , 8HQOM     ,8H        ,
     3            8HQIM     ,8H        /
C
      DATA KWDSDP/8HSET     ,8H        , 8H        ,8H        ,
     1            8H        ,8H        , 8H        ,8H        ,
     2            8HDO      ,8H        , 8H        ,8H        ,
     3            8H        ,8H        , 8H        ,8H        ,
     4            8HENDRCL  ,8H        , 8HIF      ,8H        ,
     5            8HTHEN    ,8H        , 8HELSE    ,8H        ,
     6            8HELSEIF  ,8H        , 8H        ,8H        ,
     7            8H        ,8H        , 8H        ,8H        ,
     8            8H        ,8H        , 8H        ,8H        ,
     9            8HENDIF   ,8H        /
C
      DATA SCHMDP/8HPASSFLOW,8H        , 8HSETQ    ,8H        ,
     1            8HSETH    ,8H        , 8HRULECURV,8HE       ,
     2            8HFILLSPIL,8HL       , 8HSPILLWAY,8H        ,
     3            8HPOOLQ   ,8H        , 8HSTPOOLQ ,8H        ,
     4            8HMINQ    ,8H        , 8HMINH    ,8H        ,
     5            8HINDSRCHG,8HE       , 8HFLASHBDS,8H        ,
     6            8HPOWERGEN,8H        , 8HSETDQ   ,8H        ,
     7            8HSETDH   ,8H        /
C
      DATA UTILDP/8HRULEADJ ,8H        , 8HSUMINF  ,8H        ,
     1            8HRAINEVAP,8H        , 8HADJUST  ,8H        ,
     2            8HBACKFLOW,8H        , 8HCONV24  ,8H        ,
     3            8HMAXQ    ,8H        , 8HENTERISC,8H        ,
     4            8HSETMIN  ,8H        , 8HSETMAX  ,8H        ,
     5            8HGOFLASH ,8H        , 8HWATERUSE,8H        /
C
C
C  SET DEBUG CODES HERE
C
      CALL FPRBUG(HANDLE,1,NUMOP,IBUG)
C
C***********************************************************************
C
C  PRINT 'SET' STATEMENTS, IF ANY. DECIDED BY SCANNING LIST OF COMP
C  VARIABLES FOR TYPE '2' CODES, WHICH IMPLY COMP. VARS DEFINED BY
C  A SET STATEMENT.
C
      LO=PO(13)
      IF(LO.EQ.0)GO TO 18
      NCOMPS=PO(LO)
      LO=LO+1
      DO 10 I=1,NCOMPS
      ITYPE=PO(LO)
      IF(ITYPE.NE.2)GO TO 5
      VALUE=PO(LO+4)
      IU=PO(LO+5)
      CNVT=CONV2
      IF(IU.EQ.0)CNVT=1.0
      IF(IU.EQ.2)CNVT=CONV1
      IF(IU.EQ.3)CNVT=CONV3
      VALUE=VALUE*CNVT
      J=LO+1
C  PUT NAME OF COMPARISON VARIABLE INTO 'CNAME' AND
C  COUNT NUMBER OF CHARACTERS(NCN) IN IT USING SUBROUTINE FCMP26
      CALL FCMP26(PO(J),3,CNAME,NCN)
C  CONVERT 'VALUE' TO CHARACTER REPRESENTATION USING SUBROUTINE FCNRC
      NDP=2
      CALL FCNRCF(VALUE,12,CVALUE,NDP,NCV,ISTAT)
C  PRINT STATEMENT
      CALL UMEMST(BLNK,RCL,20)
      LOR=1
      CALL FRCL26(KWDS(1,1),RCL,LOR,4,IBUG)
      CALL FRCL26(CNAME,RCL,LOR,NCN,IBUG)
      CALL FRCL26(OPR(7),RCL,LOR,1,IBUG)
      K=12-NCV+1
      CALL FRCL26(CVALUE(K),RCL,LOR,NCV,IBUG)
      IF(IOUNIT.EQ.IPR)WRITE(IOUNIT,900) (RCL(L),L=1,20)
 900  FORMAT(1H ,10X,20A4)
      IF(IOUNIT.NE.IPR)WRITE(IOUNIT,901) (RCL(MX),MX=1,18)
 901  FORMAT(18A4)
C
 5    IF(ITYPE.EQ.1)LO=LO+3
      IF(ITYPE.EQ.2)LO=LO+6
      IF(ITYPE.EQ.3)LO=LO+4
 10   CONTINUE
C***********************************************************************
C***********************************************************************
C
C  BEGIN DECODING RCL STATEMENTS, ONE WORD('NUM') AT A TIME
C
 18   LO=PO(12)
      IDO=0
 20   NUM=PO(LO)
      IF(NUM.EQ.19 .OR. NUM.EQ.9)GO TO 50
      IF(NUM.EQ.10 .OR. NUM.EQ.13)GO TO 55
      IF(NUM.EQ.12)GO TO 40
C
C***********************************************************************
C  NUM IS A 'DO' STATEMENT
C
      IF(IDO.EQ.0)GO TO 22
      IF(LORCL.LT.50)GO TO 30
      RCL(18)=AMP
      IF(IOUNIT.EQ.IPR)WRITE(IOUNIT,900) RCL
      IF(IOUNIT.NE.IPR)WRITE(IOUNIT,901) (RCL(MX),MX=1,18)
 22   CALL UMEMST(BLNK,RCL,20)
      LORCL=1
 30   NC=NKWDS(NUM)+1
      CALL FRCL26(KWDS(1,NUM),RCL,LORCL,NC,IBUG)
      LO=LO+1
      NUM=PO(LO)
      GO TO 295
C
C**********************************************************************
C  NUM IS AN 'ELSE' STATEMENT
C
 40   CALL UMEMST(BLNK,RCL,20)
      LORCL=1
      NC=NKWDS(NUM)+1
      CALL FRCL26(KWDS(1,NUM),RCL,LORCL,NC,IBUG)
      IDO=1
      LO=LO+1
      GO TO 20
C
C***********************************************************************
C  NUM IS AN 'ENDIF' OR AN 'ENDRCL' STATEMENT
C
  50  CALL UMEMST(BLNK,RCL,20)
      LORCL=1
      NC=NKWDS(NUM)
      CALL FRCL26(KWDS(1,NUM),RCL,LORCL,NKWDS(NUM),IBUG)
      IF(IOUNIT.EQ.IPR)WRITE(IOUNIT,900) RCL
      IF(IOUNIT.NE.IPR)WRITE(IOUNIT,901) (RCL(MX),MX=1,18)
      IF(NUM.EQ.9)GO TO 400
      LO=LO+1
      IF(PO(LO).LT.0) LO=LO+1
      GO TO 20
C
C***********************************************************************
C  NUM IS AN 'ELSEIF' OR 'IF' STATEMENT.
C
 55   CALL UMEMST(BLNK,RCL,20)
      LORCL=1
      NC=NKWDS(NUM)+1
      CALL FRCL26(KWDS(1,NUM),RCL,LORCL,NC,IBUG)
      CALL FRCL26(OPR(5),RCL,LORCL,1,IBUG)
C
C  LOCATE 'IF' CLAUSE IN PO ARRAY AND DETERMINE HOW TO
C  REARRANGE WORDS FROM REVERSE POLISH NOTATION BACK TO
C  THE ORDER IN WHICH THEY WERE ORIGINALLY INPUT.
C
      NLO=-PO(LO+1)-1
      IFG=NLO+PO(14)
      NVAL=PO(IFG)
C
C  FILL ARRAY LP WITH POSITIONS OF LOGICAL PHRASES/VARIABLES
C
      NLP=0
      L=0
      LONE=0
      DO 80 I=1,NVAL
      NUM=PO(IFG+I)
      IF(NUM.LT.550)GO TO 60
      IF(NUM.GT.600)GO TO 80
C
C  'NUM' IS A LOGICAL VARIABLE
C
      NLP=NLP+1
      LP(NLP)=-I
      GO TO 80
 60   IF(NUM.GT.150 .AND. NUM.LT.170)GO TO 75
      IF(NUM.LT.120 .OR. NUM.GT.500)GO TO 80
C
C  'NUM' IS A COMBINATOR (AND, OR)
C
      L=L+1
      LCMB(L)=I
      KOR(L)=0
      IF(NUM.EQ.139)KOR(L)=1
      GO TO 80
C
C  'NUM' IS AN OPERATOR (EQ,GT,LE, ETC.)
C
 75   NLP=NLP+1
      LP(NLP)=I
 80   CONTINUE
      IF (IBUG.LE.0) GO TO 81
C
      WRITE(IODBUG,1605) L
 1605 FORMAT(' NO. OF COMBINATORS =',I3)
      IF (L.GT.0) WRITE(IODBUG,1606) (LCMB(LL),CCOMB(KOR(LL)+1),LL=1,L)
 1606 FORMAT('  LOCATION OF COMB. =',I3,
     .' TYPE IS ',A4,'.')
      WRITE(IODBUG,1607) NLP,(LP(NLPP),NLPP=1,NLP)
 1607 FORMAT(' NO. OF PHRASES/OPERATORS =',I3,' LOCATIONS =',10I4)
C
C  NCMB=THE NUMBER OF COMBINATORS IN THE 'IF' CLAUSE
C
   81 CONTINUE
      NCMB=L
      IF(NCMB.NE.0)GO TO 84
C
C  'IF' CLAUSE CONSISTS OF ONLY ONE LOGICAL PHRASE/VARIABLE
C
      LONE=1
      IFIRST=0
      ML=LP(1)
      KL=L
      GO TO 135
C
C  FILL ARRAY LC FOR EACH  LC(1,N)= POSITION OF CURRENT COMBINATOR(N)
C  COMBINATOR(N):          LC(2,N)= POSITION OF LOGICAL PHRASE/COMBIN
C                                   TO THE RIGHT OF CURRENT COMB.
C                          LC(3,N)= POSITION OF LOGICAL PHRASE/COMBIN
C                                   TO THE LEFT OF CURRENT COMBINATOR
C
C  NOTE: A RIGHT OR LEFT POSITION GREATER THAN 100 MEANS THAT SIDE
C        OF THE COMBINATOR IS ANOTHER COMBINATOR AND ITS SIDES.
C        LESS THAN 100 MEANS THE SIDE IS THE BASIC LOGICAL PHRASE.
C
 84   DO 100 I=1,NCMB
      LC(1,I)=LCMB(I)
      MR=LC(1,I)-1
      IF(I.EQ.1)GO TO 115
      KEI = I-1
      DO 110 K=1,KEI
      IF(MR.NE.LC(1,K))GO TO 110
      LC(2,I)=100+K
      ML=LC(3,K)
 85   IF(ML.LT.100)GO TO 90
      KL=ML-100
      ML=LC(3,KL)
      GO TO 85
 90   IF(ML.LT.0)ML1=-ML-1
      IF(ML.GT.0)ML1=ML-3
 92   DO 105 KK=1,I
      IF(LC(1,KK).NE.ML1)GO TO 105
      LC(3,I)=100+KK
      GO TO 127
 105  CONTINUE
      DO 108 L=1,NLP
      IF(ML1.NE.IABS(LP(L)))GO TO 108
      LC(3,I)=LP(L)
 108  CONTINUE
      GO TO 127
 110  CONTINUE
C
 115  DO 120 L=1,NLP
      IF(MR.NE.IABS(LP(L)))GO TO 120
      LC(2,I)=LP(L)
      GO TO 125
 120  CONTINUE
 125  ML1=LC(2,I)-3
      IF(LC(2,I).LT.0)ML1=IABS(LC(2,I))-1
      GO TO 92
 127  CONTINUE
      IF (IBUG.GT.0) WRITE(IODBUG,1610) I,(LC(MB,I),MB=1,3)
 1610 FORMAT(' COMB. NO. =',I3,' CURRENT, RIGHT, AND LEFT POSITIONS =',
     .  3I4)
 100  CONTINUE
C
C  DECODE AND PRINT 'IF' CLAUSE NOW USING THE ORDER
C  INFORMATION STORED IN THE LC ARRAY AND A STACK ARRAY.
C
C  WE START WITH THE LAST COMBINATOR, AND WORK THROUGH UNTIL WE'VE
C  PRINTED ALL COMBINATORS WITH THEIR LEFT AND RIGHT HAND SIDES AND
C  ALL THE APPROPRIATE PARENTHESES.
C
C  THE FIRST COMBINATOR IS PUSHED INTO THE TOP OF THE STACK. EVERY
C  TIME A COMB. IS PUSHED WE SET THE 'ON LEFT-HAND-SIDE' TO ON, AND
C  PRINT A '(' IF THE COMBINATOR IS AN 'OR'.
C
      NCMBPR = 0
      NSTACK = 0
C
C  PUSH THE LAST COMB. TO TOP OF STACK
C
      CALL FPUS26(ISTACK,NCMB,NSTACK,ONLHS,KOR,RCL,LORCL,IBUG)
C
C  STATEMENT 1110 IS THE TOP OF THE LOOP FOR PUTTING THE IF CLAUSE T
C  TOGETHER.
C
 1110 CONTINUE
C
C  WE WANT TO LOOK AT THE COMB. AT THE TOP OF THE STACK AND GET THE
C  POSITION OF EITHER THE LHS OR RHS OF THE COMB. (DEPENDING ON VALUE
C  OF 'ONLHS'.
C
      ITOP = ISTACK(1)
      ICKPOS = LC(2,ITOP)
      IF (ONLHS) ICKPOS = LC(3,ITOP)
C
C  IF POSITION OF RHS OR LHS IS GT 100, IT MEANS THAT SIDE IS ANOTHER
C  COMBINATOR WITH ITS APPROPRIATE SIDES. HERE WE SEE WHAT COMB. IT IS
C  BY SUBTRACTING 100 FROM THE POSITION, THEN WE PUSH THAT COMB. ONTO
C  THE TOP OF THE STACK, AND GO BACK TO 1110 TO LOOK FOR LHS POSITION
C  OF CURRENT COMB (I.E. THE ONE ON TOP OF THE STACK). WE KEEP DOING
C  THIS UNTIL THE LHS POSITION IS LT 100, WHICH MEANS WE'RE AT THE
C  LOGICAL PHRASE, AND THEN WE PRINT IT.
C
      IF (ICKPOS .LT. 100) GO TO 130
C
C  POSITION IS GT 100. IT'S REFERRING TO COMBINATOR (ICKPOS-100).
C
      NUMCMB = ICKPOS - 100
C
      CALL FPUS26(ISTACK,NUMCMB,NSTACK,ONLHS,KOR,RCL,LORCL,IBUG)
      GO TO 1110
C
C  HERE WE'RE DOWN TO THE ACTUAL LOGICAL PHRASE. JUST PRINT IT!
C
  130 CONTINUE
      ML = ICKPOS
C
C  CONTROL REACHES STMT 135 DIRECTLY IF ONLY A SINGLE LOGICAL
C  PHRASE/VARIABLE IS FOUND IN THE IF CLAUSE.
C
  135 CONTINUE
      IF(ML.LT.0)GO TO 190
C
C  ML POINTS TO A LOGICAL PHRASE
C
      N2=ML+IFG
      N1=N2-2
      N3=N2-1
      IFIRST=0
      NAME=PO(N1)
C
 140  IF(NAME.LT.0)GO TO 150
C
C  NAME IS A SYSTEM COMPARISON VARIABLE
C
      NAME=NAME-500
      CALL FRCL26(CMPV(1,NAME),RCL,LORCL,NCMPV(NAME),IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      GO TO 185
C
C  NAME IS A USER DEFINED COMPARISON VARIABLE
C
 150  LOC=PO(13)-NAME-1
      ITYPE=PO(LOC)
      LOC=LOC+1
      GO TO(155,160,165),ITYPE
C
C  TYPE OF COMPARISON VARIABLE=CONSTANT VALUE, NO NAME
C
 155  VALUE=PO(LOC)
      LOC=LOC+1
      IU=PO(LOC)
      CNVT=CONV2
      IF(IU.EQ.0)CNVT=1.0
      IF(IU.EQ.2)CNVT=CONV1
      IF(IU.EQ.3)CNVT=CONV3
      VALUE=VALUE*CNVT
C
C  CONVERT 'VALUE' TO CHARACTER REPRESENTATION.
C
      NDP=2
      CALL FCNRCF(VALUE,12,CVALUE,NDP,NCV,ISTAT)
      K=12-NCV+1
      CALL FRCL26(CVALUE(K),RCL,LORCL,NCV,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      GO TO 185
C
C  TYPE OF COMPARISON VARIABLE=CONSTANT VALUE WITH NAME
C
 160  CALL FCMP26(PO(LOC),3,CNAME,NCN)
      CALL FRCL26(CNAME,RCL,LORCL,NCN,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      GO TO 185
C
C  TYPE OF COMPARISON VARIABLE=FUNCTION OR (FUNCTION)(OPERATOR)(FACTO
C
 165  INM=0
      JUNC=1
      IF(PO(LOC).GT.1000.)JUNC=2
      IF(JUNC.EQ.1)GO TO 170
      JM=PO(LOC)/10-156
      RM=PO(LOC)/10.-156.
      DIFF=(RM-JM)*10.+.01
      INM=DIFF
  170 CONTINUE
      CALL FRCL26(FUNC(1,JUNC),RCL,LORCL,NFUNC(JUNC),IBUG)
      IF(INM.LE.1)GO TO 180
      CALL FRCL26(NBR(INM),RCL,LORCL,3,IBUG)
  180 CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      NOP=PO(LOC+1)
      IF(NOP.EQ.0)GO TO 185
C
C  FUNCTION IS OPERATED ON BY A FACTOR
C
      FACT=PO(LOC+2)
      IF(NOP.NE.1 .AND. NOP.NE.2)GO TO 182
      CNVT=CONV1
      IF(JUNC.EQ.2)CNVT=CONV2
      FACT=FACT*CNVT
  182 CALL FRCL26(OPR(NOP),RCL,LORCL,1,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
C
C  CONVERT 'FACT' TO CHARACTER REPRESENTATION
C
      NDP=2
      CALL FCNRCF(FACT,12,CVALUE,NDP,NCV,ISTAT)
      K=12-NCV+1
      CALL FRCL26(CVALUE(K),RCL,LORCL,NCV,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
C
 185  IF(IFIRST.EQ.1)GO TO 200
C
C  NAME IS A COMPARATIVE OPERATOR
C
      NAME=PO(N2)-163
      CALL FRCL26(OPER(NAME),RCL,LORCL,4,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      IFIRST=1
      NAME=PO(N3)
      GO TO 140
C
C  ML POINTS TO A LOGICAL VARIABLE
C
 190  LV=-ML+IFG
      NAME=PO(LV)-550
      CALL FRCL26(LGV(1,NAME),RCL,LORCL,NLGV(NAME),IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
C
C  LOCATE NEXT POSITION TO PRINT BY SEARCHING FOR THE POSITION
C  PRIOR TO THE FIRST 999.
C
 200  IF(LONE.EQ.1)GO TO 250
C
C  NOW WE'RE DONE PRINTING THE ACTUAL LOGICAL PHRASE. IF THE PHRASE
C  WAS ON THE LHS OF THE COMB. WE MUST PRINT THE COMBINATOR (AND
C  PARENS IF IT'S AN OR), INCREMENT THE NO. OF COMBS. ALREADY PRINTED
C  , SET THE LHS SWITCH TO OFF, AND LOOK TO PRINT THE RHS OF THE
C  COMB.
C
C  IF IT'S THE RHS, WE MUST CLOSE OUT THE PARENS (IF THE TOP COMB.
C  IS AN 'OR'), MOVE THE SECOND COMB. IN THE STACK TO THE TOP AND
C  CHECK IF WE'VE PRINTED ALL THE COMBS. IF WE HAVE THEN WE JUST
C  CLOSE OUT THE PHRASE (POPPING THE STACK AND WRITING ')'S IF THE
C  TOP OF THE STACK IS AN 'OR'. DO THIS UNTIL WE'VE DEPLETED THE STACK.
C
C  IF WE HAVEN'T PRINTED ALL COMBS, THEN WE'RE DONE WITH THE RHS OF
C  ONE COMB WHICH CONSTITUTES THE LHS OF THE NEXT COMB., AND WE TREAT
C  IT AS IF WE'RE ON THE LHS OF THE TOP COMB. (I.E - GO TO STATEMENT
C  210 TO PRINT TOP COMB AND PARENS IF NECESSARY)
C
      IF (.NOT.ONLHS) GO TO 230
C
C  ON LEFT HAND SIDE OF TOP COMB.
C
  210 CONTINUE
      IF (KOR(ITOP).EQ.1) CALL FRCL26(OPR(6),RCL,LORCL,1,IBUG)
C
C  PRINT COMB.
C
      CALL FRCL26(COMB(KOR(ITOP)+1),RCL,LORCL,NCOMB(KOR(ITOP)+1),IBUG)
       CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      IF (KOR(ITOP).EQ.1) CALL FRCL26(OPR(5),RCL,LORCL,1,IBUG)
C
C  INCREMENT NO. OF COMBS. PRINTED, AND SET LHS SWITCH TO OFF
C
      NCMBPR = NCMBPR + 1
      ONLHS = .FALSE.
      GO TO 1110
C
C  ON RHS OF COMB.
C
  230 CONTINUE
      IF (KOR(ITOP).EQ.1) CALL FRCL26(OPR(6),RCL,LORCL,1,IBUG)
C
C  POP TOP COMB OFF STACK. CHECK TO SEE IF WE'VE PRINTED ALL COMBS.
C
      CALL FPOP26(ISTACK,NSTACK,IBUG)
      ITOP = ISTACK(1)
C
C  IF WE'RE NOT DONE PRINTING, PRINT TOP COMB.
C  IF WE'RE DONE PRINTING, JUST KEEP POPPING AND CLOSING OUT THE IF
C  CLAUSE.
C
      IF (NCMBPR .LT. NCMB) GO TO 210
C
C  ALL COMBS. PRINTED. JUST CLOSE OUT CLAUSE WITH PARENS (IF NEEDED).
C
  240 CONTINUE
      IF (NSTACK .LE. 0) GO TO 250
      IF (KOR(ISTACK(1)) .EQ. 1) CALL FRCL26(OPR(6),RCL,LORCL,1,IBUG)
       CALL PRCL26(IOUNIT,RCL,LORCL,55,IBUG)
      CALL FPOP26(ISTACK,NSTACK,IBUG)
      IF (NSTACK .GT. 0) GO TO 240
 250  CONTINUE
C
C   FINISHED PRINTING 'IF' CLAUSE. CONTINUE TO PRINT NEXT KEYWORD.
C
      CALL FRCL26(OPR(6),RCL,LORCL,2,IBUG)
      CALL PRCL26(IOUNIT,RCL,LORCL,60,IBUG)
      NC=NKWDS(11)+1
      CALL FRCL26(KWDS(1,11),RCL,LORCL,NC,IBUG)
      IDO=1
      LO=LO+3
      GO TO 20
C
C***********************************************************************
C  NUM IS THE NAME OF A 'SCHEME' OR 'UTILITY'
C
 295  IBASE=NUM/10
      LEVEL=NUM-IBASE*10
      IF(IBASE.LT.150)GO TO 300
C
C  'NUM' IS A UTILITY
C
      NUM=IBASE-150
      NC=NUTIL(NUM)+1
      CALL FRCL26(UTIL(1,NUM),RCL,LORCL,NC,IBUG)
      GO TO 305
C
C  'NUM' IS A SCHEME
C
 300  NUM=IBASE-100
      NC=NSCHM(NUM)+1
      CALL UMEMOV (SCHM(1,NUM),STRNG,2)
      CALL FRCL26(SCHM(1,NUM),RCL,LORCL,NC,IBUG)
 305  IF(LEVEL.LE.1)GO TO 310
      LORCL=LORCL-1
      CALL FRCL26(NBR(LEVEL),RCL,LORCL,3,IBUG)
 310  CONTINUE
      IDO=0
      IF(IOUNIT.EQ.IPR)WRITE(IOUNIT,900) RCL
      IF(IOUNIT.NE.IPR)WRITE(IOUNIT,901) (RCL(MX),MX=1,18)
      LO=LO+1
      IF(PO(LO).LT.0)LO=LO+1
      IF (IBUG.GT.0) THEN
         WRITE (IPR,*) 'STRNG=',STRNG,' LO=',LO
         ENDIF
      GO TO 20
C
C***********************************************************************
C***********************************************************************
C  FINISHED PRINTING RCL STATEMENTS
 400  CONTINUE
      RETURN
      END
