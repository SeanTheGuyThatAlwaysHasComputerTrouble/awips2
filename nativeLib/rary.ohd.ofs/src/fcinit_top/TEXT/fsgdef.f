C MODULE FSGDEF
C-----------------------------------------------------------------------
C
      SUBROUTINE FSGDEF (NEWSEGC,MC,C,MOLDC,OLDC,MRSTC,RESETC,
     *  MP,P,MOLDP,OLDP,MT,T,MOLDT,OLDT,MTS,TS,MOLDTS,OLDTS,IENDIN)
C
C  ROUTINE TO RUN SEGDEF AND RESEGDEF COMMANDS.
C
C  NEWSEGC=1 FOR SEGDEF COMMAND.
C  NEWSEGC=0 FOR RESEGDEF COMMAND.
C
C  ROUTINE ORIGINALLY WRITTEN BY ED JOHNSON - HRL - 10/1979
C
      CHARACTER*1 DLIM
      CHARACTER*4 EDTYPE,EFILETP
      CHARACTER*6 DEFTS/'DEF-TS'/
      CHARACTER*8 ETSID,EPROCTP
      CHARACTER*8 RTNNAM,OPNOLD
      CHARACTER*8 SEGID,ESEGID,SEGIDX
      CHARACTER*20 STRNG,CHKSTR
      CHARACTER*80 CARD
      CHARACTER*32 FILENAME
      CHARACTER*160 PATHNAME
C
      DIMENSION C(MC),OLDC(MOLDC),RESETC(MRSTC)
      DIMENSION P(MP),OLDP(MOLDP)
      INTEGER   T(MT),OLDT(MOLDT)
      DIMENSION TS(MTS),OLDTS(MOLDTS)
      PARAMETER (LARRAY=100)
      DIMENSION ARRAY(LARRAY)
      PARAMETER (MTTS=2500)
      DIMENSION TTS(MTTS)
      PARAMETER (MPESP=1000)
      DIMENSION PESP(MPESP)
      PARAMETER (MSPESP=1)
      DIMENSION SPESP(MSPESP)
      PARAMETER (MTSESP=10000)
      DIMENSION TSESP(MTSESP),TSESPO(MTSESP)
C
      DATA BLANK/4h    /
C
      EQUIVALENCE (BLANK,IBLANK)
C
      INCLUDE 'common/ionum'
      INCLUDE 'common/fdbug'
      INCLUDE 'common/errdat'
      INCLUDE 'common/where'
      INCLUDE 'common/fd'
      INCLUDE 'common/fcsegn'
      INCLUDE 'common/fcsgnn'
      INCLUDE 'common/fcsegp'
      INCLUDE 'common/flarys'
      INCLUDE 'common/fctime'
      INCLUDE 'common/fccgd'
      INCLUDE 'common/fcfgs'
      INCLUDE 'common/fcunit'
      INCLUDE 'common/espfle'
      INCLUDE 'common/espseg'
      INCLUDE 'common/eunit'
      INCLUDE 'common/esprec'
      INCLUDE 'common/edata'
      INCLUDE 'scommon/sugnlx'
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcinit_top/RCS/fsgdef.f,v $
     . $',                                                             '
     .$Id: fsgdef.f,v 1.13 2004/02/02 20:34:56 jgofus Exp $
     . $' /
C    ===================================================================
C
C
      RTNNAM='FSGDEF'
C
      IOPNUM=0
      CALL FSTWHR (RTNNAM,IOPNUM,OPNOLD,IOLDOP)
C
      IF (ITRACE.GE.1) WRITE (IODBUG,*) 'ENTER ',RTNNAM
C
      IBUG=IFBUG('SEGD')
C
      NBLINE=1
      IFORM=1
      NCARD=0
      IEUPDT=1
C
C  READ INPUT CARDS
C
C  READ CARD 1

C   The following fixes HSD bug r23-38:
CHDH  ====================================================
CHDH  The do loop that follows was added by me.  I need
CHDH  to initialize the entire P array before each segment
CHDH  to all 0.0.
10    DO 501 I=1,MP
        P(I)=0.0
  501 CONTINUE
CHDH  ====================================================

      ICARD=1
      IEND=1
20    READ (IN,'(A)',END=110) CARD
C  PRINT CARD
      CALL UPRCR2 (NBLINE,IFORM,IPR,CARD,NCARD)
C  CHECK FOR COMMENT CARD
      IF (CARD(1:1).EQ.'$') GO TO 20
      NSCAN=1
      DLIM=' '
      CALL USCAN2 (CARD,DLIM,NSCAN,STRNG,LSTRNG,IERR)
      IF (STRNG.EQ.'END'.OR.STRNG.EQ.'ENDSEG') GO TO 110
      IF (STRNG.EQ.'STOP'.OR.STRNG.EQ.'@STOP') THEN
         IENDIN=1
         GO TO 110
         ENDIF
      STRNG=CARD(1:10)
C  GET SEGMENT ID
      CALL UMEMOV (CARD(13:13),JDSEGN,2)
      CALL UMEMOV (JDSEGN,SEGID,2)
      CALL UMEMOV (JDSEGN,ISEG,2)
C  GET LATITUDE AND LONGITUDE
      NCHAR=10
      NDEC=0
      IPRERR=1
      IBEG=21
      CALL UFA2F (CARD,IBEG,NCHAR,NDEC,REAL,IPRERR,IPR,IERR)
      XLATJ=REAL
      IBEG=31
      CALL UFA2F (CARD,IBEG,NCHAR,NDEC,REAL,IPRERR,IPR,IERR)
      XLONGJ=REAL
      IEND=0
      CHKSTR='IDENTIFIER'
      IF (STRNG(1:4).NE.CHKSTR(1:4)) THEN
         WRITE (IPR,30) STRNG(1:LENSTR(STRNG)),CHKSTR(1:LENSTR(CHKSTR)),
     *     DEFTS(1:LENSTR(DEFTS))
30    FORMAT ('0**ERROR** IN FSGDEF - ',
     *   'CARD BEGINNING ''',A,''' SHOULD BEGIN ''',A,
     *   '''. BEGIN SEARCHING FOR ''',A,''' CARD.')
         CALL ERROR
         GO TO 110
         ENDIF
C
C  READ CARD 2
      ICARD=2
40    READ (IN,'(A)',END=90) CARD
C  PRINT CARD
      CALL UPRCR2 (NBLINE,IFORM,IPR,CARD,NCARD)
C  CHECK FOR COMMENT CARD
      IF (CARD(1:1).EQ.'$') GO TO 40
      READ (CARD,50,END=90) STRNG,(SGDSCJ(I),I=1,5)
50    FORMAT (A10,5A4)
      CHKSTR='TITLE'
      IF (STRNG(1:4).NE.CHKSTR(1:4)) THEN
         WRITE (IPR,30) STRNG,CHKSTR
         CALL ERROR
         GO TO 110
         ENDIF
C
C  READ CARD 3
      ICARD=3
60    READ (IN,'(A)',END=90) CARD
C  PRINT CARD
      CALL UPRCR2 (NBLINE,IFORM,IPR,CARD,NCARD)
C  CHECK FOR COMMENT CARD
      IF (CARD(1:1).EQ.'$') GO TO 60
      READ (CARD,70,END=90) STRNG,((JUPSEG(I,J),I=1,2),J=1,5)
70    FORMAT (A10,5(2X,2A4))
      CHKSTR='UPSTREAM'
      IF (STRNG(1:4).NE.CHKSTR(1:4)) THEN
         WRITE (IPR,30) STRNG,CHKSTR
         CALL ERROR
         GO TO 110
         ENDIF
      DO 73 I=1,5
         CALL UMEMOV (JUPSEG(1,I),SEGIDX,LEN(SEGIDX)/4)
         IF (SEGIDX.NE.' ') THEN
            CALL UBEGIN (SEGIDX,LEN(SEGID),LBEGIN)
            IF (LBEGIN.GT.1) THEN
               WRITE (IPR,75) LBEGIN,CHKSTR(1:LENSTR(CHKSTR)),SEGIDX
75    FORMAT ('0**WARNING** LOCATION IF FIRST NON-BLANK CHARACTER (',I1,
     *   ') IS NOT 1 FOR ',A,' SEGMENT ',A,'.')
               CALL WARN
               ENDIF
            ENDIF
73      CONTINUE
C
C  READ CARD 4
      ICARD=4
80    READ (IN,'(A)',END=90) CARD
C  PRINT CARD
      CALL UPRCR2 (NBLINE,IFORM,IPR,CARD,NCARD)
C  CHECK FOR COMMENT CARD
      IF (CARD(1:1).EQ.'$') GO TO 80
      READ (CARD,70,END=90) STRNG,((JDNSEG(I,J),I=1,2),J=1,2)
      CHKSTR='DOWNSTREAM'
      IF (STRNG(1:4).NE.CHKSTR(1:4)) THEN
         WRITE (IPR,30) STRNG,CHKSTR
         CALL ERROR
         GO TO 110
         ENDIF
      DO 83 I=1,2
         CALL UMEMOV (JDNSEG(1,I),SEGIDX,LEN(SEGIDX)/4)
         IF (SEGIDX.NE.' ') THEN
            CALL UBEGIN (SEGIDX,LEN(SEGID),LBEGIN)
            IF (LBEGIN.GT.1) THEN
               WRITE (IPR,75) LBEGIN,CHKSTR(1:LENSTR(CHKSTR)),SEGIDX
               CALL WARN
               ENDIF
            ENDIF
83      CONTINUE
C
      GO TO 110
C
C  UNEXPECTED END OF FILE
90    WRITE (IPR,100)
100   FORMAT ('0**ERROR** IN FSGDEF - UNEXPECTED END OF FILE.')
      CALL ERROR
      GO TO 110
C
110   IF (IEND.EQ.1) GO TO 660
C
C  CHECK FOR VALID IDENTIFIER
      IPRERR=1
      CALL FCIDCK (JDSEGN,8,1,3,IPRERR,IERR)
      IF (IERR.NE.0) THEN
         WRITE (IPR,120) JDSEGN
120   FORMAT ('0**ERROR** SEGMENT IDENTIFIER ',2A4,' IS INVALID.')
         CALL ERROR
         ENDIF
C
C  CHECK IF SEGMENT EXISTS
      IEREC=0
      CALL FLOCSG (JDSEGN,IRSEG)
      IF (IRSEG.GT.0) THEN
C     GET OLD SEGMENT DEFINITION - NEED TO GET VALUE OF IWKLOC FOR
C     ESP SEGMENT DEFINITIONS
         IBYREC=1
         NOPARM=0
         CALL FGETSG (IDSEGN,IRSEG,MOLDP,OLDP,MOLDT,OLDT,
     *      MOLDTS,OLDTS,IBYREC,NOPARM,IER)
         ELSE
            IWKLOC=-1
         ENDIF
      INEWSEG=0
      IF (IRSEG.EQ.0) INEWSEG=1
      IF (INEWSEG.NE.NEWSEGC) THEN
         IF (NEWSEGC.EQ.0) THEN
C        ATTEMPT TO REDEFINE A SEGMENT THAT DOES NOT EXIST
            WRITE (IPR,290) JDSEGN
290   FORMAT ('0**WARNING** SEGMENT ',2A4,' DOES NOT EXIST. ',
     * 'COMMAND SEGDEF ASSUMED INSTEAD OF COMMAND RESEGDEF.')
            CALL WARN
            INEWSEG=1
            ENDIF
         IF (NEWSEGC.EQ.1) THEN
C        ATTEMPT TO DEFINE AN SEGMENT THAT EXISTS
            WRITE (IPR,270) JDSEGN
270   FORMAT ('0**ERROR** SEGMENT ',2A4,' EXISTS AND CAN BE CHANGED ',
     * 'WITH THE COMMAND RESEGDEF.')
            CALL ERROR
            INEWSEG=-1
            ENDIF
         ENDIF
C
C  READ UGNL PARAMETERS TO GET LATITUDE AND LONGITUDE LIMITS
      IF (IUGFIL.EQ.0) CALL SUGTUG (LARRAY,ARRAY,IERR)
C
C  CHECK LATITUDE AND LONGITUDE
      IF (XLATJ.GE.ULLMTS(2).AND.XLATJ.LE.ULLMTS(1)) THEN
         ELSE
            WRITE (IPR,130) 'LATITUDE',XLATJ,ULLMTS(2),ULLMTS(1)
130   FORMAT ('0**ERROR** IN FSGDEF - ',
     *   A,' ',F8.1,' IS OUT OF RANGE. ',
     *   'VALID VALUES ARE ',F7.1,' THROUGH ',F7.1,'.')
            CALL ERROR
         ENDIF
      IF (XLONGJ.GE.ULLMTS(3).AND.XLONGJ.LE.ULLMTS(4)) THEN
         ELSE
            WRITE (IPR,130) 'LONGITUDE',XLONGJ,ULLMTS(3),ULLMTS(4)
            CALL ERROR
         ENDIF
C
      IF (NEWSEGC.EQ.0) STRNG='SEGMENT REDEFINITION'
      IF (NEWSEGC.EQ.1) STRNG=' SEGMENT DEFINITION'
      WRITE (IPR,140) STRNG,JDSEGN
140   FORMAT ('1',80('*') / ' ','*',78X,'*' / ' ','*',29X,A,29X,'*' /
     *   ' ','*',27X,'SEGMENT NAME = ',2A4,28X,'*' / ' ','*',78X,'*' /
     *   ' ',80('*'))
C
C  SET SEGMENT COMPLETION SWITCH TO INCOMPLETE
      JDEFSG=0
C
C  READ DEF-TS CARD
150   READ (IN,160,END=180) CARD
160   FORMAT (A)
      IF (CARD(1:6).NE.DEFTS) THEN
         WRITE (IPR,170) DEFTS(1:LENSTR(DEFTS)),CARD(1:LENSTR(CARD))
170   FORMAT ('0**ERROR** IN FSGDEF - ''',A,''' EXPECTED ',
     *  'ON THE FOLLOWING CARD:' / ' ',A)
         CALL ERROR
         GO TO 150
         ENDIF
      GO TO 200
180   WRITE (IPR,190) DEFTS(1:LENSTR(DEFTS))
190   FORMAT ('0**ERROR** IN FSGDEF - END OF FILE ',
     *  'ENCOUNTERED SEARCHING FOR ''',A,''' CARD.')
      CALL ERROR
      GO TO 660
C

C ew Gather ESP information for all segs
200      FILENAME='ESPPARM'
         LFILENAME=LENSTR(FILENAME)
         CALL UPPFIX ('OPER',FILENAME,PATHNAME,LPATHNAME)
         IUNIT=0
         CALL UPEXIS (IUNIT,PATHNAME,IERR)
         IF (IERR.NE.0) THEN
            WRITE (IPR,201) FILENAME(1:LFILENAME)
201   FORMAT ('0**ERROR** FILE ',A,' NOT FOUND.')
            CALL ERROR
            IER=1
            INDERR=1
            GO TO 208
            ENDIF
C     READ FIRST RECORD OF FILE ESPPARM
         IREC=1
         CALL UREADT (KEPARM,IREC,ESPDAT,IERR)
         IF (IERR.NE.0) THEN
            WRITE (IPR,203) IERR,IREC
203   FORMAT ('0**ERROR** READING THE FIRST RECORD OF THE ',
     +           'ESPPARM FILE.')
            CALL ERROR
            IER=1
            INDERR=1
            GO TO 208
            ENDIF
         MXREC=ESPDAT(1)
         NXREC=ESPDAT(2)
         LRECL=ESPDAT(3)

C  CHECK IF SEGMENT HAD AN ESP DEFINITION
      IF (IEREC.GT.0) THEN
C     UPDATE ESP SEGMENT DEFINITION
C     GET OLD ESP SEGMENT DEFINITION
         IFILLA=1
         ICHKID=0
         CALL ESPRDF (IFILLA,ICHKID,IEREC,TSESPO,MTSESP,PESP,MPESP,
     *      SPESP,MSPESP,IERR)
         IF (IERR.NE.0) THEN
            WRITE (IPR,205)
205   FORMAT ('0**ERROR** ENCOUNTERED IN ROUTINE ESPRDF.')
            CALL ERROR
            ENDIF
       ENDIF
C
C  DEFINE TIME SERIES
208   NXD=1
      CALL UMEMST (0.0,TTS,MTTS)
      IESPTS=0
      CALL TSDEF (TS,MTS,D,MD,NXD,MSNGTS,LWMAX,
     *   TTS,MTTS,TSESP,MTSESP,IESPTS)
C
C  CHECK IF DEFINED IN FILE ESPPARM BUT NO ESP TIME SERIES SPECIFIED
      IF (IEREC.GT.0.AND.IESPTS.EQ.0) THEN
         WRITE (IPR,209) JDSEGN
209   FORMAT ('0**ERROR** SEGMENT ',2A4,' IS DEFINED IN THE ',
     *   'ESP PARAMETER FILE BUT NO ESP TIME SERIES WERE SPECIFIED.')
         CALL ERROR
         ENDIF
C
      IF (MSNGTS.GT.0) JDEFSG=2
C
C  SET FIRST AVAILABLE POSITION IN D ARRAY FOR WORK SPACE - SAME AS
C  IWKLOC IN COMMON FCSEGN
      JWKLOC=NXD
C
C  CHECK IF ESP TIME SERIES DEFINED
      IF (IESPTS.EQ.1) THEN
         ITSESP=0
C     GET TIME SERIES TYPE
207      IETSTYP=TSESP(ITSESP+1)
         IF (IBUG.EQ.1) THEN
            WRITE (IODBUG,*) ' IETSTYP=',IETSTYP
            ENDIF
         IF (IETSTYP.GT.0.AND.IETSTYP.LT.4) THEN
            CALL UMEMOV (TSESP(ITSESP+3),ETSID,2)
            CALL UMEMOV (TSESP(ITSESP+5),EDTYPE,1)
            CALL UMEMOV (TSESP(ITSESP+10),EFILETP,1)
            IF (IBUG.EQ.1) THEN
               WRITE (IODBUG,*) ' ETSID=',ETSID,
     *            ' EDTYPE=',EDTYPE,' EFILETP=',EFILETP
               ENDIF
C        CHECK ESP FILE TYPE
            IF (EFILETP.EQ.'GENR') THEN
               IPOS=13
               CALL UMEMOV (TSESP(ITSESP+IPOS),EPROCTP,2)
C           CHECK IF GENERATE TYPE
               IF (EPROCTP.EQ.'BLEND-TS') THEN
C              GET LOCATION OF FUTURE DATA IN THE D ARRAY
                  IPOS=23
                  ILOCDF=TSESP(ITSESP+IPOS)
                  IF (IBUG.EQ.1) THEN
                     WRITE (IODBUG,*) ' EPROCTP=',EPROCTP,
     *                  ' ILOCDF=',ILOCDF
                     ENDIF
                  IF (ILOCDF.LT.0) THEN
C                 VALUE IF IWKLOC WAS NOT KNOWN WHEN TIME SERIES DEFINED
                     ILOCDF=JWKLOC+IABS(ILOCDF)
                     IF (IBUG.EQ.1) THEN
                        WRITE (IODBUG,*) ' ILOCDF=',ILOCDF
                        ENDIF
                     TSESP(ITSESP+IPOS)=ILOCDF+.01
                     IF (IBUG.EQ.1) THEN
                        WRITE (IODBUG,*) ' TSESP(ITSESP+IPOS)=',
     *                     TSESP(ITSESP+IPOS)
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ITSESP=TSESP(ITSESP+2)-1
            IF (ITSESP.LT.MTSESP) GO TO 207
            ENDIF
         ENDIF
C
C  UPDATE PROCESSED DATA BASE CONTROLS
      CALL WPDBCO (IERR)
      CALL UCLOSL
      IF (IERR.NE.0) THEN
         WRITE (IPR,210) JDSEGN
210   FORMAT ('0**ERROR** DUE TO ERROR IN ROUTINE WPDBCO, ',
     *   'ALL TIME-SERIES IN SEGMENT ',2A4,' HAVE NOT BEEN CREATED.')
         CALL ERROR
         ENDIF
C
C  SET UP THE OPERATIONS TABLE
      CALL SETUP (P,MP,RESETC,MRSTC,T,MT,TS,MTS,D,MD,NXD,JMINDT,LWMAX,
     *   IENDIN)
      IOPNUM=0
      CALL UMEMOV (RTNNAM,OPNAME,2)
C
C  CHECK SIZE OF C ARRAY AGAINST MC AND MOLDC
      IF (LC.LE.MC.AND.LC.LE.MOLDC) GO TO 230
         WRITE (IPR,220) LC,MC,MOLDC
220   FORMAT ('0**ERROR** REQUIRED LENGTH OF C ARRAY (',I6,
     *     ') EXCEEDS SIZE OF ' /
     *  13X,'ARRAY ASSIGNED TO HOLD UPDATED CARRYOVER (',I6,
     *     ') AND/OR' /
     *  13X,'ARRAY ASSIGNED TO HOLD OLD CARRYOVER (',I6,').')
         CALL ERROR
C
C  SET VALUES IN COMMON FCSGNN FROM VALUES IN COMMON FLARYS
230   JND=LD
      JNC=LC
      JNP=LP
      JNT=LT
      JNTS=LTS
C
C  CREATION DATE OF NEW SEGMENT
      DO 240 I=1,5
         JCRDTE(I)=NOW(I)
240      CONTINUE
C
      IF (NERRS.GT.0) GO TO 250
C
C  DETERMINE NUMBER OF CARRYOVER OPERATIONS
      CALL FMCOPS (JNCOPS,RESETC,JNC)
C
C  AT THIS POINT, ALL VARIABLES IN COMMON FCSGNN ARE DEFINED FOR
C  THE NEW SEGMENT EXCEPT JRSEG, JPREC, JWOCRY, JFGID AND JCGID
      IF (IBUG.EQ.1) CALL FCDMP1 (1,JRSEG)
C
250   IF (NERRS.GT.0) THEN
         WRITE (IPR,260)
260   FORMAT ('0**NOTE** SEGMENT DEFINITION ENDED BECAUSE ERRORS WERE ',
     *  'ENCOUNTERED.')
         CALL FRESTR
         GO TO 10
         ENDIF
C
      IF (INEWSEG.EQ.-1) THEN
         CALL FRESTR
         GO TO 10
         ENDIF
C
      INPLACE=0
C
C  CHECK IF NEW SEGMENT
      IF (INEWSEG.EQ.1) THEN
C     SET ESP SEGMENT RECORD NUMBER TO ZERO
         JEREC=0
         GO TO 470
         ENDIF
C
C  GET OLD SEGMENT DEFINITION
      CALL FGETSG (IDSEGN,IRSEG,MOLDP,OLDP,MOLDT,OLDT,
     *   MOLDTS,OLDTS,1,0,IER)
      IF (IER.NE.0) THEN
         WRITE (IPR,310) JDSEGN
310   FORMAT ('0**ERROR** SEGMENT ',2A4,' COULD NOT BE READ ',
     *   'FROM FILE. SEGMENT REDEFINITION STOPPED.')
         CALL ERROR
         CALL FRESTR
         GO TO 10
         ENDIF
C
C  RESET COMMON FLARYS TO LENGTHS FOR NEW SEGMENT
      LTS=JNTS
      LP=JNP
      LC=JNC
      LT=JNT
      LD=JND
C
C  SET VALUES IN NEW SEGMENT FROM THE OLD VALUES
      IGR=0
      DO 330 I=1,2
         JFGID(I)=IFGID(I)
         IF (IFGID(I).EQ.IBLANK) IGR=IGR+1
         JCGID(I)=ICGID(I)
330      CONTINUE
C
C  SET ESP POINTER TO OLD VALUE
      JEREC=IEREC
C
C  IF SEGMENT IS IN A FGROUP AND TIME SERIES ARE MISSING,
C  THE SEGMENT CANNOT BE REDEFINED
      IF (IGR.EQ.2) GO TO 460
      IF (MSNGTS.LE.0) GO TO 350
         WRITE (IPR,340) JDSEGN,IFGID
340   FORMAT ('0**ERROR** SEGMENT ',2A4,
     * ' IS IN FORECAST GROUP ' ,2A4,
     * ' AND ALL TIME SERIES HAVE NOT BEEN DEFINED FOR THIS SEGMENT.')
         CALL ERROR
         CALL FRESTR
         GO TO 10
C
C  CHECK IF TRYING TO CHANGE CONNECTIVITY OF SEGMENT THAT IS IN A
C  FORECAST GROUP
350   DO 360 I=1,5
         IF (IUPSEG(1,I).NE.JUPSEG(1,I)) GO TO 370
         IF (IUPSEG(2,I).NE.JUPSEG(2,I)) GO TO 370
360      CONTINUE
      IF (IDNSEG(1,1).EQ.JDNSEG(1,1).AND.
     *    IDNSEG(2,1).EQ.JDNSEG(2,1).AND.
     *    IDNSEG(1,2).EQ.JDNSEG(1,2).AND.
     *    IDNSEG(2,2).EQ.JDNSEG(2,2)) GO TO 440
370   WRITE (IPR,380) JDSEGN,IFGID
380   FORMAT ('0**WARNING** SEGMENT ',2A4,
     * ' IS IN FORECAST GROUP ',2A4,
     * ' AND SEGMENT CONNECTIVITY IS BEING CHANGED.')
      WRITE (IPR,400) ((IUPSEG(I,J),I=1,2),J=1,5)
400   FORMAT (13X,'OLD UPSTREAM DEFINITION =',5(1X,2A4))
      WRITE (IPR,410) ((JUPSEG(I,J),I=1,2),J=1,5)
410   FORMAT (13X,'NEW UPSTREAM DEFINITION =',5(1X,2A4))
      WRITE (IPR,420) ((IDNSEG(I,J),I=1,2),J=1,2)
420   FORMAT (13X,'OLD DOWNSTREAM DEFINITION =',2(1X,2A4))
      WRITE (IPR,430) ((JDNSEG(I,J),I=1,2),J=1,2)
430   FORMAT (13X,'NEW DOWNSTREAM DEFINITION =',2(1X,2A4))
      CALL WARN
C
C  CHECK IF SEGMENT IS IN A FORECAST GROUP
440   IF (IFGID(1).EQ.IBLANK.AND.IFGID(2).EQ.IBLANK) GO TO 460
C
C  LOAD FGROUP DEFINITION INTO COMMON FCFGS TO GET THE VALUE OF THE
C  MINIMUM DATA TIME INTERVAL FOR THE FORECAST GROUP
      CALL FGGET (IFGID,IFGREC,IERR)

C  NEW MINDT MUST BE EVENLY DIVISIBLE INTO OR LESS THAN OLD MINDT
      IF (MOD(MINDTF,JMINDT).NE.0) THEN
         WRITE (IPR,450) JDSEGN,JMINDT,IFGID,MINDTF
450   FORMAT ('0**ERROR** MINIMUM TIME STEP FOR SEGMENT ',2A4,
     * ' (',I2,' HRS) IS NOT EVENLY DIVISIBLE INTO OR' /
     *  11X,'IS GREATER THAN THE MINIMUM TIME STEP FOR FORECAST GROUP ',
     *    2A4,' (',I2,' HRS).')
         CALL ERROR
         CALL FRESTR
         GO TO 10
         ENDIF
C
C  CHECK IF SEGMENT CAN BE REDEFINED IN-PLACE
460   IF (NC.NE.JNC) GO TO 480
      IF ((NT+NTS+NP).NE.(JNT+JNTS+JNP)) GO TO 480
      INPLACE=1
      JRSEG=IRSEG
      JPREC=IPREC
      JWOCRY=IWOCRY
      GO TO 480
C
C  SET FORECAST GROUP AND CARRYOVER GROUP TO BLANKS WHEN ADDING
C  A NEW SEGMENT
470   JFGID(1)=IBLANK
      JFGID(2)=IBLANK
      JCGID(1)=IBLANK
      JCGID(2)=IBLANK
C
C  OLD SEGMENT DEFINITION COMPLETE AND CHECKED
480   IF (IBUG.EQ.1) THEN
         WRITE (IODBUG,490) INEWSEG,INPLACE
490   FORMAT (' IN SEGDEF - OLD SEGMENT DEFINITION HAS BEEN CHECKED. ',
     *  'INEWSEG=',I1,' INPLACE=',I1)
         CALL FCDMP1 (1,JRSEG)
         CALL FDMPA ('RSTC',RESETC,JNC)
         CALL FDMPA ('P   ',P,JNP)
         CALL FDMPA ('TS  ',TS,JNTS)
         CALL FDMPT ('T   ',T,JNT)
         IF (INEWSEG.EQ.0) THEN
            CALL FCDMP1 (0,IRSEG)
            CALL FDMPA ('OLDC',OLDC,NC)
            CALL FDMPA ('OLDP',OLDP,NP)
            CALL FDMPA ('OLTS',OLDTS,NTS)
            CALL FDMPT ('T   ',OLDT,NT)
            ENDIF
         ENDIF
C
      INDERR=0
C
C  CHECK IF ESP TIME SERIES SPECIFIED
      IF (IESPTS.EQ.1) THEN
C     CHECK IF ESP SEGMENT DEFINED
         IFOUND=0
         ISGREC=2
C     READ FIRST RECORD FOR EACH SEGMENT
520      CALL UREADT (KEPARM,ISGREC,ESPDAT,IERR)
         IF (IERR.NE.0) THEN
            WRITE (IPR,203) ISGREC,KEPARM
            CALL ERROR
            IER=1
            INDERR=1
            GO TO 560
            ENDIF
         NSREC=ESPDAT(3)
         IF (NSREC.EQ.0) GO TO 530
         CALL UMEMOV (ESPDAT(1),ESEGID,2)
         IF (ESEGID.EQ.SEGID) THEN
            IFOUND=1
            ELSE
               IF (NSREC.LT.NXREC) THEN
                  ISGREC=NSREC
                  GO TO 520
                  ENDIF
            ENDIF
530      WRITE (IPR,535) 'ESP PARAMETER',SEGID
535   FORMAT ('0*** BEGINNING ',A,' FILE UPDATES FOR SEGMENT ',A,'. ',
     *   'ABNORMAL PROGRAM TERMINATION MAY RESULT IN UNUSABLE FILES.')
         NAVAIL=MXREC-NXREC+1
         NWORDS=16+LTSESP+LPESP+LSPESP
         NRECS=NWORDS/LRECL
         IF (NRECS*LRECL.NE.NWORDS) NRECS=NRECS+1
         IF (IFOUND.EQ.0) THEN
            WRITE (IPR,540) SEGID,FILENAME(1:LFILENAME)
540   FORMAT ('0**NOTE** ESP SEGMENT ',A,' NOT FOUND IN FILE ',A,'.')
C        CHECK FOR SPACE IN FILE
            IF (NRECS.GT.NAVAIL) THEN
               WRITE (IPR,580) FILENAME(1:LFILENAME)
               CALL ERROR
               IER=1
               INDERR=1
               GO TO 560
               ENDIF
            ISGREC=NXREC
C        SET NEXT AVAILABLE WRITE LOCATION IN FILE
            NSREC=NXREC+NRECS
            ENDIF
         IF (IFOUND.EQ.1) THEN
            WRITE (IPR,545) SEGID,FILENAME(1:LFILENAME),ISGREC
545   FORMAT ('0**NOTE** ESP SEGMENT ',A,' FOUND IN FILE ',A,
     *   ' AT RECORD ',I5,'.')
            NRECU=NSREC-ISGREC
            IF (NRECS.GT.NRECU) THEN
C           CHECK FOR SPACE IN FILE
               IF (NRECS.GT.NAVAIL) THEN
                  WRITE (IPR,580) FILENAME(1:LFILENAME)
                  CALL ERROR
                  IER=1
                  INDERR=1
                  GO TO 560
                  ENDIF
C           DELETE OLD SEGMENT
               IOPT=0
               IWFGST=0
               CALL EDELSG (IOPT,ISGREC,SEGID,IWFGST)
               IFOUND=-1
               ISGREC=NXREC
C        SET NEXT AVAILABLE WRITE LOCATION IN FILE
               NSREC=NXREC+NRECS
               ENDIF
            ENDIF
C        SET CREATION DATE
            CALL UMEMOV (NOW,IECRDT,5)
            CALL UMEMOV (NOW,IECKDT,5)
C        WRITE SEGMENT TO FILE
            CALL UMEMOV (SEGID,ID,2)
            CALL ESPWTF (ISGREC,TSESP,MTSESP,PESP,MPESP,SPESP,MSPESP,
     *         IERR)
            IF (IERR.NE.0) THEN
               IER=1
               INDERR=1
               GO TO 560
               ENDIF
            STRNG='?'
            IF (IFOUND.EQ.0.OR.IFOUND.EQ.-1) WRITE (IPR,550) SEGID,
     *         ISGREC,FILENAME(1:LFILENAME)
550   FORMAT ('0**NOTE** ESP SEGMENT ',A,' SUCCESSFULLY  WRITTEN TO ',
     *   'RECORD ',I5,' IN FILE ',A,'.')
            IF (IFOUND.EQ.1) WRITE (IPR,553) SEGID,
     *         FILENAME(1:LFILENAME),ISGREC
553   FORMAT ('0**NOTE** ESP SEGMENT ',A,' FOUND IN FILE ',A,
     *   ' AT RECORD ',I5,' SUCCESSFULLY UPDATED.')
C        SET NEXT AVAILABLE WRITE LOCATION
            IF (NSREC.GT.NXREC) THEN
               NXREC=NSREC
               ESPDAT(1)=MXREC+.01
               ESPDAT(2)=NXREC+.01
               ESPDAT(3)=LRECL+.01
               IREC=1
               CALL UWRITT (KEPARM,IREC,ESPDAT,IERR)
               IF (IERR.NE.0) THEN
                  IER=1
                  INDERR=1
                  GO TO 560
                  ENDIF
               WRITE (IPR,555) IREC,FILENAME(1:LFILENAME),NXREC
555   FORMAT ('0**NOTE** NEXT AVAILABLE WRITE LOCATION IN RECORD ',I2,
     *   ' IN FILE ',A,' SUCCESSFULLY UPDATED TO ',I5,'.')
               ENDIF
            IEREC=ISGREC
            JEREC=ISGREC
            IEUPDT=0
         ENDIF
C
560   IF (INDERR.EQ.1) THEN
         CALL FRESTR
         GO TO 10
         ENDIF
C
      IMSGU=-99
C
C  CHECK IF NEW SEGMENT AND UPDATE IS IN-PLACE
      IF (IBUG.EQ.1) THEN
         WRITE (IODBUG,*) ' INEWSEG=',INEWSEG,' INPLACE=',INPLACE
         ENDIF
      IF (INEWSEG.EQ.1) GO TO 610
      IF (INPLACE.EQ.1) GO TO 610
C
C  SEGMENT EXIST AND THE REDEFINITION CANNOT BE DONE IN-PLACE -
C  CHECK FOR ENOUGH SPACE IN FILES
C
C  CHECK FOR SPACE IN SEGMENT STATUS FILE
      IF (NRSTS.GT.MRSTS) THEN
         WRITE (IPR,580) 'FCSEGSTS'
C jgg corrected the following error message - 1/28/04
580   FORMAT ('0**ERROR** IN FSGDEF - NOT ENOUGH SPACE IN FILE ',A,
     *   ' FOR SEGMENT.')
         CALL ERROR
         IER=1
         INDERR=1
         ENDIF
C
C  CHECK FOR SPACE IN PARAMETER FILE
      NADRCP=(LP+LT+LTS+2+NWRP-1)/NWRP
      IF (NRP+NADRCP.GT.MRP) THEN
         WRITE (IPR,580) 'FCPARAM'
 581   FORMAT ('0**INFO** NRP=',I6,' NADRCP=',I6,' MRP=', I6)
         CALL ERROR
         IER=1
         INDERR=1
         ENDIF
C
C  CHECK FOR SPACE ON CARRYOVER FILE
      MWPS=NWR*NRSLOT
      IF (NWPS+LC+10.GT.MWPS) THEN
         WRITE (IPR,580) 'FCCARRY'
         CALL ERROR
         IER=1
         INDERR=1
         ENDIF
C
      IF (INDERR.EQ.1) THEN
         CALL FRESTR
         GO TO 10
         ENDIF
C
      WRITE (IPR,535) 'FORECAST COMPONENT',SEGID
      IMSGU=0
C
C  SET OLD SEGMENT DEFINITION TO 'OBSOLETE'
      WRITE (IPR,590)
590   FORMAT ('0**NOTE** OLD SEGMENT DEFINITION WILL BE DELETED ',
     *   'BECAUSE REDEFINITION CANNOT BE DONE IN-PLACE.')
      CALL FOBSSG (IDSEGN,IRSEG)
      WRITE (IPR,600)
600   FORMAT (' **NOTE** OLD SEGMENT DEFINITION SUCCESSFULLY DELETED.')
C
C  CHECK FOR FFG PARAMETERS IN PPPDB - DELETE IF NOT NEEDED
610   IF (INEWSEG.EQ.0) CALL DEL32 (OLDP,MOLDP,P,MP)
C
      IF (IMSGU.EQ.-99) THEN
         WRITE (IPR,535) 'FORECAST COMPONENT',SEGID
         IMSGU=-1
         ENDIF
C
C  WRITE SEGMENT DEFINITION TO FILE
      NNCOM=1
      NOPARM=0
      CALL FPUTSG (P,T,TS,INEWSEG,INPLACE,NNCOM,NOPARM,IMSGU,IER)
      IF (IER.NE.0) THEN
         WRITE (IPR,620) JDSEGN
620   FORMAT ('0**ERROR** SEGMENT DEFINITION FOR SEGMENT ',2A4,
     *  ' FAILED DUE TO ERROR RETURN FROM FPUTSG.')
         CALL ERROR
         CALL FRESTR
         GO TO 10
         ENDIF
C
C  SEGMENT NOW ON FILE WITH SKELETON CARRYOVER RECORDS
C
C  CHECK IF ANY OPERATIONS WITH CARRYOVER
      IF (JNCOPS.GT.0) THEN
C     UPDATE ALL CARRYOVER VALUES FOR NEW SEGMENT DEFINITION
         CALL FUPDCO (JNC,C,RESETC,NC,OLDC,JNP,P,NP,OLDP,INEWSEG,
     *      INPLACE)
C     MARK THE SLOTS COMPLETE
         DO 630 I=1,NSLOTS
            JNCSEG(I)=1
630         CONTINUE
         CALL UWRITT (KFSGST,JRSEG,JDSEGN,IERR)
         ENDIF
C
C  CLOSE ALL FILES
      CALL UCLOSL
C
C  SEGMENT SUCCESSFULLY DEFINED
      ICRYR=MOD(NOW(3),100)
      IF (INEWSEG.EQ.1) THEN
         STRNG='DEFINED'
         ELSE
            STRNG='REDEFINED'
         ENDIF
      WRITE (IPR,640) JDSEGN,STRNG(1:LENSTR(STRNG)),
     *   NOW(1),NOW(2),ICRYR,NOW(4),NOW(5)
640   FORMAT ('0**NOTE** SEGMENT ',2A4,' SUCCESSFULLY ',A,' WITH A ',
     *  'DEFINITION DATE OF ',I2.2,'/',I2.2,'/',I2.2,'-',I4.4,'.',I4.4,
     *  '.')
C
C  PRINT SEGMENT DEFINITION
      CALL FCDMP1 (1,JRSEG)
C
C  CHECK IF SEGMENT HAD AN ESP DEFINITION
      IF (IEREC.GT.0.AND.IEUPDT.EQ.1) THEN
         WRITE (IPR,650) SEGID
650   FORMAT ('0**WARNING** ESP SEGMENT DEFINITION EXISTS FOR ',
     * 'SEGMENT ',A,' AND SHOULD ALSO BE UPDATED.')
         CALL WARN
         ENDIF
C
      IF (NERRS+NWARN.GT.0) CALL FRESTR
      GO TO 10
C
660   CALL FSTWHR (OPNOLD,IOLDOP,OPNOLD,IOLDOP)
C
      IF (ITRACE.GE.1) WRITE (IODBUG,*) 'EXIT ',RTNNAM
C
      RETURN
C
      END
