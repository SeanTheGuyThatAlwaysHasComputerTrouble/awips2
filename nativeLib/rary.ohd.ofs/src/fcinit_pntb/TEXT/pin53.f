C MODULE PIN53
C-----------------------------------------------------------------------
C
C@PROCESS LVL(77)
C
      SUBROUTINE PIN53 (P,LEFTP,IUSEP)

C     THIS IS THE INPUT ROUTINE FOR THE SSARR 3-VARIABLE LOOKUP
C     OPERATION.  THIS ROUTINE INPUTS ALL CARDS FOR THE OPERATION
C     AND FILLS THE P ARRAY.

C     THIS ROUTINE ORIGINALLY WRITTEN BY
C        RAY FUKUNAGA - NWRFC                                 AUG 1995

C     ADDED CHECK FOR ASCENDING VALUES OF Z, X1, Y1, X2, Y2, X3, Y3.
C     ADDED CALL ERROR TO STOP DEFINITION IF ERRORS FOUND.
C        TIM SWEENEY, HRL                                     MAR 1999

C     ADDED CAPABILITY TO READ IN TIME SERIES WITH MULTI VALUE DATA
C     TYPES.
C        DARRIN SHARP, RIVERSIDE TECHNOLOGY                   AUG 2007

C     DEFINITION OF VARIABLES
C     IVERSN = I4     VERSION NUMBER OF OPERATION
C     NPTS   = I4     NUMBER OF POINTS IN THE Z SEGMENT ARRAY

C     POSITION     CONTENTS OF P ARRAY
C      1           VERSION NUMBER OF OPERATION
C      2-19        DESCRIPTION - TITLE
C     20           # OF POINTS IN THE P ARRAY

C     21-22      1ST INDEPENDENT VARIABLE (X) TIME SERIES IDENTIFIER
C     23         1ST INDEPENDENT VARIABLE (X) TIME SERIES DATA TYPE CODE
C     24         1ST INDEPENDENT VARIABLE (X) TIME SERIES TIME INTERVAL
C                (DECIMAL PORTION HOLDS MULTIVALUE INDEX WHEN APPLICABLE)

C     25-26      2ND INDEPENDENT VARIABLE (Z) TIME SERIES IDENTIFIER
C     27         2ND INDEPENDENT VARIABLE (Z) TIME SERIES DATA TYPE CODE
C     28         2ND INDEPENDENT VARIABLE (Z) TIME SERIES TIME INTERVAL
C                (DECIMAL PORTION HOLDS MULTIVALUE INDEX WHEN APPLICABLE)

C     29-30      RESULTANT (Y) TIME SERIES IDENTIFIER
C     31         RESULTANT (Y) TIME SERIES DATA TYPE CODE
C     32         RESULTANT (Y) TIME SERIES TIME INTERVAL

C                Z SEGMENTS (Z1,X11,Y11,X12,Y12,Z2,X21,Y21,X22,Y22,ETC)
C     33         THE UNITS THAT THE USER ENTERS THE Z SEGMENT ARRAY
C                'ENGL' OR 'METR' (DEFAULT)
C     34         NUMBER OF POINTS IN THE Z SEGMENT ARRAY
C     35+        Z SEGMENT ARRAY

C     THEREFORE THE NUMBER OF ELEMENTS REQUIRED IN THE P ARRAY IS
C        34 + NUMBER OF POINTS IN THE Z SEGMENT ARRAY

      PARAMETER     (MAXTBL = 700)

      CHARACTER *72 CTITLE
C     CHARACTER LINE FOR ALL PARAMS OF X AND Z TIME SERIES
      CHARACTER *72 XINDEP,ZINDEP
      CHARACTER * 8 C1XTS,C2ZTS,CRYTS
      CHARACTER * 4 C1XCOD,C2ZCOD,CRYCOD,C1XDIM,C2ZDIM,CRYDIM
      CHARACTER * 4 CXMET,CZMET,CRMET,CDIM,CTSCAL
      CHARACTER * 4 CXENG,CUNIT,TEMP2
C     CHARACTER * 4 CZENG,CRENG

C     BLANK AND X AND Z MULTI-VALUE TIME SERIES INDICES
      CHARACTER * 8 BLANK,CXMVIX,CZMVIX
C     CHAR ARRAYS TO HOLD THE X AND Z TIME SERIES PARAMS
      CHARACTER * 1 XIARY(72),ZIARY(72)
C     X AND Z MULTIVALUE INDEX, INT AND REAL
      INTEGER IXIDX,IZIDX
C     NVALS IS THE NUMBER OF VALUES EXPECTED FOR A GIVEN
C     TIME SERIES DATA TYPE - 1 MOST OF THE TIME, BUT
C     A FEW TIME SERIES' CAN HAVE MULTIPLE VALUES
C     PER TIME STEP
      INTEGER NVALS
      REAL RXIDX,RZIDX
      INTEGER I1XINT,I2ZINT

      DIMENSION R1XTS(2),R2ZTS(2),RRYTS(2),RTITLE(18)
      DIMENSION P(*)

C     ***
C     *NOTE AUG 2007* LOOKUP BY DATE HAS BEEN PARTIALLY CODED
C     BUT NOT TURNED ON OR TESTED.
C     ***
C     IS THE LOOKUP3 BASED ON DATE PARAMETER; IF SO, DATELU
C     WILL BE TRUE.
      LOGICAL DATELU

      EQUIVALENCE (C1XTS,R1XTS),(C2ZTS,R2ZTS),(CRYTS,RRYTS)
      EQUIVALENCE (C1XCOD,R1XCOD),(C2ZCOD,R2ZCOD),(CRYCOD,RRYCOD)
      EQUIVALENCE (CTITLE,RTITLE)
      EQUIVALENCE (CUNIT,RUNIT)
C     EQUIVALENCE THE ARRAY AND THE STRING SO THE STRING CAN BE PARSED
      EQUIVALENCE (XINARY,XINDEP)
      EQUIVALENCE (ZINARY,ZINDEP)

C     COMMON BLOCKS

      INCLUDE 'common/fdbug'
      INCLUDE 'common/ionum'
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/pda/users/sharpd/devl/src/fcinit_pntb/savRCS/pin53.f,v $
     . $',                                                             '
     .$Id: pin53.f,v 1.3 2007/06/26 19:55:30 sharpd Exp $
     . $' /
C    ===================================================================
C
      DATA BLANK /8H        /

C     ***
C     *NOTE AUG 2007* LOOKUP BY DATE HAS BEEN PARTIALLY CODED
C     BUT NOT TURNED ON OR TESTED.
C     ***
      DATA DATELU /.FALSE./
C
C
C     CHECK TRACE LEVEL
      CALL FPRBUG('PIN53',1,53,IBUG)

      IF (IBUG.EQ.1) WRITE(IODBUG,500)
 500  FORMAT(1H0,10X,
     +   'DEBUG INPUT ROUTINE FOR SSARR 3-VARIABLE LOOKUP OPERATION')
C        1         2         3         4         5         6         7
C23456789012345678901234567890123456789012345678901234567890123456789012

      IVER = 2
      IUSEP = 0
      NOFILL = 0
      IERROR = 0
      ZP = -999.
      XP = -999.
      YP = -999.

C     READ IN DESCRIPTION
      READ(IN,FMT='(A)',ERR=9891) CTITLE
      IF (IBUG.GE.1) WRITE(IODBUG,801) CTITLE
 801  FORMAT('PIN53: CTITLE: ',A72)

      CXMVIX=BLANK
      CZMVIX=BLANK

C     READ IN 1ST INDEPENDENT VARIABLE (X) TIME SERIES INFORMATION
      READ(IN,FMT='(A)',ERR=9893) XINDEP
C     EXTRACT THE PARAMS FROM THE TIME SERIES
      CALL EXTRTS(XINDEP,XINARY,C1XTS,C1XCOD,I1XINT,CXMVIX)
      IF (IBUG.GE.1) WRITE(IODBUG,802)
     +                  C1XTS,C1XCOD,I1XINT,CXMVIX
 802  FORMAT('PIN53: C1XTS,C1XCOD,I1XINT,CXMVIX: ',A8,1X,A4,1X,I5,1X,A8)

C     ***
C     *NOTE AUG 2007* LOOKUP BY DATE HAS BEEN PARTIALLY CODED
C     BUT NOT TURNED ON OR TESTED.
C     ***
C     CHECK FOR LOOKUP BY DATE
      IF (C1XTS.EQ.'DATE') THEN
         DATELU=.TRUE.
      ELSE
         DATELU=.FALSE.
      ENDIF

C     READ IN 2ND INDEPENDENT VARIABLE (Z) TIME SERIES INFORMATION
      READ(IN,FMT='(A)',ERR=9893) ZINDEP
C     EXTRACT THE PARAMS FROM THE TIME SERIES
      CALL EXTRTS(ZINDEP,ZINARY,C2ZTS,C2ZCOD,I2ZINT,CZMVIX)
      IF (IBUG.GE.1) WRITE(IODBUG,803)
     +                  C2ZTS,C2ZCOD,I2ZINT,CZMVIX
 803  FORMAT('PIN53: C2ZTS,C2ZCOD,I2ZINT,CZMVIX: ',A8,1X,A4,1X,I5,1X,A8)

C     READ IN RESULTANT VARIABLE (Y) TIME SERIES INFORMATION
      READ(IN,*,ERR=9894) CRYTS,CRYCOD,IRYINT
      IF (IBUG.GE.1) WRITE(IODBUG,804)
     +                  CRYTS,CRYCOD,IRYINT
 804  FORMAT('PIN53: CRYTS,CRYCOD,IRYINT: ',A8,1X,A4,I5)

C     ***
C     *NOTE AUG 2007* LOOKUP BY DATE HAS BEEN PARTIALLY CODED
C     BUT NOT TURNED ON OR TESTED.
C     ***
C     CHECK 1ST INDEPENDENT VARIABLE (X) TIME SERIES INFORMATION;
C     SKIP IF DOING A LOOKUP BY DATE
      IF (.NOT.DATELU) THEN
         IF (C1XCOD.EQ.'ROCL') THEN
            NVALS = 7
         ELSE IF (C1XCOD.EQ.'SMZC') THEN
            NVALS = 5
         ELSE
            NVALS = 1
         ENDIF
         CALL CHEKTS (C1XTS,C1XCOD,I1XINT,0,C1XDIM,0,NVALS,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,601) C1XTS,C1XCOD,I1XINT
            CALL ERROR
         ENDIF
      ENDIF

C     CHECK 2ND INDEPENDENT VARIABLE (Z) TIME SERIES INFORMATION
      IF (C2ZCOD.EQ.'ROCL') THEN
         NVALS = 7
      ELSE IF (C2ZCOD.EQ.'SMZC') THEN
         NVALS = 5
      ELSE
         NVALS = 1
      ENDIF
      CALL CHEKTS (C2ZTS,C2ZCOD,I2ZINT,0,C2ZDIM,0,NVALS,IERFLG)
      IF (IERFLG.NE.0) THEN
         WRITE(IPR,601) C2ZTS,C2ZCOD,I2ZINT
         CALL ERROR
      ENDIF

 601        FORMAT(//,10X,'*** ERROR *** ERROR WITH TIME SERIES ',
     +               'INFORMATION',/,
     +                10X,'TIME SERIES: ',2A,I6)

C     SMZC AND ROCL ARE MULTIVALUE TYPES - IF THEIR TYPE IS BLANK,
C     THE MV IDX DEFAULTS TO THE 1ST INDEX (UZTDEF AND TCHANINF,
C     RESPECTIVELY)

      IF ((C1XCOD.EQ.'SMZC').AND.(CXMVIX.EQ.BLANK)) THEN
         CXMVIX='UZTDEF'
      ENDIF

      IF ((C2ZCOD.EQ.'ROCL').AND.(CZMVIX.EQ.BLANK)) THEN
         CZMVIX='TCHANINF'
      ENDIF

C     CHECK FOR CONSISTENCY OF MULTIVALUE (MV) DATA TYPES AGAINST
C     TIME SERIES TYPE - PRINT ERROR AND EXIT IF NOT VALID;
C     MV DATA TYPE MAY BE BLANK FOR NON MV TIME SERIES, BUT
C     MUST HAVE A VALUE OTHERWISE. IF TIME SERIES TYPE IS 'DATE'
C     ALL OTHER PARAMS ARE IGNORED

C     ***
C     *NOTE AUG 2007* LOOKUP BY DATE HAS BEEN PARTIALLY CODED
C     BUT NOT TURNED ON OR TESTED.
C     ***
      IF ((CXMVIX.NE.BLANK).AND.(.NOT.DATELU)) THEN
         CALL CHEKMV(C1XCOD,CXMVIX,IXIDX)
         RXIDX=REAL(IXIDX)
         IF (IXIDX.EQ.0) THEN
C           INVALID TS / MV DATA TYPE PAIR
            WRITE(IPR,610) C1XCOD,CXMVIX
            CALL ERROR
         ELSE IF (IXIDX.EQ.-999) THEN
C           INVALID MV DATA TYPE
            WRITE(IPR,610) C1XCOD,CXMVIX
            CALL ERROR
         ENDIF
      ELSE
C     NOT MULTIVALUE, OR DATE LOOKUP - ZERO OUT INDEX
         IXIDX=0
         RXIDX=0
      ENDIF

      IF (CZMVIX.NE.BLANK) THEN
         CALL CHEKMV(C2ZCOD,CZMVIX,IZIDX)
         RZIDX=REAL(IZIDX)
         IF (IZIDX.EQ.0) THEN
C           INVALID TS / MV DATA TYPE PAIR
            WRITE(IPR,610) C2ZCOD,CZMVIX
            CALL ERROR
         ELSE IF (IZIDX.EQ.-999) THEN
C           INVALID MV DATA TYPE
            WRITE(IPR,610) C2ZCOD,CZMVIX
            CALL ERROR
         ENDIF
      ELSE
C     NOT MULTIVALUE - ZERO OUT INDEX
         IZIDX=0
         RZIDX=0
      ENDIF


 610        FORMAT(//,10X,'*** ERROR *** LOOKUP3 INPUT ERROR',/,
     +            10X,'INVALID TIME SERIES TYPE/',/,
     +            10X,'TIME SERIES DATA TYPE PAIR.',/,
     +            10X,'TIME SERIES TYPE: ',A,/,
     +            10X,'TIME SERIES DATA TYPE: ',A,//)

 630        FORMAT(//,10X,'*** ERROR *** LOOKUP3 INPUT ERROR',/,
     +            10X,'A MULTIVALUE TIME SERIES DATA TYPE',/,
     +            10X,'(CARD 2 OR 3, FIELD 1) HAS BEEN SPECIFIED',/,
     +            10X,'BUT NO MULTIVALUE DATA TYPE',/,
     +            10X,'(CARD 2 OR 3, FIELD 4) HAS BEEN SPECIFIED;',/,
     +            10X,'FIELD 4 IS A REQUIRED PARAMETER IN THIS CASE.',/,
     +            10X,'MULTIVALUE TIME SERIES DATA TYPE: ',A,//)

C     CHECK TIME INTERVALS
      IF (IBUG.GE.1) WRITE(IODBUG,805) I1XINT,I2ZINT
 805  FORMAT('PIN53: I1XINT,I2ZINT: ',2I6)
      IF (I1XINT.NE.I2ZINT) THEN
         WRITE(IPR,6019) I1XINT,I2ZINT
 6019    FORMAT(//,10X,'*** ERROR *** 1ST INDEPENDENT VARIABLE TIME ',
     +                 'SERIES TIME INTERVAL ',I4,' NOT EQUAL TO ',/,
     +                 '              2ND INDEPENDENT VARIABLE TIME ',
     +                 'SERIES TIME INTERVAL ',I4)
         CALL ERROR
      ENDIF

C     CHECK RESULTANT (Y) TIME SERIES INFORMATION
      CALL CHEKTS (CRYTS,CRYCOD,IRYINT,0,CRYDIM,0,1,IERFLG)
      IF (IERFLG.NE.0) THEN
         WRITE(IPR,601) CRYTS,CRYCOD,IRYINT
         CALL ERROR
      ENDIF

C     CHECK TIME INTERVAL
      IF (IBUG.GE.1) WRITE(IODBUG,806) I1XINT,IRYINT
 806  FORMAT('PIN53: I1XINT,IRYINT: ',2I6)
      IF (I1XINT.NE.IRYINT) THEN
         WRITE(IPR,6020) I1XINT,IRYINT
 6020    FORMAT(//,10X,'*** ERROR *** 1ST INDEPENDENT VARIABLE TIME ',
     +                 'SERIES TIME INTERVAL ',I4,' NOT EQUAL TO ',/,
     +                 '              RESULTANT TIME SERIES ',
     +                 'TIME INTERVAL ',I4)
         CALL ERROR
      ENDIF
C
C
C  CHECK SPACE AVAILABLE IN P ARRAY
      NEEDP = 34
      CALL CHECKP (NEEDP,LEFTP,IERFLG)
      IF (IERFLG.EQ.1) NOFILL = 1
C
C     STORE TS INFORMATION AND Z SEGMENT ARRAY IN P ARRAY;
C     THE DECIMAL PORTION OF ELEMENTS 24 AND 28 HOLD THE MULTIVALUE
C     TIME SERIES X AND Z INDICES (RESPECTIVELY). NOTE THAT THIS
C     REQUIRES THAT THERE BE NO MORE THAN 9 VALUES IN A MULTIVALUE
C     SERIES.
C
      IF(NOFILL.EQ.0) THEN
      P(1) = IVER + 0.01
      DO 20 I=1,18
 20   P(I+1) = RTITLE(I)
      P(21) = R1XTS(1)
      P(22) = R1XTS(2)
      P(23) = R1XCOD
      P(24) = REAL(I1XINT+RXIDX/10)
      P(25) = R2ZTS(1)
      P(26) = R2ZTS(2)
      P(27) = R2ZCOD
      P(28) = REAL(I2ZINT+RZIDX/10)
      P(29) = RRYTS(1)
      P(30) = RRYTS(2)
      P(31) = RRYCOD
      P(32) = REAL(IRYINT)
      ENDIF

      IZ = 34
C
C     READ IN UNITS OF TABLE (ENGLISH OR METRIC)
C     IF ENTERED AS ENGLISH, NEED TO CONVERT TO METRIC
      READ(IN,*,ERR=9895) CUNIT
C
      IF (CUNIT.EQ.'ENGL') THEN
         P(33) = RUNIT
         CALL FDCODE (C1XCOD,CXMET,CDIM,IMISS,NVAL,CTSCAL,NADD,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3100) C1XCOD
 3100       FORMAT(//,10X,'*** ERROR *** ERROR IN FDCODE CALL FOR TS ',
     +                    'CODE: ',A)
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,31) C1XCOD,CXMET
 31      FORMAT('PIN53: C1XCOD,CXMET:',A,1X,A)
         CALL FCONVT (CXMET,C1XDIM,CXENG,RXMF,RXCF,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3105) CXMET,C1XDIM
 3105       FORMAT(//,10X,'*** ERROR *** ERROR IN FCONVT CALL FOR ',
     +                    'METRIC UNITS AND DIMENSION: ',A,1X,A)
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,32) CXMET,C1XDIM,RXMF,RXCF
 32      FORMAT('PIN53: CXMET,C1XDIM,RXMF,RXCF: ',A,1X,A,2F10.2)

         CALL FDCODE (C2ZCOD,CZMET,CDIM,IMISS,NVAL,CTSCAL,NADD,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3100) C2ZCOD
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,33) C2ZCOD,CZMET
 33      FORMAT('PIN53: C2ZCOD,CZMET: ',A,1X,A)
         CALL FCONVT (CZMET,C2ZDIM,CZEND,RZMF,RZCF,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3105) CZMET,C2ZDIM
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,34) CZMET,C2ZDIM,RZMF,RZCF
 34      FORMAT('PIN53: CZMET,C2ZDIM,RZMF,RZCF: ',A,1X,A,2F10.2)

         CALL FDCODE (CRYCOD,CRMET,CDIM,IMISS,NVAL,CTSCAL,NADD,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3100) CRYCOD
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,35) CRYCOD,CRMET
 35      FORMAT('PIN53: CRYCOD,CRMET: ',A,1X,A)
         CALL FCONVT (CRMET,CRYDIM,CREND,RRMF,RRCF,IERFLG)
         IF (IERFLG.NE.0) THEN
            WRITE(IPR,3105) CRMET,CRYDIM
            CALL ERROR
            IERROR = 1
         ENDIF
         IF (IBUG.GE.1) WRITE(IODBUG,36) CRMET,CRYDIM,RRMF,RRCF
 36      FORMAT('PIN53: CRMET,CRYDIM,RRMF,RRCF: ',A,1X,A,2F10.2)
         IF (IERROR.EQ.0) GOTO 10001

      ELSE
         CUNIT = 'METR'
         P(33) = RUNIT
      ENDIF
C
C  SET FACTORS FOR METRIC
      RXMF = 1.
      RZMF = 1.
      RRMF = 1.
      RXCF = 0.
      RZCF = 0.
      RRCF = 0.
C
C
10001 READ(IN,*,ERR=9896,END=10009) Z,X1,Y1,X2,Y2,X3,Y3

      IF (IBUG.GE.1) WRITE(IODBUG,1002) Z,X1,Y1,X2,Y2,X3,Y3
 1002 FORMAT('PIN53: Z,X1,Y1,X2,Y2,X3,Y3: ', 7(F10.2,1X))

C           MUST HAVE READ IN AT LEAST Z,X1,Y1
C           IF Z=-999. THEN TERMINATE READ
      IF (Z.LE.-999.) GO TO 10009


      IZ = IZ + 1
      IF (IZ-41.GT.MAXTBL) THEN
        WRITE(IPR,6060) MAXTBL
 6060   FORMAT(//,10X,'*** ERROR *** NUMBER OF TABLE ',
     +        'ENTRIES WILL EXCEED MAX ALLOWED: ',I5,/,
     +        10X,'              TABLE READ ENDED')
        CALL ERROR
        GO TO 10009
      ENDIF
      IF (Z.LE.-999.) THEN
         P(IZ) = Z
      ELSE
         IF (Z.LT.ZP) THEN
            GOTO 9991
         ELSE IF (Z.GT.ZP) THEN
            XP = -999.
            YP = -999.
            ZP = Z
         ELSE
         ENDIF
         P(IZ) = (Z-RZCF)/RZMF
      ENDIF

      IZ = IZ + 1
      IF (X1.LE.-999.) THEN
         P(IZ) = X1
      ELSE
         IF (X1.LT.XP) GOTO 9992
         XP = X1
         P(IZ) = (X1-RXCF)/RXMF
      ENDIF

      IZ = IZ + 1
      IF (Y1.LE.-999.) THEN
         P(IZ) = Y1
      ELSE
         IF (Y1.LT.YP) GOTO 9993
         YP = Y1
         P(IZ) = (Y1-RRCF)/RRMF
      ENDIF

      IZ = IZ + 1
      IF (X2.LE.-999.)  THEN
         P(IZ) = X2
      ELSE
         IF (X2.LT.XP) GOTO 9992
          XP = X2
          P(IZ) = (X2-RXCF)/RXMF
      ENDIF

      IZ = IZ + 1
      IF (Y2.LE.-999.) THEN
         P(IZ) = Y2
      ELSE
         IF (Y2.LT.YP) GOTO 9993
         YP = Y2
         P(IZ) = (Y2-RRCF)/RRMF
      ENDIF

      IZ = IZ + 1
      IF (X3.LE.-999.) THEN
         P(IZ) = X3
      ELSE
         IF (X3.LT.XP) GOTO 9992
         XP = X3
         P(IZ) = (X3-RXCF)/RXMF
      ENDIF

      IZ = IZ + 1
      IF (Y3.LE.-999.) THEN
         P(IZ) = Y3
      ELSE
         IF (Y3.LT.YP) GOTO 9993
         YP = Y3
         P(IZ) = (Y3-RRCF)/RRMF
      ENDIF

      GOTO 10001
10009 CONTINUE

      P(34) = REAL(IZ-34)
      P(20) = REAL(IZ)
      IF (IBUG.GE.1) WRITE(IODBUG,90) P(20),P(34)
 90   FORMAT('PIN53: P(20),P(34) STORED: ',2F5.0)

      NEEDP = IZ
      CALL CHECKP (NEEDP,LEFTP,IERFLG)
      IF (IERFLG.EQ.1) NOFILL = 1
      IUSEP = NEEDP

      GO TO 1000
C
C
 9891 WRITE(IPR,9801)
 9801 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 1 READ: USER SUPPLIED INFORMATION')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 1 READ: USER SUPPLIED INFORMATION
      GO TO 990

 9892 WRITE(IPR,9802)
 9802 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 2 READ: 1ST INDEPENDENT TIME SERIES ',
     +              'INFORMATION')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 2 READ: 1ST INDEPENDENT TIME SERIES INFORMATION
      GO TO 990

 9893 WRITE(IPR,9803)
 9803 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 3 READ: 2ND INDEPENDENT TIME SERIES ',
     +              'INFORMATION')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 3 READ: 2ND INDEPENDENT TIME SERIES INFORMATION
      GO TO 990

 9894 WRITE(IPR,9804)
 9804 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 4 READ: RESULTANT DEPENDENT TIME ',
     +              'SERIES INFORMATION')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 4 READ: RESULTANT DEPENDENT TIME SERIES INFORMATION
      GO TO 990

 9895 WRITE(IPR,9805)
 9805 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 5 READ: UNITS OF TABLE')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 5 READ: UNITS OF TABLE
      GO TO 990

 9896 WRITE(IPR,9806)
 9806 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'CARD 6 READ: 1ST, 2ND INDEPENDENT AND ',
     +              'DEPENDENT TABLE ')
C        *** LOOKUP3 INPUT ERROR ***
C        CARD 6 READ: 1ST, 2ND INDEPENDENT AND DEPENDENT TABLE
      GOTO 990
C
C
 9991 WRITE(IPR,9901)
 9901 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'2ND INDEPENDENT VARIABLE VALUES NOT INCREASING')
      GOTO 990
C
 9992 WRITE(IPR,9902)
 9902 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'1ST INDEPENDENT VARIABLE VALUES NOT INCREASING')
      GOTO 990
C
 9993 WRITE(IPR,9903)
 9903 FORMAT(//,10X,'*** LOOKUP3 INPUT ERROR ***',/,
     +          10X,'RESULTANT VARIABLE VALUES NOT INCREASING')
C
C
 990  CALL ERROR

1000  IF (ITRACE.GE.1) WRITE(IODBUG,999)
 999  FORMAT('PIN53 (SSARR 3-VARIABLE LOOKUP) EXITED')

      RETURN
      END
