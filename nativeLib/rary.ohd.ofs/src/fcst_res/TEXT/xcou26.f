C MODULE XCOU26
C
C DESC PERFORM CARRYOVER UPDATING AND POSSIBLE SAVING AT END OF EACH
C DESC  TIME PERIOD.
C
C-------------------------------------------------------------------
      SUBROUTINE XCOU26(PO,W,D,LOCWS,LOCOWS,IDPT)
C--------------------------------------------------------------------
C  SUBROUTINE TO PERFORM CARRYOVER UPDATING AT THE END OF EACH TIME
C  STEP WITHIN THE RUN. TWO ACTIVITIES OCCUR:
C
C   1) CARRYOVER MUST BE UPDATED WITH DEFAULT VALUES PLACED IN THE
C      WORK ARRAY FOR THOSE SCHEMES NOT EXECUTED WITHIN THE TIME PERIOD.
C      IF THE SCHEME WAS EXECUTED, VALID VALUES OF CARRYOVER WERE
C      ALREADY PLACED IN THE WORK ARRAY.
C      TWO EXCEPTIONS TO THAT RULE ARE SAVING CARRYOVER FOR 'RULEADJ'
C      AND 'BACKFLOW' WHICH ARE NOT EXECUTED DURING THE RUN PERIOD (THEY
C      ARE EXECUTED AS PRE-LOOP TASKS). THEIR CARRYOVER MUST BE UPDATED
C      EVERY PERIOD.
C
C   2) CARRYOVER IS PLACED ON THE FILES IF THE CURRENT RUN PERIOD IS
C      A CARRYOVER SAVE DATE.
C
C----------------------------------------------------------------------
C  WRITTEN BY - JOE OSTROWSKI - HRL - AUGUST 1983
C----------------------------------------------------------------------
C
      INCLUDE 'common/resv26'
      INCLUDE 'common/exg26'
      INCLUDE 'common/fprog'
      INCLUDE 'common/genq26'
      INCLUDE 'common/flas26'
      INCLUDE 'common/rulc26'
      INCLUDE 'common/fdbug'
      INCLUDE 'common/dste26'
      INCLUDE 'common/xco26'
      INCLUDE 'common/fcary'
      INCLUDE 'common/fctime'
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
      INCLUDE 'common/mod126'
C  END OF CHANGE OF 10/11/89
      COMMON/FATLGK/IATL,C1,C2
      COMMON/RESLAG/IGAGE,TLAG(2)
C
      DIMENSION PO(1),W(1),D(1),LOCWS(*),LOCOWS(*),IDPT(1)
      DIMENSION QOUTX(124),RCCO(4),TIMLAG(2),ITRIB(2)
C
      LOGICAL FOP7
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_res/RCS/xcou26.f,v $
     . $',                                                             '
     .$Id: xcou26.f,v 1.10 2004/04/21 13:54:48 gzhou Exp $
     . $' /
C    ===================================================================
C
      DATA QME/4HQME /
      DATA BLANK/4H    /
C
      IF (IBUG.GE.1) WRITE(IODBUG,1600)
 1600 FORMAT('   *** ENTER XCOU26 ***')
C
C  SET THE LOCATION IN THE WORK ARRAY FOR DEFAULT INFO. AND CARRYOVER
C  STORAGE.
C
      IOFDFL = LOCWS(5) - 1
      IOFFW  = LOCWS(4) - 1
C
C  TRANSFER THE GENERAL CARRYOVER VALUES FIRST
C
      PREVQ = QO1
      PREVQM = W(IOFFW+3)
      W(IOFFW+1) = QI2
      W(IOFFW+2) = QO2
      W(IOFFW+3) = QOM
      W(IOFFW+4) = ELEV1
      W(IOFFW+5) = ELEV2
      W(IOFFW+6) = S2
      IGAGE = 1
C      MQXQT = .FALSE.
C
C  LOOP THROUGH ALL DEFINED S/U'S TO SEE IF THEY HAVE BEEN EXECUTED OR
C  IF THEY DON'T NEED TO SAVE CARRYOVER.
C
      IF (NSUDEF .EQ. 0) GO TO 1000
      DO 100 I=1,NSUDEF
      LOCSUN = LOCPTR + (I-1)*4 + 1
C
C  GET THE EXECUTION FLAG. IF IT'S = 1, THE S/U HAS BEEN EXECUTED, AND
C  NO DEFAULT CARRYOVER NEEDS TO BE STORED.
C
ccc      CALL XBLV26(PO(LOCSUN),IBASE,LEVEL)
      ISUNUM=PO(LOCSUN)
      IBASE=ISUNUM/10
      LEVEL=ISUNUM-IBASE*10
      LOCEXF = I*3
      IEX = W(LOCEXF)
      IF (IEX.EQ.1 .AND. IBASE.NE.108) GO TO 100
ccc      IF (IEX.EQ.1) GO TO 100
C
C  IF THE S/U HAS NOT BEEN EXECUTED, SEE IF WE NEED TO WORRY ABOUT
C  CARRYOVER FOR THIS S/U. ONLY S/U BASE LEVELS OF 2,3,5,6,8,10,11,12,
C  14 AND 18 NEED TO HAVE DEFAULT CARRYOVER SET.
C  ('ADJUST' UTILITY HAS PRESET CARRYOVER COMPUTED IN ADJUSTMENT
C   ROUTINE AND HELD IN /XCO26/.)
C  ALWAYS EXECUTE S/U 18 TO PICK THE RIGHT CARRYOVER
C
      IF (IBUG.GE.2) WRITE(IODBUG,1610) IBASE,LEVEL
 1610 FORMAT('   ** SETTING DEFAULT CARRYOVER FOR S/U',I3,' LEVEL',I3)
C
C  SET ALL OFFSETS FOR STORING CARRYOVER AND RETRIEVING DATA
C
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      IOFFCO = PO(LOCSUN+3) - 1
C      IOFFT  = IOFFCO + IOFFW
      IOFFCO = PO(LOCSUN+3)
      IOFFT  = IOFFCO + IOFFW - 1
      IF(IOFFCO.LE.1) IOFFCO=0
C  END OF CHANGE OF 10/11/89
      IF (IBUG.GE.2) WRITE(IODBUG,1620) IOFFCO,IOFFT
 1620 FORMAT(' LOCATION IN CO ARRAY = ',I4,'. LOCATION IN W ARRAY = ',
     . I4,'.')
C
      IF(IBASE.LT.150) THEN
         IGOTO=IBASE-100
         GO TO (100,1020,1030,100,1050,1060,100,1080,1090,1100
     .   ,1110,1120,1130,100,100), IGOTO
      ELSE
         IGOTO=IBASE-150
         GO TO (1510,100,100,1540,1550,100,100,100,100,100
     .   ,100,100), IGOTO
      ENDIF
C
C------------------
C  'SETQ' - DEFAULT CARRYOVER NEEDED IS INDICATED BY DEFAULT FLAG.
C           IF THE FLAG =:
C             0 - NO CARRYOVER NEEDS BE SAVED,
C            >0 - THIS NUMBER OF VALUES MUST BE STORED. N-1 OF THEM COME
C                 FROM THE OLD CARRYOVER, AND THE LAST VALUE COMES FROM
C                 THE TIME-SERIES. IF THIS VALUE IS MISSING, USE THE
C                 OLDEST CARRYOVER VALUE.
C
 1020 CONTINUE
      NVAL = W(IOFDFL+I)
      IF (NVAL.EQ.0) GO TO 100
C
C  NEED DELTA-T OF TIME SERIES TO SEE IF WE CAN LOOK FOR A VALUE
C  IN THIS TIME PERIOD.
C
      LOCTS = PO(LOCSUN+2)
      IDTTS = PO(LOCTS+3)
      MULT = IDTTS/MINODT
      IDLOC = NS2/MULT
C
C  MUST ALSO GET POINTER TO DATA IN D ARRAY
C
      LOCDPT = W(LOCEXF-1)
      IOFFTS = IDOFST * 24/IDTTS
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      COLAST = D(IDPT(LOCDPT)+IOFFTS+IDLOC-1) * NTIM24
C      IF (IFMSNG(D(IDPT(LOCDPT)+IOFFTS+IDLOC-1)).EQ.1.OR.MOD(NS2,MULT).
C     . NE.0) COLAST = (W(IOFFT+1))
      CALL FDCODE(PO(LOCTS+2),X,DIM,IX,IX,X,IX,IX)
      IQO=0
      IF(DIM.EQ.DL3T) IQO=1
      COLAST=QO2
C
      IF(IQO.EQ.0) COLAST=QOM
C  END OF CHANGE OF 10/11/89
C
C  NOW SHIFT CARRYOVER DOWNWARD BY ONE POSITION (I.E. - 2 TO 1, 3 TO 2)
C  IF MORE THAN ONE CARRYOVER VALUE IS SAVED.
C
      IF (NVAL.EQ.1) GO TO 127
      DO 125 K=2,NVAL
      IDOWN = K-1
      W(IOFFT+IDOWN) = W(IOFFT+K)
  125 CONTINUE
C
C  NOW SET THE LAST POSITION
C
  127 CONTINUE
      W(IOFFT+NVAL) = COLAST
      GO TO 100
C
C------------------
C  'SETH' - DEFAULT CARRYOVER NEEDED IS INDICATED BY DEFAULT FLAG.
C           IF THE FLAG =:
C             0 - NO CARRYOVER NEEDS BE SAVED,
C            >0 - THIS NUMBER OF VALUES MUST BE STORED. N-1 OF THEM COME
C                 FROM THE OLD CARRYOVER, AND THE LAST VALUE COMES FROM
C                 THE TIME-SERIES. IF THIS VALUE IS MISSING, USE THE
C                 OLDEST CARRYOVER VALUE.
C
 1030 CONTINUE
      NVAL = W(IOFDFL+I)
      IF (NVAL.EQ.0) GO TO 100
C
C  NEED DELTA-T OF TIME SERIES TO SEE IF WE CAN LOOK FOR A VALUE
C  IN THIS TIME PERIOD.
C
      LOCTS = PO(LOCSUN+2)
      IDTTS = PO(LOCTS+3)
      MULT = IDTTS/MINODT
      IDLOC = NS2/MULT
C
C  MUST ALSO GET POINTER TO DATA IN D ARRAY
C
      IOFFTS = IDOFST * 24/IDT
      LOCDPT = W(LOCEXF-1)
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      COLAST = D(IDPT(LOCDPT)+IOFFTS+IDLOC-1)
C      IF (IFMSNG(COLAST).EQ.1.OR.MOD(NS2,MULT).NE.0)
C     . COLAST = (W(IOFFT+1))
      COLAST=H2
C  END OF CHANGE OF 10/11/89
C
C  NOW SHIFT CARRYOVER DOWNWARD BY ONE POSITION (I.E. - 2 TO 1, 3 TO 2)
C  IF MORE THAN ONE CARRYOVER VALUE IS SAVED.
C
      IF (NVAL.EQ.1) GO TO 137
      DO 135 K=2,NVAL
      IDOWN = K-1
      W(IOFFT+IDOWN) = W(IOFFT+K)
  135 CONTINUE
C
C  NOW SET THE LAST POSITION
C
  137 CONTINUE
      W(IOFFT+NVAL) = COLAST
      GO TO 100
C
C-----------------------------------
C  'FILLSPILL' - SET THE CARRYOVER TO THE DEFAULT CONSTANT. IF THIS
C                VALUE IS NEGATIVE, LOOK IN THE TIME SERIES LOCATION
C                FOR A VALUE. IF THIS NOT MISSING, USE IT INSTEAD
C                OF THE CONSTANT VALUE.
C
 1050 CONTINUE
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      W(IOFFT+1) = ABS(W(IOFDFL+I))
C      IF (W(IOFDFL+I) .GE. 0.00 .OR. .NOT.ADJRUN) GO TO 100
C      IOFFTS = IDOFST * NTIM24
C      LOCDPT = W(LOCEXF-1)
C      IF (IFMSNG(D(IDPT(LOCDPT)+IOFFTS+NS2-1)).EQ.0) W(IOFFT+1) =
C     . D(IDPT(LOCDPT)+IOFFTS+NS2-1) * NTIM24
      W(IOFFT+1)=QO2
C  END OF CHANGE OF 10/11/89
C
      GO TO 100
C
C---------------------------------------
C  'SPILLWAY' - THIS SCHEME REQUIRES A POINTER TO ADD'L INFO.
C                THE ADD'L INFO TELLS WHETHER DEFAULT VALUES ARE TO BE
C                PICKED UP FROM TIME SERIES, HOW THE MAX GEN. Q IS TO
C                BE DETERMINED, AND WHAT THE CONSTANT SLUICEWAY Q IS.
C
 1060 CONTINUE
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      LOCSPI = W(IOFDFL+I)
CC
CC  FIRST VALUE IS TIME-SERIES INFO.
CC
CC  SET MISSING FILLER FOR SLUICE Q HERE.
CC
C      SLQ = W(LOCSPI+2)
C      ICOMP = 1
C      ITS = W(LOCSPI)
C      IF (ITS.EQ.0 .OR. .NOT.ADJRUN) GO TO 165
CC
CC  PICK UP TIME-SERIES INFO FOR AT LEAST ONE OF THE VALUES, AND INDICAT
CC  WHETHER THE MISSING DEFAULT SHOULD BE USED.
CC
CC
CC  IF ITS = 1 OR 3, WE NEED TO CHECK TIME SERIES FOR MAX GEN Q.
CC
C      IOFFTS = IDOFST * NTIM24
C      LOCDPT = W(LOCEXF-1)
C      IF (MOD(ITS,2).EQ.0) GO TO 164
CC
C      ICOMP = 0
C      QMX = D(IDPT(LOCDPT)+IOFFTS+NS2-1)
C      IF (IFMSNG(QMX).EQ.1) ICOMP = 1
CC
CC  LOOK TO SEE IF WE HAVE A VALID TIME SERIES VALUE FOR SLUICE Q
CC
C  164 CONTINUE
C      IF (ITS.LT.2) GO TO 165
C      IF (IFMSNG(D(IDPT(LOCDPT+1)+IOFFTS+NS2-1)).EQ.0)
C     .    SLQ = D(IDPT(LOCDPT+1)+IOFFTS+NS2-1)
CC
CC  WE NOW HAVE A VALUE FOR SLUICEQ. SEE IF WE NEED TO COMPUTE A VALUE
CC  FOR THE MAX GEN Q.
CC
C  165 CONTINUE
C      IF (ICOMP.EQ.0) GO TO 168
CC
CC  WE DON'T HAVE A VALUE FROM THE TIME SERIES FOR MAX GEN Q.
CC
C      QMX = W(LOCSPI+1)
C      IF (QMX.GE.0.00) GO TO 168
CC
CC  NEED TO COMPUTE THE MAX GENERATION FROM THE TOTALQ VS. MAXGENQ CURVE
CC
C      CALL XFTQ26(PO(LOCSUN),PO,W,LOCOWS,1)
C      CALL NTER26(QO2,QMX,W(LOCOWS(8)),W(LOCOWS(8)+NSE),NSE,IFLAG,
C     .            0,IBUG)
CC
CC  NOW HAVE BOTH THE SLUICE Q AND MAX GEN Q. THE SUM OF THE TWO CANNOT
CC  EXCEED THE ALREADY COMPUTED TOTAL RELEASE.
CC
C  168 CONTINUE
C      TNSQ = SLQ + QMX
C      IF (TNSQ.GT.QO2) TNSQ = QO2
CC
CC  SET CARRYOVER VALUE
CC
C      W(IOFFT+1) = TNSQ
      W(IOFFT+1)=QO2
C  END OF CHANGE OF 10/11/89
      GO TO 100
C
C------------------------------------
C  'STPOOLQ'
C
 1080 CONTINUE
C
C  ALWAYS EXECUTE S/U 18 TO PICK THE RIGHT CARRYOVER
C  NEED TO UPDATE THE CARRYOVER FOR ALL LAG/K OPERATIONS AND RATING
C  CURVES.
      TTLAG = 0.0
      DELTAT = MINODT
      LOCSTQ = W(IOFDFL+I)
      NGAGES = W(LOCSTQ)
C  IOLDC = 0 -- NEW CARRYOVER ARRAY AFTER SEGMENT REDEFINITION
C  IOLDC = 1 -- USE OLD CARRYOVER ARRAY 11/97
C
      IOLDC=0
      NGAGES = ABS(W(LOCSTQ))
      IOLDC=2-(W(LOCSTQ)-NGAGES)*100
C
C  SET UP TRIBUTARY CONTROL INDICATOR IF USED
C  = 0, D/S FLOW CONDITION CONTROL, =1, TRIBUTARY CONTROL
      ITRIB(1)=0
      ITRIB(2)=0
      IF(NGAGES.GT.2) THEN
         NGAGES=NGAGES/100
         DUM=W(LOCSTQ)-NGAGES*100
         ITRIB(1)=DUM/10
         ITRIB(2)=DUM-ITRIB(1)*10
      ENDIF
C
C  RESET CARRYOVER SAVE INFO TEMPORARILY TO CONTROL EX7.
C  ALSO, SAVE THE TIMING VALUES AS THEY WILL BE RECOMPUTED FOR
C  ROUTING. VALUES WILL BE RESTORED AT END OF SUBROUTINE.
C
      IFILLT = IFILLC
      NCSTOT = NCSTOR
      IFILLC = 1
      NCSTOR = 0
      IDAT = IDA
      LDAT = LDA
      IHRT = IHR
      LHRT = LHR
      IDADTT = IDADAT
C
      LENC = 0
      IFILLC = 1
      LOCCLK = IOFFT + 2
C
C  RESET TIMING INFO TO ROUTE UP TO NEXT PERIOD.
C
      IDA = IDARUN
      IHR = MINODT
      LDA = IDA
      LHR = IHR
      IDADAT = IDA
      LOCIN = LOCOWS(12)
      LOCOUT = LOCIN + NDD*NTIM24
C
      NCLGK=0
      LCLKX=LOCCLK
      DO IG=1,NGAGES
        ISTAGE(IG)=0
        LORC = LOCSTQ+(IG-1)*3+2
        IF (W(LORC).NE.BLANK.OR.W(LORC+1).NE.BLANK) ISTAGE(IG)=1
        LGKX=W(LCLKX)
        LCLKX=LCLKX+LGKX
        NCLGK=NCLGK+LGKX
      ENDDO
C
      DO 1800 IG=1,NGAGES
C
      QADDX = 0.0
      IGAGE = IG
      LOCLAG = W(LOCSTQ+(IG-1)*3+1)
      NLAGK = PO(LOCLAG)
      LOCLAG = LOCLAG + 1
C
      IF (IG.GE.2) GO TO 183
      QOUTX(1) = PREVQ
      LOCKA = PO(LOCLAG+17) + LOCLAG - 1
      NLGG=PO(LOCLAG+19)
      NLGK=PO(LOCKA+1)
      IF (.NOT.FOP7(PO(LOCKA),PO(LOCKA+1))) GO TO 390
      IF(PO(LOCLAG+3).EQ.QME) QOUTX(1)=PREVQM/NTIM24
 390  QTLX =QOUTX(1)
  183 CONTINUE
      QINX = QTLX
C
C  PERFORM UP TWO TWO LAG/K OPERATIONS PER GAGE.
C
      DO 185 J=1,NLAGK
C
C  DETERMINE NO. OF VALUES USED BY LAG/K IN PO ARRAY
C
      NUMLAG = PO(LOCLAG+15)
      LOCKA = PO(LOCLAG + 17) + LOCLAG - 1
      IATL = 1
      IF(PO(LOCLAG-1 + 11) .GT. 0.0)IATL = 0
      IF (.NOT.FOP7(PO(LOCKA),PO(LOCKA+1)) .OR. IATL.EQ.0) GO TO 186
      NVAL7 = PO(LOCLAG+NUMLAG)
      NVAL27 = PO(LOCLAG+NUMLAG+1+2*NVAL7)
C
      NUMLAG = NUMLAG + 2 + 2*NVAL7 + 2*NVAL27
C
  186 CONTINUE
C
C  SET LOCATION OF CARRYOVER FOR EACH LAG/K OPERATION
C
      LOCCLK = LOCCLK + LENC
      LENC = W(LOCCLK)
C
C  ROUTE OUT ONE PERIOD.
C
      QOUTX(1)=QINX
      IF(NLGG.GT.0 .OR. NLGK.GT.0)
     & CALL EX7(PO(LOCLAG),W(LOCCLK),QINX,QOUTX(1))
      LOCLAG = LOCLAG + NUMLAG
C
C  TRANSFER OUTFLOW VALUES BACK INTO INFLOW AREA IF WE'RE ON THE FIRST
C  GAGE.
C
C
  185 CONTINUE
C
C  ADD LOCAL FLOW AND CONVERT STAGE TO DISCHARGE IF NEEDBE.
C
      TTLAG = TLAG(IG)
      TIMLAG(IG)=TTLAG/MINODT
      NTLAG = TIMLAG(IG)
      LOCADD = LOCIN
      IF (IG.EQ.2) LOCADD = LOCOUT
      LOCTSD = W(LOCEXF-1) + IG - 1
      IOFFTS = IDOFST * NTIM24
      IF (IDPT(LOCTSD).EQ.0) GO TO 188
C
      JQX = NS2+NTLAG-1
      IF(JQX.LT.NUM) GO TO 1515
      IQ2 = IDPT(LOCTSD)+IOFFTS+NUM-1
      IQ1 = IQ2-1
      QADDX = D(IQ2) + (D(IQ2)-D(IQ1))*(JQX-NUM+1)
      IF (QADDX.LE.0.0) QADDX=0.0
      GO TO 1520
 1515 QAX1 = D(IDPT(LOCTSD)+IOFFTS+JQX)
      QAX2 = D(IDPT(LOCTSD)+IOFFTS+JQX+1)
      QADDX = QAX1+(QAX2-QAX1)*(TIMLAG(IG)-NTLAG)
 1520 CONTINUE
      IF(IBUG.LT.2 .OR. NS2.GE.2) GO TO 188
      WRITE(IODBUG,1611) IG
 1611 FORMAT(1X,'LOCAL INFLOW FOR GAGE ',I1,':')
      WRITE(IODBUG,1612) (D(IDPT(LOCTSD)+IOFFTS+IUM-1),IUM=1,NUM)
 1612 FORMAT(1X,8F10.1)
C
  188 CONTINUE
C
C  TRANSFER CARRYOVER TO TEMP ARRAY
C
      LORC = LOCSTQ+(IG-1)*3+2
      IF(IOLDC.EQ.0 .OR. ISTAGE(IG).EQ.1) GO TO 2005
         RCCO(2)=W(LOCIN)
         GO TO 2020
 2005 CONTINUE
      LOCRCO = IOFFT + NCLGK + (IG-1)*4 + 3
      DO 2010 L=1,4
      RCCO(L) = W(LOCRCO+L-1)
 2010 CONTINUE
C
 2020 CONTINUE
      ILAG=TLAG(IG)
C  FRACATION OF LAG ALREADY ACCOUNTED FOR IN LAG/K OPERATION
C      QOUTX(1) = QOUTX(1)+(QOUTX(1)-RCCO(2))*(TLAG(IG)-ILAG)
      QTLX = QOUTX(1)+QADDX
      QLKUP=QTLX
      IF(ITRIB(IG).EQ.1) QLKUP=QADDX
      LQTLX = LOCOWS(12)+(IG-1)*NDD*NTIM24+NS2+NTLAG-1
      W(LQTLX) = QTLX
C      LORC = LOCSTQ+(IG-1)*3+2
      LOCWK1 = LOCOUT + NDD*NTIM24
      LOCWK2 = LOCWK1 + NDD*NTIM24
C
      STGX=0.0
C      IF (W(LORC).EQ.BLANK.AND.W(LORC+1).EQ.BLANK) GO TO 1840
      IF (ISTAGE(IG).EQ.0) GO TO 1840
      CALL FGETRC(W(LORC),IERRC)
      FLSAVE=FRLOOP
      FRLOOP=-999.0
      CALL FSTGQ(W(LORC),2,1,1,DELTAT,QLKUP,STGX,
     .           W(LOCWK1),W(LOCWK2),X,X,X,X,X,X,X,W(LOCRCO),
     .           IDAT,IHRT,IX,IER,0)
      FRLOOP=FLSAVE
      LSTGX = LOCOWS(12) + (IG+5)*NDD*NTIM24+NS2+NTLAG-1
      W(LSTGX) = STGX
      GO TO 1850
 1840 CONTINUE
      IF(IOLDC.EQ.1) THEN
         W(LOCIN)=QLKUP
         GO TO 1850
      ENDIF
      IF(IG.EQ.1) W(LOCRCO-1) = QADDX
      W(LOCRCO) = 0.0
      W(LOCRCO+1) = QLKUP
      W(LOCRCO+2) = QLKUP-RCCO(2)
      W(LOCRCO+3) = 0.0
 1850 IF (IBUG.GE.2) WRITE(IODBUG,1670) IG,QOUTX(1),QADDX,STGX
 1670 FORMAT(5X,'*** ROUTED, LOCAL FLOW, AND STAGE FOR GAGE ',I1,'=',
     &       2F10.1,F10.3)
 1800 CONTINUE
C
C  RESET TIMING VARIABLES TO THEIR INITIAL VALUES
C
      IFILLC = IFILLT
      NCSTOR = NCSTOT
      IDA = IDAT
      IHR = IHRT
      LDA = LDAT
      LHR = LHRT
      IDADAT = IDADTT
      GO TO 100
C
C----------------------------------------------
C  'MINQ' - NO CARRYOVER USED
C  MINQ SCHEME COMPUTATION NEEDED ONLY AT FIRST TIME IS CALLED
C  SET MQXQT TO TRUE FOR SUBSEQUENT CALLS TO SKIP MINQ COMPUTATION
C
 1090 CONTINUE
C      MQXQT = .TRUE.
C
      GO TO 100
C
C----------------------------------------------
C  'MINH' - THREE VALUES ARE NEEDED, THEY'RE ALL GOTTEN FROM TIME SERIES
C
 1100 CONTINUE
      IOFFTS = IDOFST * NTIM24
      LOCDPT = W(LOCEXF-1)
      W(IOFFT+1) = D(IDPT(LOCDPT)+IOFFTS+NS2-1)
C
      IF (NS2.EQ.1) W(IOFFT+3) = W(IOFFT+2)
C
      W(IOFFT+2) = D(IDPT(LOCDPT+1)+IOFFTS+NS2-1)
      IF (NS2.GT.1) W(IOFFT+3) = D(IDPT(LOCDPT+1)+IOFFTS+NS2-2)
C
      GO TO 100
C
C--------------------------------------------
C  'INDSRCHGE' - FIVE VALUES MUST BE FILLED. THE FIRST TWO ARE THE
C                INST. INFLOW AND POOL ELEVATION AT THE BEGINNING
C                OF THE PERIOD, AND THE LAST FIVE ARE SET TO -999.0
C
 1110 CONTINUE
      W(IOFFT+1) = QI1
      W(IOFFT+2) = ELEV1
      DO 212 K=1,5
      W(IOFFT+K+2) = -999.0
  212 CONTINUE
      GO TO 100
C
C-----------------------------------------------
C  'FLASHBDS' - NEED TO SET THE NO. OF LARGE BOARDS DOWN TO ZERO, THE
C               NO. OF SMALL BDS DOWN TO ZERO (IF SMALL BDS ARE USED),
C               AND THE GATE OPENING TO -999.0 (IF A GATE IS USED).
C
C  ALSO NEED TO SET SOME INDICATOR VALUES FOR CURVE GENERATION WITHIN
C  THE FLASHBOARD ROUTINE
C
C
 1120 CONTINUE
      LOCFBD = W(IOFDFL+I)
      IVAL = W(LOCFBD)
      ITS = W(LOCFBD+3)
      W(IOFFT+1) = 0.01
      W(IOFFT+2) = 0.01
      IADD = 2
      IF (IVAL.EQ.0) GO TO 222
C
C  SEE WHAT COMBINATION OF SMALL BDS AND GATES IS.
C
      W(IOFFT+3) = 0.01
      IF (MOD(IVAL,2).EQ.0) W(IOFFT+3) = -999.01
      IADD = IADD + 1
C
      IF (IVAL.LT.3) GO TO 222
      W(IOFFT+4) = -999.0
      W(IOFFT+5) = 0.01
      IADD = IADD + 2
C
C  SET VALUES TO INDICATE TO THE FLASHBOARD ROUTINE THAT CURVES AND
C  OTHER VALUES MUST BE COMPUTED UPON ENTRY INTO FLASHBOARD ROUTINE.
C
  222 CONTINUE
      NLGSOH = -999
      NSMSOH = -999
      NGASOH = -999
      NPOSOH = -999
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
CC
CC  NOW DETERMIN DEFAULT CO VALUE FOR NON-SPILLWAY DISCHARGE
CC
C      SLQ = W(LOCFBD+2)
C      ICOMP = 1
C      IF (ITS.EQ.0 .OR. .NOT.ADJRUN) GO TO 225
CC
CC  HER WE HAVE TIME SERIES GIVING US AT LEAST ONE OF THE NSQ
CC  COMPONENET VALUES.
CC
C      IOFFTS = IDOFST * NTIM24
C      LOCDPT = W(LOCEXF-1)
C      IF (ITS/10 .LT. 1) GO TO 224
CC
CC  HAVE GEN. DISCHARGE TIME SERIES
CC
C      ICOMP = 0
C      QMX = D(IDPT(LOCDPT)+IOFFTS+NS2-1)
C      IF (IFMSNG(QMX) .EQ. 1) ICOMP = 1
CC
CC  LOOK FOR SLUICE DISCHARGE
CC
C  224 CONTINUE
C      IF (MOD(ITS,2) .EQ. 0) GO TO 225
C      IF (IFMSNG(D(IDPT(LOCDPT+1)+IOFFTS+NS2-1)) .EQ. 0)
C     .     SLQ = D(IDPT(LOCDPT+1)+IOFFTS+NS2-1)
CC
CC  SEE IF WE NEED TO COMPUTE A MAX GNENERATION DISCHARGE
CC
C  225 CONTINUE
C      IF (ICOMP .EQ. 0) GO TO 228
CC
CC  DON'T HAVE VALUE FROM TIME-SERIES
CC
C      QMX = W(LOCFBD+1)
C      IF (QMX .GE. 0.00) GO TO 228
CC
CC  NEED TO COMPUTE THE MAX GENERATION FROM THE TOTALQ VS. MAXGENQ CURVE
CC
C      CALL XFTQ26(PO(LOCSUN),PO,W,LOCOWS,1)
C      CALL NTER26(QO2,QMX,W(LOCOWS(8)),W(LOCOWS(8)+NSE),NSE,IFLAG,
C     .            0,IBUG)
CC
CC  NOW HAVE BOTH THE SLUICE Q AND MAX GEN Q. THE SUM OF THE TWO CANNOT
CC  EXCEED THE ALREADY COMPUTED TOTAL RELEASE.
CC
C  228 CONTINUE
C      TNSQ = SLQ + QMX
C      IF (TNSQ.GT.QO2) TNSQ = QO2
CC
CC  SET CARRYOVER VALUE
CC
C      W(IOFFT+IADD+1) = TNSQ
      W(IOFFT+IADD+1) = QO2
C  END OF CHANGE OF 10/11/89
      GO TO 100
C
C--------------------------------------------------------
C  'POWERGEN' - NEED TO UPDATE THE PERIOD MEAN DISCHARGES FOR A FULL DAY
C               AND TO RESET THE FIRST-EXECUTION-FLAG.
C
 1130 CONTINUE
      IF (NTIM24.EQ.1) GO TO 234
      DO 232 K=2,NTIM24
      W(IOFFT+K-1) = W(IOFFT+K)
  232 CONTINUE
  234 CONTINUE
      W(IOFFT+NTIM24) = QOM
C
      IENTER(LEVEL) = -999
      GO TO 100
C
C----------------------------------------------------
C  'RULEADJ' - NEED TO UPDATE VALUES FROM WORKING ARRAYS UNLESS WE'RE
C              NOT FAR ENOUGH INTO THE RUN. THEN WE USE CARRYOVER
C              VALUES.
C
 1510 CONTINUE
C
C  THE NO. OF CONSECUTIVE MISSING VALUES IS ALWAYS THE NS2 VALUE
C  OF THE ARRAY SECTION HOLDING MISSING VALUES.
C
      IOFMSG = LOCOWS(6) - 1
      IOFDEV = LOCOWS(6) + NDD*NTIM24 - 1
      W(IOFFT+1) = W(IOFMSG+NS2)
C
      NCO = NTIMRL - NS2
      IST = 1
C
C  SEE IF WE'RE FAR ENOUGH IN THE RUN TO USE ALL WORKING VALUES.
C
      IF (NCO.LE.0) GO TO 242
C
C  WE NEED TO PICK UP SOME VALUES FROM THE CARRYOVER ARRAY
C
      DO 241 K=1,NCO
      W(IOFFT+K+1) = W(IOFFT+NS2+K+1)
  241 CONTINUE
      IST = NCO + 1
C
C  PICK UP VALUES FROM DEVIATION ARRAY
C
  242 CONTINUE
      DO 243 K=IST,NTIMRL
      W(IOFFT+K+1) = W(IOFDEV+K-NCO)
  243 CONTINUE
C
      GO TO 100
C
C-----------------------------------------------------------------------
C  'ADJUST' CARRYOVER IS UPDATED HERE. VALUES HAVE ALREADY BEEN
C           SET IN ROUTINE XU1726 AND STORED IN VARIABLE ADJCO IN
C           /XCO26/. (THE CARRYOVER FOR 'ADJUST'ING ISN'T CRITICAL FOR
C           ANY SUBSEQUENT EXECUTION OF ANY S/U. IT'S ONLY NECESSARY IF
C           WE'RE SAVING ANY CARRYOVER TO THE FILES. THEREFORE, IF WE
C           JUST SET THE CARRYOVER BLINDLY IN THE WORK ARRAY W, IT WILL
C           ONLY BE TRANSFERRED IF WE'RE ON A CARRYOVER DATE.)
C
 1540 CONTINUE
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C     IF ((LASTCO .EQ. NCSTOR) .OR. (.NOT.ADJRUN)) GO TO 100
      IF (.NOT.ADJRUN) GO TO 100
      EVEN=ICOMB*0.5-ICOMB/2
      IF (EVEN .EQ. 0.0) GO TO 100
      IF(.NOT.M126ON) GO TO 271
      W(IOFFT+1) = 0.01
      W(IOFFT+2) = 0.01
      GO TO 100
  271 CONTINUE
      IPOS = LASTCO + 1
      W(IOFFT+1) = ADJCO(1,IPOS)
      W(IOFFT+2) = ADJCO(2,IPOS)
C
C GZHOU  MODIFICATION FOR BUG R24-2 02/12/2004
C AFTER CARRYOVER UPDATED, SHOULD JUMP OUT OF THE LOOP.
C      GO TO 100
      GO TO 1000
C
C-----------------------------------------------------------------
C  'BACKFLOW' CARRYOVER MUST BE UPDATED HERE. WE NEED TO UPDATE THE
C             END-OF-DAY ELEVATION IF WE'RE AT THE END OF DAY.
C
 1550 CONTINUE
C  THE FOLLOWING CHANGES MADE ON 10/11/89 -- MAINT. #553
C      IF (MOD(NS2,4) .EQ. 0) W(IOFFT+1) = ELEV2
      IF (MOD(NS2,NTIM24) .EQ. 0) W(IOFFT+1) = ELEV2
C  END OF CHANGE OF 10/11/89
      GO TO 100
  100 CONTINUE
C
C
C------------------------------------------------------------------
C  NOW SEE IF WE NEED TO PLACE CARRYOVER ON TO THE FILES
C
C  THIS WILL ONLY HAPPEN IF:
C    1) THIS IS A CARRYOVER SAVE RUN (ISAVCO>0), AND
C    2) WE HAVE NOT USED ALL THE CARRYOVER SAVE DATES, AND
C    3) THIS IS A PERIOD TO SAVE CARRYOVER.
C
 1000 CONTINUE
C
C  IF ADJUSTMENT IS TO BE DONE AND THIS IS NOT ADJUST PART OF RUN,
C  DON'T SAVE CARRYOVER.
C
cew added ".and. mainum .ne. 2" to allow ESP to save
cew carryover for esp verification runs.

      IF (ADJUST .AND. .NOT.ADJRUN .and. mainum .ne. 2) GO TO 9000
C
      IF (ISAVCO.EQ.0) GO TO 9000
      IF (LASTCO.EQ.NCSTOR) GO TO 9000
      IPOS = LASTCO + 1
      IF (ICOPOS(IPOS).NE.NS2) GO TO 9000
C
C  SAVE CARRYOVER, WE'VE PASSED ALL THE TESTS
C
C  ALTERNATIVE WAY TO GET DATES WITHOUT /FCARY/ IS:
C    NPD = NS2 - 1
C    MHR = (MOD(NPD,NTIM24)+1)*MINODT
C    CALL FCWTCO(JULDAY,MHR,W(LOCWS(4)),NUMCOV)
C
      IF (IBUG.GE.2) WRITE(IODBUG,1690) NS2,(W(LOCWS(4)+L-1),L=1,NUMCOV)
 1690 FORMAT('  >>> SAVING CARRYOVER FOR PERIOD NO. ',I3 /
     &,(6F12.3))
      CALL FCWTCO(ICDAY(IPOS),ICHOUR(IPOS),W(LOCWS(4)),NUMCOV)
      LASTCO = LASTCO + 1
C
 9000 CONTINUE
      IF (IBUG.GE.1) WRITE(IODBUG,1699)
 1699 FORMAT('    *** EXIT XCOU26 ***')
      RETURN
      END
