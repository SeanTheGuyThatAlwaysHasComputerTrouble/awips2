C MODULE XS0826
C
      SUBROUTINE XS0826(SUNUM,PO,W,D,LOCWS,LOCOWS,IDPT)
C--------------------------------------------------------------------
C
C  SUBROUTINE TO EXTRACT ALL PARM, TS AND CO INFO FROM THE PO ARRAY
C  FOR USE IN THE COMPUTING ROUTINE FOR THE 'STPOOLQ' SCHEME (SU#8).
C  FLOWS ARE ALSO ROUTED IN THIS ROUTINE TO THE DOWNSTREAM POINT(S)
C  BEFORE THE COMPUTING ROUTINE IS CALLED.
C-------------------------------------------------------------------
C  WRITTEN BY - JOE OSTROWSKI - HRL - SEPT 1983
C-------------------------------------------------------------------
C
      INCLUDE 'common/ionum'
      INCLUDE 'common/fratng'
      INCLUDE 'common/resv26'
      INCLUDE 'common/exg26'
      INCLUDE 'common/fdbug'
      INCLUDE 'common/dste26'
      INCLUDE 'common/fcary'
      INCLUDE 'common/fprog'
      INCLUDE 'common/fctime'
      INCLUDE 'common/rulc26'
      COMMON/FATLGK/IATL,C1,C2
      COMMON/RESLAG/IGAGE,TLAG(2)
C
      DIMENSION W(1),D(1),PO(1),LOCWS(*),LOCOWS(*),IDPT(1),TIME(24),
     .          TIMLAG(2),RCURVE(2,2),ANOVAL(10),RELATN(100),ELVNO(4),
     .          ELRES(20),RELNO(20),DNOVAL(2),NLAGN(2),
     .        NVLAG(2,2),RCCO(4),LOCCOR(2),IDARC(2),IHRRC(2),LOCSTG(2),
     .        LOCWK1(2),LOCWK2(2),QOUTX(124),DSVALU(4),ITRIB(2)
C
      LOGICAL FOP7
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_res/RCS/xs0826.f,v $
     . $',                                                             '
     .$Id: xs0826.f,v 1.8 2002/10/10 17:24:16 wkwock Exp $
     . $' /
C    ===================================================================
C
      DATA QME/4HQME /
      DATA BLANK/4H    /
C
C--------------------------------------------------------------------
C
      IF (IBUG.GE.1) WRITE(IODBUG,1600)
 1600 FORMAT('   *** ENTER XS0826 ***')
C
C-----------------
C  GET SU POINTERS
C
      CALL XPTR26(SUNUM,PO,IORD,IBASE,LEVEL,LOCPM,LOCTS,LOCCO)
C
C  SET EXECUTION FLAG
C
      LOCEX = IORD*3
      W(LOCEX) = 1.01
C
C  SET LOCATION OF POINTER OF FIRST TIME-SERIES FOR THIS SCHEME
C
      LOCTSD = W(LOCEX-1)
      IOFFTS = IDOFST * NTIM24
C
C  SET CARRYOVER LOCATION
C
      IOFFW = LOCWS(4)-1
      IOFFCO = LOCWS(4) + LOCCO - 2
      LOCCLK = IOFFCO + 2
C
C--------------------------------------------------------------
C  NOW START GETTING PARMS. FIRST COUPLE ARE ENTERED ONLY ONCE,
C  EVEN IF THERE ARE TWO GAGES.
C
C  IOLDC = 0 -- NEW CARRYOVER ARRAY AFTER SEGMENT REDEFINITION
C  IOLDC = 1 -- USE OLD CARRYOVER ARRAY FOR SEGDEF BEFORE 11/97
C
      IOLDC=0
CC      IF(PO(LOCPM).GE.1) IOLDC=1
      NGAGES = ABS(PO(LOCPM))
      IOLDC=2-(PO(LOCPM)-NGAGES)*100
C
C  SET UP TRIBUTARY CONTROL INDICATOR IF USED
C  = 0, D/S FLOW CONDITION CONTROL, =1, TRIBUTARY CONTROL
      ITRIB(1)=0
      ITRIB(2)=0        
      IF(NGAGES.GT.2) THEN
         NGAGES=NGAGES/100
         DUM=PO(LOCPM)-NGAGES*100
         ITRIB(1)=DUM/10
         ITRIB(2)=DUM-ITRIB(1)*10
      ENDIF
C
C  GET DIST'N IF THIS IS A DAILY RELEASE SPECIFICATION
C
      IADD = 2
      NQMX24 = PO(LOCPM+1)
      LOCFAC = LOCPM
      IF (NQMX24.EQ.0) GO TO 50
      IADD = 2 + NTIM24
      LOCFAC = LOCPM + 2
C
      DO 30 I=1,NTIM24
      TIME(I) = I*MINODT + 0.01
   30 CONTINUE
C
C  NOW GET PARMS FOR EACH GAGE (A COMPLETE SET FOR EACH GAGE).
C
   50 CONTINUE
      LOCNXT = LOCPM + IADD
      NOREL = 0
      IST = 1
      IRST = 1
      IEND = 0
      LENC = 0
      DELTAT = MINODT
      NELVNO = 0
      MAXREL = 0
      TTLAG = 0.0
      DO I=1,4
         DSVALU(I)=0.0
      ENDDO
C
C  RESET CARRYOVER SAVE INFO TEMPORARILY TO CONTROL EX7 (NO CO IS
C  UPDATED UNTIL AFTER CALL TO EDST26).
C  ALSO, SAVE THE TIMING VALUES AS THEY WILL BE RECOMPUTED FOR
C  ROUTING. VALUES WILL BE RESTORED AT END OF SUBROUTINE.
C
      IFILLT = IFILLC
      NCSTOT = NCSTOR
      IFILLC = 0
      NCSTOR = 0
      IDAT = IDA
      LDAT = LDA
      IHRT = IHR
      LHRT = LHR
      IDADTT = IDADAT
C
      NCLGK=0
      LCLKX=LOCCLK
      DO IG=1,NGAGES
        LGKX=W(LCLKX)
        LCLKX=LCLKX+LGKX
        NCLGK=NCLGK+LGKX
      ENDDO
      DO 5000 IG=1,NGAGES
      ISTAGE(IG) = 0
      QADDX = 0.0
      IGAGE = IG
      TLAG(IGAGE) = 0.0
      RCURVE(1,IG) = PO(LOCNXT+1)
      RCURVE(2,IG) = PO(LOCNXT+2)
cc      IF (IG.EQ.2) GO TO 100
C
C  IF A RATING CURVE HAS BEEN ENTERED, THEN WE NEED TO INDICATE THAT
C  STAGES ARE USED IN THE RELATIONS.
C
      IF (PO(LOCNXT+1).NE.BLANK.OR.PO(LOCNXT+2).NE.BLANK) ISTAGE(IG) = 1
C
C  SET THE NO. OF RELATIONS FOR THIS GAGE.
C
      NRELD = PO(LOCNXT+3)
      LOCNXT = LOCNXT + 3
C
C  FILL IN ALL RELATIONS
C
      DO 150 J=1,NRELD
      LOCNXT = LOCNXT + 1
      NOREL = NOREL + 1
C
C  SET NO OF PAIRS OF VALUES FOR THIS RELATION
C
      ANOVAL(NOREL) = PO(LOCNXT)
      NVAL = ANOVAL(NOREL)
C
C  FILL IN RELATION OF DISCHARGE (OR STAGE) VS. ALLOWED RELEASE
C
      DO 170 K=1,NVAL
      RELATN(IST+K-1) = PO(LOCNXT+K)
  170 CONTINUE
C
      LOCNXT = LOCNXT + NVAL
      IST = IST + NVAL
  150 CONTINUE
C
C
C  GET TABLE OF ELEVATIONS VS. RELATIONS TO USE FOR RISING STAGES (J=1)
C  AND FALLING STAGES (J=2).
C
      DO 250 J=1,2
      LOCNXT = LOCNXT + 1
      NELN = PO(LOCNXT)
C
C  NELN POTENTIALLY WILL ONLY BE ZERO FOR FALLING STAGE REALTION (J=2)
C
      IF (NELN .EQ. 0) GO TO 250
C
      NELVNO = NELVNO + 1
      ELVNO(NELVNO) = PO(LOCNXT)
      DO 200 K=1,NELN
      ELRES(IRST+K-1) = PO(LOCNXT+K)
      RELNO(IRST+K-1) = PO(LOCNXT+NELN+K) + MAXREL
  200 CONTINUE
      IRST = IRST + NELN
      LOCNXT = LOCNXT + NELN*2
  250 CONTINUE
      MAXREL = NOREL
C
C  GET RULE CURVE (IF NEEDED). INFO FOR THE RULE CURVE WILL
C  ACCOMPANY THE FIRST GAGE DEFINITION ONLY.
C
      IADD = 0
      LOCNXT = LOCNXT + 1
      IF (IG .EQ. 2) GO TO 300
      IADD = 1
      NRU = PO(LOCNXT)
      LOCPT = LOCNXT
      IF (PO(LOCNXT).LT.0) LOCPT = -PO(LOCNXT) + IOFPRM
      IF (NRU.EQ.0) GO TO 300
C
      NTIMES = 1
      QLIMRL = 1.0E10
      CALL XFRU26(PO,LOCNXT,W,LOCOWS)
      IF (NRU .GT. 0) IADD = 2*NRU + 2
  300 CONTINUE
      LOCNXT = LOCNXT + IADD
C
C  NOW START GETTING INFO FOR ROUTING OF FLOWS USING THE LAG/K OPERATION
C  THERE CAN POTENTIALLY BE TWO LAG/K OPERATIONS FOR THE FIRST GAGE.
C  THE REASON IS THAT THE RESERVOIR RELEASES ARE MEAN DISCHARGES AND
C  LAG/K CAN ONLY ATTENUATE ('K') MEAN DISCHARGES. IF ANY LAG IS NEEDED
C  FOR THE FIRST GAGE, A SECOND LAG/K OPERATION MUST BE DEFINED.  THE
C  SECOND GAGE WILL USE OUTPUT FROM THE FIRST GAGE FOR ROUTING AND THE
C  FIRST GAGES OUTPUT WILL BE INSTANTANEOUS DISCHARGES, SO BOTH LAG AND
C  K CAN BE PERFORMED ON THESE VALUES.
C
      NLAGK = PO(LOCNXT)
      NLAGN(IG) = NLAGK
C
C  MUST CONVERT MEAN DISCHARGES FROM 'TIMD' UNITS TO CMSD FOR USE BY
C  LAG/K FOR FIRST GAGE ONLY.
C
      IF (IG.GE.2) GO TO 400
      QOUTX(1) = W(LOCWS(4)+1)
      LOCKA = PO(LOCNXT+18) + LOCNXT
      IF (.NOT.FOP7(PO(LOCKA),PO(LOCKA+1))) GO TO 390
      IF(PO(LOCNXT+4).EQ.QME) QOUTX(1)=W(LOCWS(4)+1)/NTIM24
 390  QTLX =QOUTX(1)
C
C  PERFORM ROUTING, DISCHARGE/STAGE CONVERSION (IF NEEDED), AND LOCAL
C  FLOW ADDITION FOR THE CURRENT GAGE DEFINITION.
C
  400 CONTINUE
      QINX = QTLX
      LOCIN = LOCOWS(12)
      LOCOUT= LOCIN + NDD*NTIM24
C
      LOCNXT = LOCNXT + 1
C
C  RESET TIMING INFO TO ROUTE UP TO PERIOD NEEDED TO DETERMINE RELEASE.
C  INITIAL HOURS (IHR) MUST BE ON A 0 TO 23 BASIS, AND THE ENDING HOUR
C  (LHR) MUST BE ON A 1 TO 24 BASIS.
C
      NS1 = NS2 - 1
      IDA = IDARUN + NS1/NTIM24
      IHR = (MOD(NS1,NTIM24))*MINODT
C
      IDARC(IG) = IDA
      IHRRC(IG) = IHR
C
      DNOVAL(IG) = 2
C
C  NEED TO SET THE IHR AS THE FIRST PERIOD OF THE DAY (ALWAYS) SO THAT
C  EX7 ALWAYS LOOKS IN THE FIRST ARRAY LOCATION FOR THE FIRST INFLOW
C  VALUE. SET LDA AND LHR ACCORDING TO HOW MANY PERIODS IN THE FUTURE WE
C  ROUTING OUT TO.
C
      IDA = IDARUN
      IHR = MINODT
      LDA = IDA
      LHR = IHR
      IDADAT = IDA
C
C  TRANSFER OUTFLOW VALUES BACK INTO INFLOW AREA IF WE'RE ON THER FIRST
C  GAGE.
C
      DO 1000 J=1,NLAGK
C
C  DETERMINE NO. OF VALUES USED BY LAG/K IN PO ARRAY
C
      NUMLAG = PO(LOCNXT+15)
      LOCKA = PO(LOCNXT+17) + LOCNXT - 1
      NLGG=PO(LOCNXT+19)
      NLGK=PO(LOCKA+1)
      IATL = 1
      IF(PO(LOCNXT-1 + 11) .GT. 0.0)IATL = 0
      IF (.NOT.FOP7(PO(LOCKA),PO(LOCKA+1)) .OR. IATL.EQ.0) GO TO 500
C
      NVAL7 = PO(LOCNXT+NUMLAG)
      NVAL27 = PO(LOCNXT+NUMLAG+1+2*NVAL7)
C
      NUMLAG = NUMLAG + 2 + 2*NVAL7 + 2*NVAL27
C
  500 CONTINUE
C
C  SET LOCATION OF CARRYOVER FOR THIS LAG/K OPERATION
C
      LOCCLK = LOCCLK + LENC
      LENC = W(LOCCLK)
C
C  ROUTE OUT TO PERIOD IN QUESTION
C
C      IF (IBUG.LT.2 .OR. NLAGK.LE.1) GO TO 510
      IF (IBUG.LT.2) GO TO 510
      IF(NLAGK.LE.1) THEN 
        WRITE(IODBUG,1652)
        GO TO 510
      ENDIF
 1652 FORMAT(/'    *** CALLING EX7 FOR LAG/K OPERATION ***')
      IF(J.EQ.1) WRITE(IODBUG,1650)
 1650 FORMAT(/'    *** CALLING EX7 FOR K OPERATION ***')
      IF(J.EQ.2) WRITE(IODBUG,1651)
 1651 FORMAT(/'    *** CALLING EX7 FOR LAG OPERATION ***')
 510  CONTINUE
      QOUTX(1)=QINX
      IF(NLGG.GT.0 .OR. NLGK.GT.0)
     & CALL EX7(PO(LOCNXT),W(LOCCLK),QINX,QOUTX(1))
C
      LOCNXT = LOCNXT + NUMLAG
      NVLAG(J,IG) = NUMLAG
C
C  TRANSFER OUTFLOW VALUES BACK INTO INFLOW AREA IF WE'RE ON THER FIRST
C  GAGE.
C
      QINX=QOUTX(1)
 1000 CONTINUE

ccc      ibug=2
C
C  ADD ANY LOCAL FLOW HERE BEFORE CONVERTING TO STAGE (BOTH PROCESSES
C  ARE OPTIONAL).
C
      TTLAG = TLAG(IG)
      TIMLAG(IG) = TTLAG/MINODT
      NTLAG = TIMLAG(IG)
      LOCADD = LOCIN
      IF (IG.EQ.2) LOCADD = LOCOUT
      LOCTSD = LOCTSD + IG - 1
      IF (IDPT(LOCTSD).EQ.0) GO TO 2000
C
      JQX = NS2+NTLAG-1
      IF(JQX.LT.NUM) GO TO 1515
      IQ2 = IDPT(LOCTSD)+IOFFTS+NUM-1
      IQ1 = IQ2-1
      QADDX = D(IQ2) + (D(IQ2)-D(IQ1))*(JQX-NUM+1)
      IF (QADDX.LE.0.0) QADDX=0.0
      GO TO 1520
 1515 QAX1 = D(IDPT(LOCTSD)+IOFFTS+JQX)
      QAX2 = D(IDPT(LOCTSD)+IOFFTS+JQX+1)
      QADDX = QAX1+(QAX2-QAX1)*(TIMLAG(IG)-NTLAG)
 1520 CONTINUE
C
C  PICK UP CARRYOVER FOR LOCAL FLOW IF ON FIRST GAGE
C
C
C  CONVERT DISCHARGES TO STAGES IF NEEDED.
C
 2000 CONTINUE
C
C  TRANSFER CARRYOVER TO TEMP ARRAY
C
      IF(IOLDC.EQ.0 .OR. ISTAGE(IG).EQ.1) GO TO 2005
         RCCO(2)=W(LOCIN)
         GO TO 2020
 2005 CONTINUE
      LOCRCO = IOFFCO + NCLGK + (IG-1)*4 + 3
      LOCCOR(IG) = LOCRCO
      DO 2010 L=1,4
      RCCO(L) = W(LOCRCO+L-1)
 2010 CONTINUE
C
 2020 CONTINUE
      ILAG=TLAG(IG)
C  FRACATION OF LAG ALREADY ACCOUNTED FOR IN LAG/K OPERATION
C      QOUTX(1) = QOUTX(1)+(QOUTX(1)-RCCO(2))*(TLAG(IG)-ILAG)
      QTLX = QOUTX(1)+QADDX
      QLKUP=QTLX
      IF(ITRIB(IG).EQ.1) QLKUP=QADDX
C     
C
      LQTLX = LOCOWS(12)+(IG-1)*NDD*NTIM24+NS2+NTLAG-1
      W(LQTLX) = QTLX
C
      LOCSTG(IG) = LOCOWS(12) + (IG+5)*NDD*NTIM24
      LOCWK1(IG) = LOCOUT + NDD*NTIM24
      LOCWK2(IG) = LOCWK1(IG) + NDD*NTIM24
C
      JSUM = (IG-1)*2+1
      DSVALU(JSUM) = RCCO(2)
      DSVALU(JSUM+1) = QLKUP
      STGX=0.0
      IF (ISTAGE(IG).EQ.0) GO TO 4900
      DSVALU(JSUM) = RCCO(1)
C
C  SET NUMBER OF VALUES TO BE CONVERTED
C
      NCONV = 1
C
      CALL FGETRC(RCURVE(1,IG),IERRC)
      IF(MAINUM.EQ.2) GO TO 2015
      IF(IFMSNG(FRLOOP).EQ.1) GO TO 2015
      IF(NS2.NE.1 .OR. IFCST.NE.0) GO TO 2015
      WRITE(IPR,9003) RTCVID
9003  FORMAT(/10X,'*WARNING* LOOP RATING IS NOT CURRENTLY AVAILABLE ',
     & 'IN STPOOLQ SCHEME, SINGLE VALUED RATING IS USED FOR ',2A4)
      CALL WARN
 2015 FLSAVE=FRLOOP
      FRLOOP=-999.0
      CALL FSTGQ(RCURVE(1,IG),2,1,NCONV,DELTAT,QLKUP,
     .           STGX,W(LOCWK1(IG)),W(LOCWK2(IG)),X,X,X,X,X,X,X,
     .           W(LOCRCO),IDARC(IG),IHRRC(IG),IX,IER,0)
      DSVALU(JSUM+1) = STGX
      W(LOCSTG(IG)) = STGX
      FRLOOP=FLSAVE
      LSTGX = LOCOWS(12) + (IG+5)*NDD*NTIM24+NS2+NTLAG-1
      W(LSTGX) = STGX
      GO TO 4950 
 4900 CONTINUE
C IF FLOW CONTROLLED, NO SPACE ARE RESERVED FOR CARRYOVER IN OLD METHOD
      IF(IOLDC.EQ.1) THEN
         W(LOCIN)=QLKUP
         GO TO 4950
      ENDIF
 4950 CONTINUE
      IF(IBUG.LE.1) GO TO 5000
      WRITE(IODBUG,1660) LOCRCO,RCCO
      WRITE(IODBUG,1665) DSVALU
      WRITE(IODBUG,1670) IG,ISTAGE(IG),ITRIB(IG),QOUTX(1),QADDX,
     & STGX,QLKUP
 1660 FORMAT(5X,'LOCRCO: ',I5,5X,'RCCO: ',4F12.2)
 1665 FORMAT(5X,'DSVALU: ',4F12.2)
 1670 FORMAT(5X,'IGAGE=',I2,2X,'ISTAGE=',I2,2X,'ITRIB=',I3,2X,
     & 'ROUTED=',F10.1,2X,'TRIBFLOW=',F10.1,2X,
     & 'STAGE =',F8.3,2X,'FLOW=',F10.1)
 5000 CONTINUE
C
C  NOW CALL THE ROUTINE TO DETERMINE THE MAX. ALLOWABLE DISCHARGE FOR
C  THIS TIME PERIOD.
C
C
C  MUST POSITON POINTER FOR STAGE/DISCHARGE INFO. BEFORE CALL.
C
      CHANGE = W(IOFFW+5)-W(IOFFW+4)
      LOCRUL=LOCOWS(2)
      NRU=PO(LOCPT)
      CALL EDST26(PO,W,LOCOWS
     & ,TIME,PO(LOCFAC),CHANGE,DNOVAL,DSVALU,TIMLAG
     & ,ELVNO,ELRES,RELNO,ANOVAL,RELATN
     & ,W(LOCRUL),PO(LESSTO),PO(LESELV),PO(LOCPT+1),PO(LOCPT+NRU+1))
C
C  UPDATE CARRYOVER
C
C  RESET TIMING VARIABLES TO THEIR INITIAL VALUES
C
      IFILLC = IFILLT
      NCSTOR = NCSTOT
      IDA = IDAT
      IHR = IHRT
      LDA = LDAT
      LHR = LHRT
      IDADAT = IDADTT
C
      IF (IBUG.GE.1) WRITE(IODBUG,1699)
 1699 FORMAT('    *** EXIT XS0826 ***')
C
ccc      ibug=0
      RETURN
      END



