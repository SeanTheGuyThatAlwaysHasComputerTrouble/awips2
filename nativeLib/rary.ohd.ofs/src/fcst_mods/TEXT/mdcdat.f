C MODULE MDCDAT
C-----------------------------------------------------------------------
C
C  THIS ROUTINE DECODES DATES OR RANGES OF DATES ENTERED ON MOD CARDS
C
C     NOTE THAT LOCATION 7 OF THE JDATES ARRAY RETURNS
C       EQUAL TO 0 IF NO HOUR WAS ENTERED ON THE DATE AND
C       EQUAL TO 1 IF AN HOUR WAS ENTERED ON THE DATE
C
      SUBROUTINE MDCDAT (NCARDS,MODCRD,NFLD,
     1 MAXDTS,NDATES,JDATES,IRNGDT,ISTAT)
C
      CHARACTER*48 XCHAR
C
      COMMON/IONUM/IN,IPR,IPU
      INCLUDE 'udatas'
      INCLUDE 'common/fpwarn'
      INCLUDE 'ufreex'
      COMMON/UFREEI/XUFREE(161),IDATBF(80),XUFRE2
      CHARACTER*4 IDATBF
C
      DIMENSION MODCRD(20,NCARDS)
      DIMENSION JDATES(7,MAXDTS),IRNGDT(MAXDTS)
      DIMENSION OLDOPN(2)
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_mods/RCS/mdcdat.f,v $
     . $',                                                             '
     .$Id: mdcdat.f,v 1.2 1998/07/02 20:45:00 page Exp $
     . $' /
C    ===================================================================
C
      DATA IDASH/4H-   /
C
C      
C
      CALL FSTWHR (8HMDCDAT  ,0,OLDOPN,IOLDOP)
C
      IDATS=1
      NDATES=0
C
C     NOW DECODE DATE FIELD(S) AND STORE IN ARRAY JDATES
C
C     ARRAY IRNGDT TELLS WHAT TYPE OF DATE THE CORRESPONDING
C     DATE IN ARRAY JDATES IS
C       IRNGDT=0 - SINGLE DATE ENTERED
C             =1 - STARTING DATE OF A RANGE
C             =2 - ENDING DATE OF A RANGE
C      NOTE THAT IRNGDT VALUES 1 AND 2 MUST COME IN PAIRS
C
10    ISTRT=-3
      LXCHAR=12
CCC      LXCHAR=LEN(XCHAR)/4
      ICKDAT=0
C
      CALL UFIEL2 (NCARDS,MODCRD,NFLD,ISTRT,LEN,ITYPE,NREP,INTGER,REAL,
     1  LXCHAR,XCHAR,LLPAR,LRPAR,LASK,LATSGN,LAMPS,LEQUAL,ISTAT)
C
      IF (ITYPE.EQ.-1) GO TO 150
C
C     NOW SEE IF THIS FIELD IS A SLASH
C
      IF (XCHAR.NE.'/') GO TO 20
C
C   YES IT IS - AT END OF DATES TO BE DECODED
C     SET ISTAT = 2 AND RETURN
C
      ISTAT=2
      GO TO 150
C
C     NO IT IS NOT A SLASH - CHECK FOR SPECIAL DATE CODES
C     THIS IS ILLEGAL FOR DATES ON MOD CARDS
C
20    CALL USCHFL (IASTR,NFLD,LFOUND)
      IF (LFOUND.GT.0) GO TO 30
      CALL USCHFL (IDOLR,NFLD,LFOUND)
      IF (LFOUND.GT.0) GO TO 30
      CALL USCHFL (IPRCNT,NFLD,LFOUND)
      IF (LFOUND.GT.0) GO TO 30
      GO TO 50
C
C     DO NOT DECODE THIS DATE FIELD,
C     PRINT A WARNING, AND LOOK FOR NEXT FIELD
C
30    IF (MODWRN.EQ.1)
     *   WRITE (IPR,40) IASTR,IDOLR,IPRCNT,NFLD,ICDBUF(1:72)
40    FORMAT (1H0,10X,'**WARNING** THERE IS AN ',
     *   A1,', ',A1,' OR ',A1,' IN FIELD ',I2,
     1   'WHICH IS SUPPOSED TO BE A DATE. ',
     2   'DATES WITH THESE CODES ARE NOT ALLOWED ON MOD CARDS. ',
     3   'THE CURRENT MOD CARD IS:' / 11X,A)
      IF (MODWRN.EQ.1) CALL WARN
      GO TO 10
C
C     NOW SEE IF THERE IS A DASH IN THE FIELD
C
50    CALL USCHFL (IDASH,NFLD,LOCDSH)
C
      IF (LOCDSH.EQ.0) GO TO 120
C
C     HAVE A DASH AT LOCATION 'LOCDSH'
C     DECODE TWO DATES AND STORE IN JDATES ARRAY
C     ALSO SET JRNGDT ARRAY TO PROPER VALUES
C
C     CHECK IF THERE IS ROOM IN JDATES AND IRNGDT ARRAYS FOR 2 DATES
C
      IF (IDATS+2.GT.MAXDTS) GO TO 100
C
      LENGTH=LOCDSH-1
      DO 60 I=1,LENGTH
      J=IFSTRT(NFLD)-1+I
60    IDATBF(I)=ICDBUF(J:J)
C
      IDEFLT=1
      CALL HCKDAT (1,LENGTH,JDATES(1,IDATS),IER)
      IF (JDATES(5,IDATS).EQ.-1) IDEFLT=0
      CALL HSETDY (JDATES(1,IDATS))
      JDATES(7,IDATS)=IDEFLT
C
      IF (IER.EQ.0) GO TO 70
C
C     INVALID DATE DECODED
C
      CALL MDTERR (NFLD)
      GO TO 10
C
70    CONTINUE
C
C     HAVE SUCESSFULLY DECODED FIRST DATE OF A RANGE
C     NOW DECODE ENDING DATE OF THE RANGE
C
      LENGTH=IFSTOP(NFLD)-IFSTRT(NFLD)-LOCDSH+1
      DO 80 I=1,LENGTH
      J=IFSTRT(NFLD)+LOCDSH-1+I
80    IDATBF(I)=ICDBUF(J:J)
C
      IDEFLT=1
      CALL HCKDAT (1,LENGTH,JDATES(1,IDATS+1),IER)
      IF (JDATES(5,IDATS+1).EQ.-1) IDEFLT=0
      CALL HSETDY (JDATES(1,IDATS+1))
      JDATES(7,IDATS+1)=IDEFLT
C
      IF (IER.EQ.0) GO TO 90
C
      CALL MDTERR (NFLD)
      GO TO 10
C
90    CONTINUE
C
C     HAVE VALID SECOND DATE OF RANGE
C     NOW SET VALUES OF IRNGDT
C
      IRNGDT(IDATS)=1
      IRNGDT(IDATS+1)=2
      IDATS=IDATS+2
      GO TO 10
C
C     NO ROOM IN JDATES AND IRNGDT ARRAYS
C
100   IDATS=IDATS-1
      IF (MODWRN.EQ.1)
     *   WRITE (IPR,110) IDATS
110   FORMAT (1H0,10X,'**WARNING** NOT ENOUGH ROOM TO HOLD ALL THE ',
     1 'DATES ENTERED.'/11X,'THE FIRST ',I3,' VALID DATES WERE STORED.')
      IF (MODWRN.EQ.1) CALL WARN
      GO TO 150
C
C <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
C
120   CONTINUE
C
C     HAVE JUST ONE DATE (I.E., NO DASH)
C
      IF (IDATS.GT.MAXDTS) GO TO 100
C
      LENGTH=IFSTOP(NFLD)-IFSTRT(NFLD)+1
      DO 130 I=1,LENGTH
      J=IFSTRT(NFLD)-1+I
130   IDATBF(I)=ICDBUF(J:J)
C
      IDEFLT=1
      CALL HCKDAT (1,LENGTH,JDATES(1,IDATS),IER)
      IF (JDATES(5,IDATS).EQ.-1) IDEFLT=0
      CALL HSETDY (JDATES(1,IDATS))
      JDATES(7,IDATS)=IDEFLT
C
      IF (IER.EQ.0) GO TO 140
C
      CALL MDTERR (NFLD)
      GO TO 10
C
C     HAVE VALID DATE - SET VALUE OF IRNGDT
C
140   IRNGDT(IDATS)=0
      IDATS=IDATS+1
      GO TO 10
C
C <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
C
150   NDATES=IDATS-1
      CALL FSTWHR (OLDOPN,IOLDOP,OLDOPN,IOLDOP)
C
      RETURN
C
      END
