C MEMBER PDFTCR
C-----------------------------------------------------------------------
C
      SUBROUTINE PDFTCR (ICMD)
C
C  THIS ROUTINE CREATES OR UPDATES THE DATA/FILE DICTIONARY
C  THAT ASSOCIATES DATA TYPES WITH LOGICAL UNITS.  THE
C  FILE ALSO CONTAINS THE NUMBER OF TIME SERIES OF THIS TYPE
C  TO BE KEPT IN CORE, A POINTER TO THE CORE BUFFER, THE MAX
C  VALUES OF DATA FOR THE TIME SERIES AND THE SMALLEST TIME INTERVAL.
C  IT ALSO CREATES THE ENTRY FOR A FUTUTE TYPE.
C
      CHARACTER*8 XFILE
      CHARACTER*8 XFILES(5)
     *   /'PRDTS1  ','PRDTS2  ','PRDTS3  ','PRDTS4  ','PRDTS5  '/
C
      DIMENSION LSTCMD(1),IDFREC(18)
      DIMENSION IDFFRC(18)
C
      DATA LSTCMD/4HEND /
      DATA NCMD /1/
C
      INCLUDE 'uio'
      INCLUDE 'udebug'
      INCLUDE 'ufreei'
      INCLUDE 'prdcommon/pdatas'
      INCLUDE 'prdcommon/pdftbl'
      INCLUDE 'prdcommon/pmaxdm'
      INCLUDE 'prdcommon/ptsctl'
      INCLUDE 'prdcommon/punits'
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/prdutil/RCS/pdftcr.f,v $
     . $',                                                             '
     .$Id: pdftcr.f,v 1.2 2001/06/13 14:07:34 dws Exp $
     . $' /
C    ===================================================================
C
C
      IF (IPRTR.GT.0) WRITE (IOGDB,490)
C
C  PROCESS COMMAND:
C    ICMD=1 ADD
C    ICMD=2 CHANGE
C    ICMD=3 DELETE
C
      IF (ICMD.LT.1.OR.ICMD.GT.3) GO TO 410
C
C  CHECK IF DELETE
      IF (ICMD.EQ.3) GO TO 340
C
C  READ CARD
10    CALL RCOMND (LSTCMD,NCMD,INDXC)
      CALL WPCARD (IBUF)
      IF (INDXC) 470,20,480
C
20    ISTAT=0
      ISTA=0
C
      IF (ICMD.EQ.2) GO TO 260
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  ADD DATA TYPE
C
C  CHECK NUMBER OF FIELDS ON CARD
      IF (NFIELD.EQ.5.OR.NFIELD.EQ.9) GO TO 30
         WRITE (LP,500)
         GO TO 10
C
30    CALL UMEMST (0,IDFREC,18)
      CALL UMEMST (0,IDFFRC,18)
      IERR=0
      ISTAT=0
      INDXF=0
C
C  GET DATA TYPE
      J=IFSTRT(1)
      N=IFSTOP(1)-J+1
      IF (N.LE.4) GO TO 40
         WRITE (LP,510)
         ISTAT=1
         N=4
C
40    CALL UPACK1 (IBUF(J),IDFREC(1),N)
C
C  CHECK FOR VALID DATA TYPE
      CALL PCKDTC (IDFREC,IFCODE,ISTA)
      IF (ISTA.NE.0) ISTAT=1
C
C  CHECK FILE NAME
      J=IFSTRT(2)
      N=IFSTOP(2)-J+1
      IF (N.GT.8) GO TO 60
      CALL UPACK1 (IBUF(J),XFILE,N)
      DO 50 I=1,NUMFIL
         IF (XFILE.EQ.XFILES(I)) GO TO 70
50       CONTINUE
60    WRITE (LP,520) XFILE
      ISTAT=1
      GO TO 80
C
70    IDFREC(2)=KPRDTU(I)
C
C  GET INCORE NUM, MAXDAYS, SMALLEST TIME INTERVAL FOR REGULAR
80    DO 90 I=3,5
         CALL UINTFX (IDFREC(I),IFSTRT(I),IFSTOP(I),ISTA)
         IF (ISTA.NE.0) ISTAT=1
90       CONTINUE
C
C  COMPUTE LENGTH AND NUM INCORE TO SEE IF ENOUGH ROOM
      IWDS=IDFREC(4)*(24/IDFREC(5))*IDFREC(13)+LENHED+IDFREC(14)
      NEWTOT=IWDS*IDFREC(3)
C
C  FIND TIME SERIES INDEX FOR LOGICAL UNIT
      CALL PGETLU (IDFREC(2),INDXT)
C
C  CHECK TIME INTERVAL
      CALL PCKDLT (IDFREC(5),1,IERR)
      IF (IERR.EQ.0) GO TO 100
         WRITE (LP,690) IDFREC(5)
         ISTAT=1
C
C  CHECK FOR FUTURE TIME SERIES INFORMATION
100   IF (NFIELD.EQ.9) GO TO 110
C
C  IF NO SEPARATE FUTURE TIME SERIES, CHECK MAX DAYS AGAINST MINDAY
      IF (IDFREC(4).GE.MINDAY) GO TO 200
         WRITE (LP,530) IDFREC(4),MINDAY
          ISTAT=1
          GO TO 200
C
C  CHECK FUTURE TYPE
110   IF (IDFREC(11).EQ.0) GO TO 120
         WRITE (LP,540) IDFREC(1)
         ISTAT=1
         GO TO 200
C
120   IF (IFCODE.NE.IBLNK) GO TO 130
         IFCODE=IDFREC(1)
         CALL UMOVEX (1H+,1,IFCODE,2,1)
C
130   WRITE (LP,550) IDFREC(1),IFCODE
      IDFFRC(1)=IFCODE
C
C  CHECK NAME OF FUTURE FILE
      IFIELD=6
      J=IFSTRT(IFIELD)
      N=IFSTOP(IFIELD)-J+1
      IF (N.GT.8) GO TO 150
      CALL UPACK1 (IBUF(J),XFILE,N)
      DO 140 I=1,NUMFIL
         IF (XFILE.EQ.XFILES(I)) GO TO 160
140      CONTINUE
150   WRITE (LP,520) XFILE
      ISTAT=1
      GO TO 170
C
160   IDFFRC(2)=KPRDTU(I)
C
C  GET LOGICAL UNIT
      CALL PGETLU (IDFFRC(2),INDXF)
C
C  GET INCORE NUM, MAXDAYS, SMALLEST TIME INTERVAL FOR REGULAR
170   IFIELD=IFIELD+1
      DO 180 I=3,5
         CALL UINTFX (IDFFRC(I),IFSTRT(IFIELD),IFSTOP(IFIELD),ISTA)
         IF (ISTA.NE.0) ISTAT=1
         IFIELD=IFIELD+1
180      CONTINUE
      IDFFRC(6)=IDFREC(6)
      CALL UMEMOV (IDFREC(11),IDFFRC(11),4)
C
C  COMPUTE NUMBER OF WORDS FOR IN CORE BUFFER
      IWDS=IDFFRC(4)*(24/IDFFRC(5))*IDFFRC(13)+LENHED+IDFFRC(14)
      NEWTOT=NEWTOT+IWDS*IDFFRC(3)
C
C  CHECK TIME INTERVAL
      CALL PCKDLT (IDFFRC(5),1,IERR)
      IF (IERR.EQ.0) GO TO 190
         WRITE (LP,690) IDFFRC(5)
         ISTAT=1
C
C  CHECK THAT TIME INTERVAL OF FUTURE LE TIME INTERVAL OF REGULAR
190   IF (IDFFRC(5).LE.IDFREC(5)) GO TO 200
         WRITE (LP,680)
         ISTAT=1
C
C  CHECK FOR ROOM IN INCORE BUFFER
200   CALL PCKNIC (0,0,NEWTOT)
      IF (ISTAT.EQ.0) GO TO 210
         WRITE (LP,560)
         GO TO 10
C
C  CHECK IF DATA TYPE EXISTS
210   CALL PFDTYP (IDFREC(1),INDXD)
      INDXDD=0
      IF (INDXF.NE.0) CALL PFDTYP (IDFFRC(1),INDXDD)
C
C  CHECK IF TYPE EXISTS
      IF (INDXD.NE.0) GO TO 420
C
C  IF FUTURE IS NOT UNIQUE, CHANGE IT BY MOVING THE +
      IF (INDXDD.EQ.0) GO TO 240
      DO 220 I=1,4
         IDFFRC(1)=IDFREC(1)
         CALL UMOVEX (1H+,1,IDFFRC(1),I,1)
         CALL PFDTYP (IDFFRC(1),INDXDD)
         IF (INDXDD.EQ.0) GO TO 230
220      CONTINUE
      WRITE (LP,570)
      ISTAT=1
      GO TO 480
C
230   WRITE (LP,550) IDFREC(1),IDFFRC(1)
C
C  CHECK IF ENOUGH ROOM (IF FUTURE, NEED 2 SLOTS)
240   J=1
      IF (INDXF.NE.0) J=2
      IF (NUMDTP+J.GT.MAXDTP) GO TO 430
      NINDX=NUMDTP+1
      NINDXF=NINDX+1
      NUMDTP=NUMDTP+J
C
C  UPDATE NUMBER OF DATA TYPES DEFINED
      TSCNTR(4,INDXT)=TSCNTR(4,INDXT)+1
      IF (INDXF.NE.0) TSCNTR(4,INDXF)=TSCNTR(4,INDXF)+1
C
C  SET INDICATOR FOR FUTURE IN REGULAR
      IF (INDXF.EQ.0) GO TO 250
         IDFFRC(7)=-NINDX
         CALL UMEMOV (IDFFRC,DATFIL(1,NINDXF),18)
         IDFREC(7)=NINDXF
C
250   CALL UMEMOV (IDFREC,DATFIL(1,NINDX),18)
      GO TO 10
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  CHANGE TYPE
C
260   IF (NFIELD.EQ.3.OR.NFIELD.EQ.5) GO TO 270
         WRITE (LP,500)
         GO TO 10
C
270   J=IFSTRT(1)
      N=IFSTOP(1)-J+1
      IF (N.LE.4) GO TO 280
      WRITE (LP,510)
      ISTAT=1
      N=4
280   CALL UPACK1 (IBUF(J),ITYPE,N)
      CALL PFDTYP (ITYPE,INDXD)
C
C  CHECK IF TYPE EXISTS
      IF (INDXD.EQ.0) GO TO 440
C
C  GET NUMBER INCORE AND SMALLEST TIME INTERVAL
      CALL UINTFX (NC,IFSTRT(2),IFSTOP(2),ISTA)
      IF (ISTA.NE.0) ISTAT=1
      CALL UINTFX (IDT,IFSTRT(3),IFSTOP(3),ISTA)
      IF (ISTA.NE.0) ISTAT=1
C
C  MAKE SURE TIME INTERVAL ONLY GETTING SMALLER
      IF (IDT.LE.DATFIL(5,INDXD)) GO TO 290
         WRITE (LP,580) DATFIL(5,INDXD)
         ISTAT=1
         GO TO 330
C
C  COMPUTE NUMBER OF WORDS FOR INCORE BUFFER
290   IWDS=DATFIL(4,INDXD)*(24/IDT)*DATFIL(13,INDXD)+LENHED+
     *   DATFIL(14,INDXD)
      NEWTOT=IWDS*NC
C
C  CHECK FOR FUTURE TYPE
      NCF=0
      IDTF=0
      INDXF=DATFIL(7,INDXD)
      IF (INDXF.EQ.0.AND.NFIELD.EQ.5) GO TO 450
      IF (INDXF.NE.0.AND.NFIELD.EQ.3) GO TO 460
      IF (NFIELD.EQ.3) GO TO 310
      CALL UINTFX (NCF,IFSTRT(4),IFSTOP(4),ISTA)
      IF (ISTA.NE.0) ISTAT=1
      CALL UINTFX (IDTF,IFSTRT(5),IFSTOP(5),ISTA)
      IF (ISTA.NE.0) ISTAT=1
      IF (ISTAT.NE.0) GO TO 330
C
C  CHECK FUTURE TIME INTERVAL
      IF (IDTF.LE.DATFIL(5,INDXF)) GO TO 300
         WRITE (LP,580) DATFIL(5,INDXF)
         ISTAT=1
         GO TO 330
C
C  CHECK FOR ROOM IN INCORE BUFFER
300   IWDS=DATFIL(4,INDXF)*(24/IDTF)*DATFIL(13,INDXF)+LENHED+
     *   DATFIL(14,INDXF)
      NEWTOT=NEWTOT+IWDS*NCF
C
310   CALL PCKNIC (INDXD,INDXF,NEWTOT)
      IF (ISTAT.NE.0) GO TO 330
      DATFIL(3,INDXD)=NC
      DATFIL(5,INDXD)=IDT
      IF (INDXF.EQ.0) GO TO 320
         DATFIL(3,INDXF)=NCF
         DATFIL(5,INDXF)=IDTF
C
320   WRITE (LP,590)
      GO TO 10
C
330   WRITE (LP,600)
      GO TO 10
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  DELETE DATA TYPE
C
340   CALL RCOMND (LSTCMD,NCMD,INDXC)
      CALL WPCARD (IBUF)
      IF (INDXC) 470,350,480
C
C  GET DATA TYPE
350   DO 400 I=1,NFIELD
         J=IFSTRT(I)
         CALL UPACK1 (IBUF(J),NAME,4)
         CALL PFDTYP (NAME,INDXD)
         IF (INDXD.NE.0) GO TO 360
C        DATA TYPE NOT FOUND
            WRITE (LP,610) NAME
            GO TO 400
C     CHECK IF ANY TIME SERIES DEFINED
360      IF (DATFIL(15,INDXD).EQ.0) GO TO 370
            WRITE (LP,620) DATFIL(1,INDXD)
            GO TO 400
C     CHECK IF THERE IS A FUTURE TYPE
370      IF (DATFIL(7,INDXD).LE.0) GO TO 390
            INDXDD=DATFIL(7,INDXD)
C        CHECK FOR FUTURES STILL THERE
            IF (DATFIL(8,INDXDD).EQ.0) GO TO 380
               WRITE (LP,620) DATFIL(1,INDXDD)
               GO TO 400
C     DECREMENT NUMBER IN FILE
380      CALL PGETLU (DATFIL(2,INDXDD),IOLD)
         TSCNTR(4,IOLD)=TSCNTR(4,IOLD)-1
         WRITE (LP,630) DATFIL(1,INDXDD)
C     RECOVER THE SPACE
         CALL PMOVDT (INDXDD)
C     CHANGE REGULAR
390      CALL PGETLU (DATFIL(2,INDXD),IOLD)
         TSCNTR(4,IOLD)=TSCNTR(4,IOLD)-1
         WRITE (LP,630) DATFIL(1,INDXD)
C     RECOVER SPACE
         CALL PMOVDT (INDXD)
400      CONTINUE
      GO TO 340
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C ERRORS
C
410   WRITE (LP,640)
      GO TO 480
420   WRITE (LP,650) IDFREC(1)
      GO TO 10
430   WRITE (LP,660) NUMDTP
      GO TO 10
440   WRITE (LP,670) ITYPE
      GO TO 10
450   WRITE (LP,540) ITYPE
      GO TO 10
460   WRITE (LP,700)
      GO TO 10
470   WRITE (LP,710)
C
480   IF (IPRTR.GT.0) WRITE (IOGDB,720)
C
      RETURN
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
490   FORMAT (' *** ENTER PDFTCR')
500   FORMAT ('0**ERROR** INCORRECT NUMBER OF FIELDS ON CARD.')
510   FORMAT ('0**ERROR** DATA TYPE MUST BE 4 CHARACTERS OR LESS.')
520   FORMAT ('0**ERROR** INVALID FILE NAME ',A,'.')
530   FORMAT ('0**ERROR** MAXIMUM DAYS OF DATA',I4,' IS LESS THAN ',
     *   'MINDAY ',I3,'.')
540   FORMAT ('0**ERROR** DATA TYPE ',A4,' CANNOT STORE FUTURE IN ',
     *  'SEPARATE FILE.')
550   FORMAT ('0**NOTE** THE FUTURE DATA TYPE FOR ',A4,' IS ',A4,
     *   '.')
560   FORMAT ('0**ERROR** DATA TYPE NOT ENTERED.')
570   FORMAT ('0**ERROR** CANNOT ASSIGN FUTURE DATA TYPE.')
580   FORMAT ('0**ERROR** SMALLEST TIME INTERVAL CANNOT BE BIGGER ',
     *   I4,'.')
590   FORMAT ('0**NOTE** DATA TYPE SUCCESSFULLY CHANGED.')
600   FORMAT ('0**NOTE** DATA TYPE NOT SUCCESSFULLY CHANGED.')
610   FORMAT ('0**ERROR** DATA TYPE ',A4,' NOT FOUND')
620   FORMAT ('0**ERROR** TYPE ',A4,' CANNOT BE DELETED BECAUSE ',
     *   'THERE ARE TIME SERIES DEFINED.')
630   FORMAT ('0**NOTE** DATA TYPE ',A4,' SUCCESSFULLY DELETED.')
640   FORMAT ('0**ERROR** NO COMMAND. FOUND')
650   FORMAT ('0**WARNING** DATA TYPE ',A4,' ALREADY EXISTS.')
660   FORMAT ('0**ERROR** DATA TYPE INDEX IS FULL AT ',I3,'.')
670   FORMAT ('0**ERROR** DATA TYPE ',A4,' NOT FOUND.')
680   FORMAT ('0**ERROR** FUTURE TIME INTERVAL CANNOT BE GREATER ',
     *   'THAN REGULAR.')
690   FORMAT ('0**ERROR** ',I4,' IS INVALID FOR TIME INTERVAL.')
700   FORMAT ('0**ERROR** MISSING FUTURE TYPE INFORMATION.')
710   FORMAT ('0**ERROR** MISSING END CARD.')
720   FORMAT (' *** EXIT PDFTCR')
C
      END
