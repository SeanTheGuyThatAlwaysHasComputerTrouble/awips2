C MODULE QDSPLY
C-----------------------------------------------------------------------
C
C  ROUTINE QDSPLY DISPLAYS THE RRS DATA FOR A STATION.
C
C  ORIGINALLY CODED BY DEBBIE VAN DEMARK - 3/1/84
C
C-----------------------------------------------------------------------
C
C  INPUT ARGUMENTS:
C       ISTNUM - STATION NUMBER
C        STAID - STATION IDENTIFIER
C         DESC - STATION DESCRIPTION
C        PRINT - OBSERVED DATA PRINT ARRAY
C       IPRINT - OBSERVED DATA PRINT ARRAY PASSED AS AN INTEGER ARRAY
C       NUMHRS - NUMBER OF HOURS IN THE PRINT ARRAY
C        NTYPE - NUMBER OF DATA TYPES TO PRINT THIS TIME
C       NPRTOB - NUMBER OF DATA TYPES TO HAVE OBSERVED DATA PRINTED
C       PRNTOB - DATA TYPES TO HAVE OBSERVED DATA PRINTED
C       NXPTOB - NUMBER OF DATA TYPES NOT TO HAVE OBSERVED DATA PRINTED
C       XPRTOB - DATA TYPES NOT TO HAVE OBSERVED DATA PRINTED
C       MXTYPE - MAX NUMBER OF DATA TYPES THAT CAN FIT IN THE ARRAYS
C        IUDTR - INDICATOR WHETHER ROUTINE UDTRRS HAS BEEN CALLED
C        NUTYPE - NUMBER OF DATA TYPES RETURNED FROM UDTRRS
C         TYPE - ARRAY TO HOLD DATA TYPES
C       IPRTYP - ARRAY TO HOLD DATA PRINT CATEGORIES
C        JMEAN - ARRAY TO HOLD MEAN DATA INDICATORS
C        JMISS - ARRAY TO HOLD MISSING DATA ALLOWED INDICATORS
C       AUNITI - ARRAY TO HOLD DATA INPUT UNITS
C       AUNITO - ARRAY TO HOLD DATA OUTPUT UNITS
C       DISTBR - ARRAY TO HOLD THE DISTRIBUTION INDICATORS
C       LFIELD - ARRAY TO HOLD THE FIELD LENGTH TO BE USED
C                WHEN PRINTING VALUES
C       NUMDEC - ARRAY TO HOLD THE NUMBER OF DECIMAL PLACES TO BE
C                USED WHEN PRINTING VALUES
C       CHKMIN - ARRAY TO HOLD THE MINIMUM VALUES
C       CHKMAX - ARRAY TO HOLD THE MAXIMUM VALUES
C       NUTYPE - NUMBER OF DATA TYPES RETURNED FROM UDTRRS
C
C-----------------------------------------------------------------------
C
      SUBROUTINE QDSPLY (ISTNUM,STAID,ST,DESC,PRINT,IPRINT,
     $ NUMHRS,NTYPE,NPRTOB,PRNTOB,NXPTOB,XPRTOB,MXTYPE,IUDTR,NUTYPE,
     $ TYPE,IPRTYP,JMEAN,JMISS,AUNITI,AUNITO,
     $ DISTRB,LFIELD,NUMDEC,CHKMIN,CHKMAX)
C
      CHARACTER*4 UNITM
      CHARACTER*8 OLDOPN,STAID
      CHARACTER*20 DESC
      CHARACTER*64 PRTDT
      CHARACTER*76 CPRINT
      DIMENSION PRINT(480,1),IPRINT(480,1)
      PARAMETER (MPDTYP=5)
      CHARACTER*4 PDTYP(MPDTYP),UNITS(MPDTYP),UNITIN(MPDTYP)
      DIMENSION IMEAN(MPDTYP),NFIELD(MPDTYP),NDEC(MPDTYP),CONVRT(MPDTYP)
      CHARACTER*4 PRNTOB(1),XPRTOB(1)
      DIMENSION TYPE(1),IPRTYP(1),JMEAN(1),JMISS(1),AUNITI(1),AUNITO(1)
      DIMENSION DISTRB(1),LFIELD(1),NUMDEC(1),CHKMIN(1),CHKMAX(1)
C
      INCLUDE 'common/ionum'
      INCLUDE 'common/fctime'
C  USE INPTZC FROM FCTIM2 FOR TIME ZONE CODE
      INCLUDE 'common/fctim2'
      INCLUDE 'common/pudbug'
      INCLUDE 'common/pptime'
      INCLUDE 'common/qprint'
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_rrs/RCS/qdsply.f,v $
     . $',                                                             '
     .$Id: qdsply.f,v 1.4 1999/07/06 15:54:08 page Exp $
     . $' /
C    ===================================================================
C
C
      IFUT=0
      IDESC=0
C
      IF (IPTRCE.GT.1) WRITE (IOPDBG,200)
C
      IOPNUM=-3
      CALL FSTWHR ('QDSPLY  ',IOPNUM,OLDOPN,IOLDOP)
C
C  CHECK DEBUG CODES
      IBUG=IPBUG('QDSP')
C
      IF (NPRTOB.EQ.0) GO TO 190
C
C  INITIALIZE THE CONVERSION FACTORS TO ONE
      DO 20 I=1,5
         CONVRT(I)=1.0
20       CONTINUE
C      
      NPDTYP=0
      NSUM=NPRTOB+NXPTOB
      DO 30 I=1,NSUM
         IF (PRNTOB(I).EQ.' ') GO TO 30
         NPDTYP=NPDTYP+1
         IF (NPDTYP.GT.MPDTYP) THEN
            WRITE (IPR,205) MPDTYP
            CALL WARN
            GO TO 30
            ENDIF            
         PDTYP(NPDTYP)=PRNTOB(I)
30       CONTINUE
C
C  RESET NPDTYP IF IT IS GRATER THAN THE NUMBER OF TYPES THAT WILL
C  BE PRINTED THIS TIME
      IF (NPDTYP.GT.NTYPE) NPDTYP=NTYPE
C
      IF (IBUG.GT.0) THEN
         WRITE (IOPDBG,230)
         WRITE (IOPDBG,240) (PDTYP(I),I=1,NPDTYP)
         ENDIF
C
C  GET THE INFORMATION FOR DISPLAY
      PRTDT=' '
      DO 110 I=1,NPDTYP
         CALL QDTYPE (PDTYP(I),IUDTR,MXTYPE,TYPE,IPRTYP,JMEAN,JMISS,
     $    AUNITI,AUNITO,DISTRB,LFIELD,NUMDEC,CHKMIN,CHKMAX,
     $    NUTYPE,ITYPE,IMEAN(I),UNITIN(I),UNITOT,NFIELD(I),
     $    NDEC(I),ISTAT)
         IF (ISTAT.NE.0) THEN
            WRITE (IPR,210) PDTYP(I),ISTAT
            CALL WARN
            GO TO 100
            ENDIF
         IF (NFIELD(I).GT.0) GO TO 50
            WRITE (IPR,220) PDTYP(I),NFIELD(I)
            CALL WARN
            GO TO 100 
50       IF (METRIC.EQ.0) THEN
            UNITS(I)=UNITIN(I)
            GO TO 90
            ENDIF
C     GET THE DATA UNITS IN METRIC
         CALL FDCODE (PDTYP(I),UNITM,DIMM,'MSG ',NPDT,TSCALE,NUMADD,
     *      ISTAT)
         IF (ISTAT.NE.0) THEN
            WRITE (IPR,320) PDTYP(I),ISTAT
            CALL WARN
            UNITS(I)=UNITIN(I)
            GO TO 90
            ENDIF
         UNITS(I)=UNITM
C     GET THE CONVERSION FACTORS FROM FCONVT
90       CALL FCONVT (UNITM,DIMM,UNITE,CONVT,ADD,ISTAT)
         IF (ISTAT.NE.0) THEN
            WRITE (IPR,330) UNITM,DIMM,ISTAT
            CALL WARN
            ENDIF
         CONVRT(I)=CONVT
         JCOL=(I-1)*15+1
         PRTDT(JCOL:JCOL+4)=PDTYP(I)
         JCOL=JCOL+4
         PRTDT(JCOL:JCOL)='('
         JCOL=JCOL+1
         PRTDT(JCOL:JCOL+4)=UNITS(I)
         JCOL=JCOL+4
         PRTDT(JCOL:JCOL)=')'
         JCOL=JCOL+2
         PRTDT(JCOL:JCOL+2)='PD'
         GO TO 110
100      PDTYP(I)=' '
110      CONTINUE
C
      IF (IBUG.GT.0) WRITE (IOPDBG,340) (UNITS(I),I=1,NPDTYP)
C
C  GET THE OUTPUT TIME ZONE CODE
      CALL FCTZC (NOUTZ,NOUTDS,OUTZC)
C
      DO 180 J=1,NUMHRS
         CPRINT=' '
         NMEAN=0
         DO 160 I=1,NPDTYP
           IF (IBUG.GT.0.AND.J.EQ.1) WRITE (IOPDBG,280) PDTYP(I),
     $        UNITIN(I),NFIELD(I),NDEC(I),IMEAN(I)
              IF (PDTYP(I).EQ.' ') GO TO 160
              ICOL=I+NMEAN
              IF (IMEAN(I).EQ.3) NMEAN=NMEAN+1
              IF (PRINT(J,ICOL).EQ.-10001.) GO TO 160
            IPT=15*(I-1)+1
C        CONVERT DATA VALUES (DIVIDE BY THE CONVERSION FACTORS 
C        BECAUSE FCONVT GOES FROM METRIC TO ENGLISH)
C        APPLY THE CONVERSION FACTORS
            IF (METRIC.EQ.1) THEN
               PRINT(J,ICOL)=PRINT(J,ICOL)/CONVRT(ICOL-NMEAN)
               ENDIF
            IF (NFIELD(I).LT.15) GO TO 140
            NFIELD(I)=15
140         CALL URELCH (PRINT(J,ICOL),NFIELD(I),CPRINT(IPT:IPT),
     $         NDEC(I),NFILL,IST)
            IF (IST.EQ.0) GO TO 150
               NDEC(I)=-1
               CALL URELCH (PRINT(J,ICOL),NFIELD,CPRINT(IPT:IPT),
     $            NDEC(I),NFILL,IST)
               IF (IST.EQ.0) GO TO 150
               WRITE (IPR,310) PRINT(J,ICOL)
               CALL WARN
150         IF (IMEAN(I).EQ.2) GO TO 160
            IPT=IPT+NFIELD(I)+2
            CALL UINTCH (IPRINT(J,ICOL+1),3,CPRINT(IPT:IPT),NFILL,IST)
            IF (IST.EQ.0) GO TO 160
               CPRINT(IPT:IPT+4)='????'
               WRITE (IPR,350) IPRINT(J,ICOL+1)
            CALL WARN
160         CONTINUE
CCC         DO 170 K=1,19
            IF (CPRINT.EQ.' ') GO TO 170
C        CONVERT FROM INTERNAL TIME TO MMDDYYHH
            ITIME=J+ISTRUN-1
            IDARUN=ITIME/24+1
            IHRRUN=ITIME-IDARUN*24+24
            CALL MDYH2 (IDARUN,IHRRUN,IM,ID,IY,IH,NZXXX,NDXXX,OUTZC)
C        IF FIRST TIME WRITING DATA FOR A STATION PRINT THE
C        DESCRIPTION AND PRINT FUTURE TO INDICATE THE BEGINNING OF 
C        FUTURE DATA
            NTIME=ITIME+NHOPDB
            IF (IBUG.GT.0) WRITE (IOPDBG,300) NTIME,IFPTR
            IF (IDESC.EQ.0.AND.NTIME.GE.IFPTR.AND.IFUT.EQ.0)
     $         WRITE (IPR,250) STAID,OUTZC,PRTDT,
     $         DESC,IM,ID,IY,IH,CPRINT
            IF (IDESC.EQ.0.AND.(IFUT.EQ.1.OR.NTIME.LT.IFPTR))
     $         WRITE (IPR,260) STAID,OUTZC,PRTDT,
     $         DESC,IM,ID,IY,IH,CPRINT
            IF (IDESC.EQ.1.AND.IFUT.EQ.1)
     $         WRITE (IPR,270) IM,ID,IY,IH,CPRINT
            IF (IDESC.EQ.1.AND.IFUT.EQ.0.AND.NTIME.GE.IFPTR)
     $      WRITE (IPR,290) IM,ID,IY,IH,CPRINT
            IF (IDESC.EQ.1.AND.IFUT.EQ.0.AND.NTIME.LT.IFPTR)
     $         WRITE (IPR,270) IM,ID,IY,IH,CPRINT
            IDESC=1
            IF (NTIME.GE.IFPTR) IFUT=1
            GO TO 180
170         CONTINUE
180      CONTINUE
C
190   CALL FSTWHR (OLDOPN,IOLDOP,OLDOPN,IOLDOP)
C
      IF (IPTRCE.GT.1) WRITE (IOPDBG,360)
C      
      RETURN
C
200   FORMAT (' *** ENTER QDSPLY')
205   FORMAT ('0**WARNING** IN QDSPLY - MAXIMUM NUMBER OF DATA TYPES ',
     $ 'THAT CAN BE PROCESSED (',I2,') EXCEEDED.')
210   FORMAT ('0**WARNING** DATA TYPE ',A4,' HAD A STATUS CODE OF ',I3,
     $ ' RETURNED FROM QDTYPE.  THE OBSERVED DATA FOR THIS TYPE',
     $ ' WILL NOT BE PRINTED.')
220   FORMAT ('0**WARNING** DATA TYPE ',A4,' HAS AN INVALID',
     $ ' LENGTH OF',I5,' SO IT WILL NOT HAVE OBSERVED DATA',
     $ ' PRINTED.')
230   FORMAT ('0THE FOLLOWING OBSERVED DATA TYPES WILL BE DISPLAYED:')
240   FORMAT (' ',10(A4,4X))
250   FORMAT ('0',132('-')/'0',3('*'),A,3('*'),' RAW DATA (',A4,')',
     $ 9X,'MO',1X,'DA',1X,'YEAR',1X,'HR',2X,A,/,
     $ 10X,A,1X,'FUTURE',3X,I2,'/',I2,'/',I4,1X,I2,2X,A)
260   FORMAT ('0',132('-')/'0',3('*'),A,3('*'),' RAW DATA (',A4,')',
     $ 9X,'MO',1X,'DA',1X,'YEAR',1X,'HR',2X,A,/,
     $ 10X,A,10X,I2,'/',I2,'/',I4,1X,I2,2X,A)
270   FORMAT (40X,I2,'/',I2,'/',I4,1X,I2,2X,A)
280   FORMAT ('0 THE VALUES RETURNED FROM QDTYPE ARE: PDTYP=',A4,
     $ 'UNITIN=',A4,' NFIELD=',I2,' NDEC=',I2,' IMEAN=',I2)
290   FORMAT (31X,'FUTURE',3X,I2,'/',I2,'/',I4,1X,I2,2X,A)
300   FORMAT ('0NTIME= ',I7,' IFPTR= ',I7)
310   FORMAT ('0**WARNING** THERE WAS AN ERROR IN CONVERTING',
     $ ' THE REAL VALUE ',G15.7,' INTO ITS CHARACTER REPRESENTATION')
320   FORMAT ('0**WARNING** THE DATA TYPE ',A4,' IS NOT A VALID',
     $ ' DATA TYPE.  A STATUS CODE OF ',I3,' WAS RETURNED FROM',
     $ ' ROUTINE FDCODE.')
330   FORMAT ('0**WARNING** A ERROR OCCURED IN ROUTINE FCONVT',
     $ 'WITH UNITM= ',A4,' DIMM= ',A4,' ISTAT= ',I4 /
     $ T17,'A CONVERSION FACTOR OF ONE WAS RETURNED.')
340   FORMAT ('0 THE UNITS ARRAY ',20(A4,2X))
350   FORMAT ('0**WARNING** THERE WAS AN ERROR IN CONVERTING',
     $ ' THE INTEGER VALUE ',I7,' INTO ITS CHARACTER REPRESENTATION')
360   FORMAT (' *** EXIT QDSPLY')
C
      END
