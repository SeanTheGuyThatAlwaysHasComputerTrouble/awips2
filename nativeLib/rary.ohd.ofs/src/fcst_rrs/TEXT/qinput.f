C MODULE QINPUT
C-----------------------------------------------------------------------
C
C  ROUTINE QINPUT OBTAINS RUN TIME OPTIONS SPECIFIED USING THE
C  HYDROLOGIC COMMAND LANGUAGE.
C
C  ORIGINALLY CODED BY DEBBIE VAN DEMARK - 1/5/84
C
C-----------------------------------------------------------------------
C
C  INPUT ARGUMENTS:
C        MAXMOD - MAX MOD CARDS
C        IMGMOD - ARRAY TO HOLD MOD CARDS
C
C  OUTPUT ARGUMENTS:
C        MSTAID - ARRAY CONTAINING THE STATION IDS FROM RRSMSNG MOD
C        MDTYPE - ARRAY CONTAINING THE DATA TYPE CODES FROM MOD
C        MISTRT - ARRAY CONTAINING THE START TIME FROM RRSMSNG MOD
C         MIEND - ARRAY CONTAINING THE END TIME FROM RRSMSNG MOD
C        MSCHAR - NUMBER OF NON BLANK CHARACTERS IN START DATE FIELD
C        MECHAR - NUMBER OF NON BLANK CHARACTERS IN END DATE FIELD
C          NMOD - NUMBER OF MODS RETURNED FROM HMODCK
C          IERR - STATUS CODE
C
C-----------------------------------------------------------------------
C
      SUBROUTINE QINPUT (MAXMOD,IMGMOD,MSTAID,MDTYPE,MISTRT,MIEND,NMOD,
     *   MSCHAR,MECHAR,IERR)
C
      CHARACTER*4 DTYPE
      CHARACTER*8 OLDOPN,STRNG,STAID
      INTEGER*4 PDBUG
      DIMENSION RRSMOD(2)
      CHARACTER IMGMOD(MAXMOD)*80,MSTAID(MAXMOD)*8,MDTYPE(MAXMOD)*4
      CHARACTER MISTRT(MAXMOD)*12,MIEND(MAXMOD)*12
      DIMENSION MSCHAR(MAXMOD),MECHAR(MAXMOD)
      PARAMETER (LIARGS=70)
      DIMENSION IARGS(LIARGS)
C
      INCLUDE 'ufreei'
      INCLUDE 'common/ionum'
      INCLUDE 'common/errdat'
      INCLUDE 'common/sysbug'
      INCLUDE 'common/fdbug'
      INCLUDE 'common/pudbug'
      INCLUDE 'common/fctime'
      INCLUDE 'common/fctim2'
      INCLUDE 'common/qprint'
      INCLUDE 'common/pptime'
      COMMON /HDFLTS/ DX1(2),LINPTZ,DX2(18),LCLHCL,LTZHCL,NPDHCL,NCAHCL
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_rrs/RCS/qinput.f,v $
     . $',                                                             '
     .$Id: qinput.f,v 1.6 2004/12/06 20:52:41 dsa Exp $
     . $' /
C    ===================================================================
C
      DATA IBLNK/4H    /
      DATA LALL/4HALL /
      DATA ISLASH/4H/   /
      DATA IASTR/4H*   /
C
C
      IERR=0
C
      CALL UMEMOV ('RRSMSNG ',RRSMOD,2)
      IPALL=0
      NDBUG=0
      ICARD=0
      DO 10 N=1,MAXMOD
         MECHAR(N)=0
10       CONTINUE
C
      IOPNUM=-3
      CALL FSTWHR ('QINPUT  ',IOPNUM,OLDOPN,IOLDOP)
C
C  ROUTINE FTEKCK CHECKS TO SEE IF THE VALUE OF A TECH IS WITHIN
C  VALID LIMITS AND RETURNS THE VALUE IF IT IS AND A DEFAULT VALUE
C  IF IT IS NOT
C
      IOUNT=0
      IF (IOUNT.EQ.1) THEN
C
C  GET I/O UNIT NUMBERS FOR PRINT, PPRINT AND DEBUG
      CALL HPAST ('PRINT   ',IPR,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'PRINT   ')
      IF (IPR.EQ.6.OR.IPR.EQ.8.OR.IPR.EQ.9) THEN
         ELSE
            IPR=6
            WRITE (IPR,180) 'PRINT',IPR
            CALL WARN
         ENDIF
      CALL HPAST ('PPPRINT ',IPPPR,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'PPPRINT ')
      IF (IPPPR.EQ.6.OR.IPPPR.EQ.8.OR.IPPPR.EQ.9) THEN
         IPR=IPPPR
         ELSE
            IPPPR=IPR
            WRITE (IPR,180) 'PPPRINT',IPPPR
            CALL WARN
         ENDIF
      CALL HPAST ('DEBUGPR ',IOPDBG,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'DEBUGPR ')
      CALL FTEKCK (IOPDBG,'DEBUGPR ',6,IOPDBG,1,9)
C
C  SET I/O UNIT NUMBER FOR ERROR MESSAGE PRINTOUT
      CALL HPAST ('ERRORPR ',IOERR,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'ERRORPR ')
      CALL FTEKCK (IOERR,'ERRORPR ',9,IOERR,1,9)
C
      ENDIF
C
C  SET THE DEBUG UNIT NUMBER FOR FORECST COMPONENT ROUTINES
      IODBUG=IOPDBG
C
C  SET TRACE LEVEL WITH THE VALUE OF TECHNIQUE PPTRACE
      CALL HPAST ('PPTRACE ',IPTRCE,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'PPTRACE ')
      CALL FTEKCK (IPTRCE,'PPTRACE ',0,IPTRCE,0,3)
C
C  SET FORECAST COMPONENT TRACE LEVEL AND NUMBER OF DEBUG CODES
      ITRACE=IPTRCE
      NDEBUG=0
C
      IF (IPTRCE.GT.0) WRITE (IOPDBG,170)
C
C  GET THE PRINT TECHNIQUE VALUES
C
      CALL HPAST ('PRLASTDY',IPLSTD,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'PRLASTDY')
      CALL FTEKCK (IPLSTD,'PRLASTDY',0,IPLSTD,0,1)
C
      CALL HPAST ('RWWARN  ',IRWARN,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RWWARN  ')
      CALL FTEKCK (IRWARN,'RWWARN  ',1,IRWARN,0,1)
C
      CALL HPAST ('OBSFUTWN',IOBSFT,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'OBSFUTWN')
      CALL FTEKCK (IOBSFT,'OBSFUTWN',1,IOBSFT,0,1)
C
      CALL HPAST ('RRSALLOB',IALLOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSALLOB')
      CALL FTEKCK (IALLOB,'RRSALLOB',0,IALLOB,0,1)
C
      IF (IALLOB.EQ.1) THEN
         IINQOB=1
         IMNQOB=1
         IMNMOB=1
         IINMOB=1
         ISTGOB=1
         IRESOB=1
         GO TO 20
         ENDIF
C
      CALL HPAST ('RRSSTGOB',ISTGOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSSTGOB')
      CALL FTEKCK (ISTGOB,'RRSSTGOB',0,ISTGOB,0,1)
C
      CALL HPAST ('RRSINQOB',IINQOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSINQOB')
      CALL FTEKCK (IINQOB,'RRSINQOB',0,IINQOB,0,1)
C
      CALL HPAST ('RRSMNQOB',IMNQOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSMNQOB')
      CALL FTEKCK (IMNQOB,'RRSMNQOB',0,IMNQOB,0,1)
C
      CALL HPAST ('RRSINMOB',IINMOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSINMOB')
      CALL FTEKCK (IINMOB,'RRSINMOB',0,IINMOB,0,1)
C
      CALL HPAST ('RRSMNMOB',IMNMOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSMNMOB')
      CALL FTEKCK (IMNMOB,'RRSMNMOB',0,IMNMOB,0,1)
C
      CALL HPAST ('RRSRESOB',IRESOB,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSRESOB')
      CALL FTEKCK (IRESOB,'RRSRESOB',0,IRESOB,0,1)
C
20    CALL HPAST ('RRSALLTS',IALLTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSALLTS')
      CALL FTEKCK (IALLTS,'RRSALLTS',0,IALLTS,0,1)
C
      IF (IALLTS.EQ.1) THEN
         IINQTS=1
         IMNQTS=1
         IMNMTS=1
         IINMTS=1
         ISTGTS=1
         IRESTS=1
         GO TO 30
         ENDIF
C
      CALL HPAST ('RRSSTGTS',ISTGTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSSTGTS')
      CALL FTEKCK (ISTGTS,'RRSSTGTS',0,ISTGTS,0,1)
C
      CALL HPAST ('RRSINQTS',IINQTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSINQTS')
      CALL FTEKCK (IINQTS,'RRSINQTS',0,IINQTS,0,1)
C
      CALL HPAST ('RRSMNQTS',IMNQTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSMNQTS')
      CALL FTEKCK (IMNQTS,'RRSMNQTS',0,IMNQTS,0,1)
C
      CALL HPAST ('RRSINMTS',IINMTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSINMTS')
      CALL FTEKCK (IINMTS,'RRSINMTS',0,IINMTS,0,1)
C
      CALL HPAST ('RRSMNMTS',IMNMTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSMNMTS')
      CALL FTEKCK (IMNMTS,'RRSMNMTS',0,IMNMTS,0,1)
C
      CALL HPAST ('RRSRESTS',IRESTS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'RRSRESTS')
      CALL FTEKCK (IRESTS,'RRSRESTS',0,IRESTS,0,1)
C

C  GET THE ENGLISH/METRIC PRINT TECHNIQUE VALUE
30    CALL HPAST ('METRIC  ',METRIC,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'METRIC  ')
      CALL FTEKCK (METRIC,'METRIC  ',0,METRIC,0,1)
C
C  GET THE PPDEBUG TECHNIQUE AND ARGUMENT VALUES
      CALL HPASTA ('PPDEBUG ' ,LIARGS,ITVAL,NWORDS,IARGS,ISTAT)
      IF (ISTAT.GT.0) THEN
         CALL FPHPWN (ISTAT,'PPDEBUG ' )
         DO 40 I=1,20
            PDBUG(I)=IBLNK
40          CONTINUE
         GO TO 60
         ENDIF
      DO 50 I=1,20
         CALL HGTSTR (1,IARGS(1+(I-1)*3),ICDS,IFL,ISTAT)
         IF (ISTAT.NE.0) THEN
            WRITE (IPR,190) ISTAT
            CALL ERROR
            ENDIF
         IF (ICDS.NE.IBLNK) THEN
            NDBUG=NDBUG+1
            PDBUG(NDBUG)=ICDS
            IDEBGS(NDBUG)=ICDS
            IF (PDBUG(NDBUG).EQ.LALL) IPALL=1
            ENDIF
50       CONTINUE
C
C  SET FORECAST COMPONENT DEBUG VALUES
60    NDEBUG=NDBUG
      IALL=IPALL
C
C  CHECK DEBUG CODES
      IBUG=IPBUG('INPT')
      IF (IBUG.GT.0.AND.NDBUG.GT.0) THEN
         WRITE (IOPDBG,200) (PDBUG(I),I=1,NDBUG)
         ENDIF
C
C  SET DATE FOR START OF RUN
      CALL HPASTA ('STARTRUN',LIARGS,ISTR,NWORDS,IARGS,ISTAT)
      IF (ISTAT.GT.0) THEN
         CALL FPHPWN (ISTAT,'STARTRUN')
         WRITE (IPR,210) 'STARTRUN'
         CALL ERROR
         IERR=1
         ELSE
            IDARUN=IARGS(1)/24+1
            IHRRUN=IARGS(1)-IDARUN*24+24
            ISTRUN=IARGS(1)
         ENDIF
C
C  SET DATE FOR END OF RUN
      CALL HPASTA ('ENDRUN  ',LIARGS,IENR,NWORDS,IARGS,ISTAT)
      IF (ISTAT.GT.0) THEN
         CALL FPHPWN (ISTAT,'ENDRUN  ')
         WRITE (IPR,210) 'ENDRUN'
         CALL ERROR
         IERR=1
         ELSE
            LDARUN=IARGS(1)/24+1
            LHRRUN=IARGS(1)-LDARUN*24+24
            IENRUN=IARGS(1)
         ENDIF
C
C  SET THE OUTPUT TIME ZONE AND THE DAYLIGHT SAVINGS SWITCH
      CALL HPAST ('NOUTDS  ',NOUTDS,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'NOUTDS  ')
      CALL FTEKCK (NOUTDS,'NOUTDS  ',0,NOUTDS,0,1)
      CALL HPAST ('NOUTZ   ',NOUTZ,ISTAT)
      IF (ISTAT.GT.0) CALL FPHPWN (ISTAT,'NOUTZ   ')
      CALL FTEKCK (NOUTZ,'NOUTZ   ',-6,NOUTZ,-12,12)
C
C  SET INPTZC, LOCAL, NLSTZ AND NHOPDB FROM HCL RFC DEFAULT CB /HDFLTS/
      INPTZC=LINPTZ
      LOCAL=LCLHCL
      NLSTZ=LTZHCL
      NHOPDB=NPDHCL
C
C  CHECK THAT THE START AND END TIMES ARE THE BEGINNING AND END OF
C  HYDROLOGIC DAYS - PREPROCESSOR MUST RUN FOR AT LEAST 24 HOURS
      ISTRUN=ISTRUN-MOD(ISTRUN,24)
      IF (MOD(IENRUN,24).EQ.0) GO TO 70
         IENRUN=IENRUN+(24-MOD(IENRUN,24))
70    IDARUN=ISTRUN/24+1
      IHRRUN=ISTRUN-IDARUN*24+24
      LDARUN=IENRUN/24+1
      LHRRUN=IENRUN-LDARUN*24+24
C
C  GET DATE OF FIRST DAY OF PP24 DATA
      CALL RPDDTE ('PP24',IDPPDB,LDPPDB,ISTAT)
      IF (ISTAT.NE.0) THEN
         IF (ISTAT.EQ.2.OR.ISTAT.EQ.3) THEN
            IF (ISTAT.EQ.2) WRITE (IPR,250)
            IF (ISTAT.EQ.3) WRITE (IPR,260)
            WRITE (IPR,265)
            CALL WARN
            GO TO 80
            ELSE
               WRITE (IPR,240) ISTAT
               CALL ERROR
               IERR=1
               GO TO 90
            ENDIF
         ENDIF
C
C  CHECK IF STARTRUN PRIOR TO FIRST DAY
      IF (IDARUN.GE.IDPPDB-1) GO TO 80
C
C  RESET STARTRUN
      IDARUN=IDPPDB-1
      ISTRUN=(IDARUN-1)*24
      IHRRUN=0
      CALL MDYH1 (IDARUN,IHRRUN,IM,ID,IY,IH,NOUTZ,NOUTDS,TZC)
      WRITE (IPR,220) IM,ID,IY
      CALL WARN
C
C  SEE IF STARTRUN LESS THAN ENDRUN
80    IF (IDARUN.LT.LDARUN) GO TO 100
      WRITE (IPR,230)
      CALL ERROR
C
C  TIMING EROR
90    IERR=1
      GO TO 160
C
C  SET DATE FOR LAST DAY OF OBSERVED DATA
100   CALL HPASTA ('LSTCMPDY',LIARGS,ILCR,NWORDS,IARGS,ISTAT)
      IF (ISTAT.GT.0) THEN
         CALL FPHPWN (ISTAT,'LSTCMPDY')
         WRITE (IPR,210) 'LSTCMPDY'
         CALL ERROR
         IERR=1
         ENDIF
      LDACPD=IARGS(1)/24 +1
      LHRCPD=IARGS(1)-LDACPD*24+24
      ILCRUN=IARGS(1)
C
      IF (IBUG.GT.0) WRITE (IOPDBG,*)
     *   ' IDARUN=',IDARUN,
     *   ' IHRRUN=',IHRRUN,
     *   ' LDARUN=',LDARUN,
     *   ' LHRRUN=',LHRRUN,
     *   ' LDACPD=',LDACPD,
     *   ' LHRCPD=',LHRCPD,
     *   ' '
C
C  PRINT RUN PERIOD
      CALL MDYH1 (IDARUN,IHRRUN,IM,ID,IY,IH,NOUTZ,NOUTDS,TZC)
      CALL MDYH1 (LDARUN,LHRRUN,LM,LD,LY,LH,NOUTZ,NOUTDS,TZC)
      CALL MDYH1 (LDACPD,LHRCPD,LCM,LCD,LCY,LCH,NOUTZ,NOUTDS,TZC)
      CALL UPAGE (IPR)
      WRITE (IPR,270)
      WRITE (IPR,280) IM,ID,IY,IH,TZC,
     *   LM,LD,LY,LH,TZC,
     *   LCM,LCD,LCY,LCH,TZC
C
C  PROCESS MOD CARDS
      CALL HMODCK (RRSMOD,MAXMOD,IMGMOD,NMOD,ISTAT)
      IF (ISTAT.NE.0) THEN
         IF (ISTAT.EQ.1) WRITE (IPR,290) MAXMOD,MAXMOD,RRSMOD
         IF (ISTAT.EQ.2) WRITE (IPR,300) RRSMOD
         IF (ISTAT.EQ.3) WRITE (IPR,310) RRSMOD
         IF (ISTAT.LT.0.OR.ISTAT.GT.3) WRITE (IPR,320) ISTAT,RRSMOD
         CALL WARN
         ENDIF
C
      IF (IBUG.GT.0) WRITE (IOPDBG,*) ' NMOD=',NMOD
C
C  CHECK IF THERE ARE ANY MODS INPUT
      IF (NMOD.EQ.0) GO TO 150
C
C  INITIALIZE THE DATE ARRAYS
      DO 110 I=1,NMOD
         MISTRT(I)=' '
         MIEND(I)=' '
110      CONTINUE
C
      DO 140 I=1,NMOD
         LMGMOD=20
         LIBUF=80
         CALL UNPAKS (IMGMOD(I),IBUF,LMGMOD,LIBUF,ISTAT)
         IF (ISTAT.GT.0) THEN
            WRITE (IPR,350) ISTAT
            CALL ERROR
            ISKIP=1
            GO TO 130
            ENDIF
C     GET FIELDS
         ICDBEG=1
         ICDEND=72
         CALL UFREE (ICDBEG,ICDEND)
         IF (IBUG.GT.0) WRITE (IOPDBG,*) ' NFIELD=',NFIELD
         IF (NFIELD.GT.1) GO TO 120
C        CHECK FOR .RRSMSNG MOD CARD
            NFLD=1
            NCHAR=IFSTOP(NFLD)-IFSTRT(NFLD)+1
            IF (NCHAR.GT.LEN(STRNG)) NCHAR=LEN(STRNG)
            STRNG=' '
            CALL UPACK1 (IBUF(IFSTRT(NFLD)),STRNG,NCHAR)
            CALL UNAMCP (STRNG,'.RRSMSNG',ISTAT)
            IF (ISTAT.EQ.0) GO TO 140
C     CHECK THAT THE MOD INPUT CARD HAS AT LEAST 2 FIELDS
120      IF (NFIELD.LT.3) THEN
            WRITE (IPR,330) IMGMOD(I)
            CALL WARN
            GO TO 140
            ENDIF
         ISKIP=0
C     GET STATION IDENTIFIER
         NFLD=1
         NCHAR=IFSTOP(NFLD)-IFSTRT(NFLD)+1
         IF (NCHAR.LT.0.OR.NCHAR.GT.LEN(STAID)) THEN
            WRITE (IPR,370) 'STATION IDENTIFIER',NFLD,LEN(STAID),NCHAR
            CALL WARN
            ISKIP=1
            ELSE
               STAID=' '
               CALL UPACK1 (IBUF(IFSTRT(NFLD)),STAID,NCHAR)
               IF (IBUG.GT.0) WRITE (IOPDBG,*) ' STAID=',STAID
               IF (STAID.EQ.'$') GO TO 140
            ENDIF
C     GET DATA TYPE
         NFLD=2
         NCHAR=IFSTOP(NFLD)-IFSTRT(NFLD)+1
         IF (NCHAR.LT.0.OR.NCHAR.GT.LEN(DTYPE)) THEN
            WRITE (IPR,370) 'DATA TYPE',NFLD,LEN(DTYPE),NCHAR
            CALL WARN
            ISKIP=1
            ELSE
               DTYPE=' '
               CALL UPACK1 (IBUF(IFSTRT(NFLD)),DTYPE,NCHAR)
               IF (IBUG.GT.0) WRITE (IOPDBG,*) ' DTYPE=',DTYPE
            ENDIF
C     GET START DATE
         NFLD=3
         CALL USRCHR (IASTR,IFSTRT(NFLD),IFSTOP(NFLD),LOC1)
         CALL USRCHR (ISLASH,IFSTRT(NFLD),IFSTOP(NFLD),LOC2)
         IF (LOC1.GT.0.OR.LOC2.GT.0) THEN
            WRITE (IPR,360) NFLD
            CALL WARN
            ISKIP=1
            ENDIF
         NCHARS=IFSTOP(NFLD)-IFSTRT(NFLD)+1
         IF (NCHARS.LT.0.OR.NCHARS.GT.LEN(MISTRT(1))) THEN
            WRITE (IPR,370) 'START DATE',NFLD,LEN(MISTRT(1)),NCHARS
            CALL WARN
            ISKIP=1
            ELSE
               ICARD=ICARD+1
               MISTRT(ICARD)=' '
               CALL UPACK1 (IBUF(IFSTRT(NFLD)),MISTRT(ICARD),NCHARS)
            ENDIF
         IF (NFIELD.EQ.3) THEN
            IF (ISKIP.EQ.1) GO TO 130
            MSTAID(ICARD)=STAID
            MDTYPE(ICARD)=DTYPE
            MSCHAR(ICARD)=NCHARS
            IF (IBUG.GT.0) WRITE (IOPDBG,340)
     *         MSTAID(ICARD),
     *         MDTYPE(ICARD),
     *         MISTRT(ICARD),
     *         MSCHAR(ICARD)
            GO TO 140
            ENDIF
C     GET END DATE
         NFLD=4
         CALL USRCHR (IASTR,IFSTRT(NFLD),IFSTOP(NFLD),LOC1)
         CALL USRCHR (ISLASH,IFSTRT(NFLD),IFSTOP(NFLD),LOC2)
         IF (LOC1.GT.0.OR.LOC2.GT.0) THEN
            WRITE (IPR,360) NFLD
            CALL WARN
            ISKIP=1
            ENDIF
         NCHARE=IFSTOP(NFLD)-IFSTRT(NFLD)+1
         IF (NCHARE.LT.0.OR.NCHARE.GT.LEN(MIEND(1))) THEN
            WRITE (IPR,370) 'END DATE',NFLD,LEN(MIEND(1)),NCHARE
            CALL WARN
            ISKIP=1
            ELSE
               IF (ISKIP.EQ.1) GO TO 130
               MIEND(ICARD)=' '
               CALL UPACK1 (IBUF(IFSTRT(NFLD)),MIEND(ICARD),NCHARE)
               MSTAID(ICARD)=STAID
               MDTYPE(ICARD)=DTYPE
               MSCHAR(ICARD)=NCHARS
               MECHAR(ICARD)=NCHARE
               IF (IBUG.GT.0) WRITE (IOPDBG,340)
     *            MSTAID(ICARD),
     *            MDTYPE(ICARD),
     *            MISTRT(ICARD),
     *            MSCHAR(ICARD),
     *            MIEND(ICARD),
     *            MECHAR(ICARD)
            ENDIF
130      IF (ISKIP.EQ.1) WRITE (IPR,380) IMGMOD(I)
140      CONTINUE
C
150   NMOD=ICARD
      IF (NMOD.LT.0) NMOD=0
C
160   CALL FSTWHR (OLDOPN,IOLDOP,OLDOPN,IOLDOP)
C
      IF (IPTRCE.GT.0) WRITE (IOPDBG,390)
C
      RETURN
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
170   FORMAT (' *** ENTER QINPUT')
180   FORMAT ('0**WARNING** THE VALUE FOR TECHNIQUE ',A,' MUST ',
     *   'BE 6, 8 OR 9. THE VALUE HAS BEEN SET TO ',I2,'.')
190   FORMAT ('0**ERROR** STATUS CODE ',I3,' RETURNED FROM ROUTINE ',
     *   'HGTSTR WHILE DECODING DEBUG CODES FROM TECHNIQUE ',
     *   'PPDBUG.')
200   FORMAT (' PPDBUG DEBUG CODES CURRENTLY ACTIVE ARE' /
     *   ' ',20(A4,1X))
210   FORMAT ('0**ERROR** TECHNIQUE ',A,' NOT SPECIFIED.')
220   FORMAT ('0**WARNING** STARTRUN DATE WAS PRIOR TO FIRST DAY OF ',
     *   'DAILY DATA. STARTRUN CHANGED TO ',I2.2,'/',I2.2,'/',I4,'.')
230   FORMAT ('0**ERROR** THE STARTRUN EQUALS THE ENDRUN DATE.')
240   FORMAT ('0**ERROR** STATUS CODE OF ',I2,
     *   'RETURNED FROM ROUTINE RPDDTE.')
250   FORMAT ('0**WARNING** DATA TYPE PP24 NOT DEFINED ',
     *   'IN THE PREPROCESSOR DATA BASE.')
260   FORMAT ('0**WARNING** NO STATIONS DEFINED FOR DATA TYPE PP24 ',
     *   'IN THE PREPROCESSOR DATA BASE.')
265   FORMAT (13X,
     *   'NO CHECK CAN BE MADE FOR STARTRUN AND FIRST DAY OF DATA.')
270   FORMAT ('0',45X,'RRS FUNCTION')
280   FORMAT ('0',30X,'RUN PERIOD',2X,
     *      I2.2,'/',I2.2,'/',I4.4,'-',I2.2,A4,' THRU ',
     *      I2.2,'/',I2.2,'/',I4.4,'-',I2.2,A4 /
     *   '0',30X,'OBSERVED DATA ENDS AT ',
     *      I2.2,'/',I2.2,'/',I4.4,'-',I2.2,A4)
290   FORMAT ('0**WARNING** MORE THAN ',I4,' CARD IMAGES FOUND. THE ',
     *   'FIRST ',I4,' CARD IMAGES RETURNED FROM HCL FOR MOD ',A,
     *   ' WILL BE PROCESSED')
300   FORMAT ('0**ERROR** THE MOD ',A,' IS NOT VALID FOR ROUTINE ',
     *   'HMODCK.')
310   FORMAT ('0**ERROR** THE MOD ',A,' NOT VALID.')
320   FORMAT ('0**ERROR** AN INVALID STATUS CODE OF ',I3,' WAS ',
     *   'RETURNED FROM HMODCK FOR MOD ',A,'.')
330   FORMAT ('0**WARNING** THE FOLLOWING MOD CARD WILL NOT BE ',
     *   'PROCESSED BECAUSE IT CONTAINS LESS THAN 3 FIELDS:' /
     *   13X,A)
340   FORMAT (' MSTAID=',A,' MDTYPE=',A,' MISTRT=',A,
     *   ' MSCHAR=',I2 : ' MIEND=',A,'MECHAR=',I2)
350   FORMAT ('0**ERROR** STATUS CODE ',I2,
     *   ' RETURNED FROM ROUTINE UNPAKS.')
360   FORMAT ('0**WARNING** AN ''*'' OR ''/'' CANNOT BE USED ',
     *   'IN DATE FIELD ',I2,' OF THE RRSMSNG MOD CARD.')
370   FORMAT ('0**WARNING** THE ',A,' IN FIELD ',I2,' CAN ',
     *   'CONTAIN ONLY ',I2,' CHARACTERS BUT IT HAS ',I2,
     *   ' CHARACTERS.')
380   FORMAT ('0**NOTE** THE FOLLOWING MOD CARD WILL NOT BE ',
     *  'PROCESSED:' / 13X,A)
390   FORMAT (' *** EXIT QINPUT')
C
      END
