C$PRAGMA C (GET_APPS_DEFAULTS)
C$PRAGMA C (UDATL)
c  =====================================================================
c
c  MAIN ROUTINE FOR FLASH FLOOD GUIDANCE VALUE COMPUTATION
c
c.......................................................................
c
c  This program computes area, grid and headwater flash flood
c  guidance values.  Current soil moisture conditions are obtained from
c  rainfall-runoff curves which are generated by the FFG Operation in
c  NWSRFS OFS.
c
c.......................................................................
c
c  Initially written by
c        Tim Sweeney, Hydrologic Services Branch, OH       Jan 1991
c
c  Increased dimension of po array to store grid values in a single
c  file for each duration
c        Tim Sweeney, HRL                                  Nov 1995
c
c  Increased dimension of bx and ibx arrays to handle increased size
c  of basin boundary arrays generated by IHABBS.
c        Tim Sweeney, HRL                                  Nov 1997
c
c  Added basin and county sizes output
c        Tim Sweeney, HRL                                  Mar 1999
c
c  Added option to assign Zone FFG computed from headwater
c  algorithm to HRAP grids.  Must enter response 'Z' instead
c  of 'C'.
c        Tim Sweeney, HL                                   Mar 2001
c
c  Added capability to compute one ffgid, zone, or headwater.
c  Enter 'o' (not zero) and the identifier, then 'g', 'a', or 'h'.
c        Tim Sweeney, HL                                   may 2001
c
c.......................................................................
c
c  Selected Variables:
c
c  Name    Description
c  ------  ---------------------------------------------------
c  arpa    Directory for area parameters
c  basnpa  Directory for basin boundary parameters
c  carypa  Directory for rainfall-runoff and snow carryovers
c  ffoppa  Directory for FFG operation directory (testing only)
c  gffpa   Directory for gridded flash flood guidance values
c  gropa   Directory for gridded threshold runoff
c  grpppa  Directory for Group of Products parameters
c  hdwpa   Directory for headwater parameters
c  igpmpa  Directory for grid runoff adjust parameters
c  outpa   Directory for output
c  prodpa  Directory for product parameters
c  rcpa    Directory for rating curves (testing only)
c  tspa    Directory for time series (testing only)
c  txtpa   Directory for text parameters
c  usrpa   Directory for user information
c
c  bx      Basin boundary parameters
c  chidx   Index array
c  ibx     Index array of identifiers
c  ibug    Debug output switch (0 = off, 1 = on)
c
c  iud     Unit for debug output
c  iue     Unit for error output
c  iul     Unit for log output
c  iutr    Unit for keyboard
c  iutw    Unit for screen
c
c  mbx     Maximum number of words in OFS basin boundary array bx
c  mpo     Maximum number of words in parameter array
c
c  narea   Number of area FFG values
c  nerr    Number of errors
c  ngrid   Number of gridded FFG values
c  nhead   Number of headwater FFG values
c  nwarn   Number of warnings
c
c  po      Parameter array
c
c.......................................................................
c
      subroutine ffmain_main
c
      character*1 resp
      character*2 resp2,bname
      character*4 code,cnum
      character*7 timezone
      character*20 appsvar,appsval
      character*30 logfile
      character*128 logpath
      character*132 strng
c
      include 'udebug'
      include 'updaio'
      COMMON /CMFFGUID/ PGMVRN,PGMVRD,PGMNAM,MPGMRG,PGMCMP,PGMSYS
      INCLUDE 'upvrsx_types'
      include 'ffg_inc/iuws'
      include 'ffg_inc/gdebug'
      include 'ffg_inc/iodno'
      include 'ffg_inc/count'
      include 'ffg_inc/paths'
      include 'ffg_inc/uinfo'
      include 'ffg_inc/timez'
      include 'ffg_inc/gidx'
      include 'ffg_inc/gpo'
      include 'ffg_inc/gbx'
      include 'ffg_inc/bsnsiz'
      include 'common/ionum'
      include 'common/fdbug'
      include 'common/fctime'
c
      integer mdy(6)
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ffg/src/ffguid_main/RCS/ffmain.f,v $
     . $',                                                             '
     .$Id: ffmain.f,v 1.11 2004/09/13 17:08:07 scv Exp $
     . $' /
C    ===================================================================
C
C     Setup the upvrsx common block
      call set_upvrsx(PGMVRN,PGMVRD,PGMNAM,MPGMRG,PGMCMP,PGMSYS)
C
C     Subroutine ARGVER outputs the version/date info and exits the
C      program if the first command line argument is "-version"
C
      CALL ARGVER()
c
c  initialize variables
      ibug   = 0
      idball = 0
      itrace = 0
      ihcltr = 0
      ihcldb = 0
      ibsize = 0
      igtrac = 0
      igdbug = 0
      igerr = 1
      ibsize = 0
      singid = 'none'
      ilogfile = 0
      ilogopen = 0
      bname = ' '
c
c  set options for utility routines
      call useto1 ('NOPAGHDR',ierr)
      call useto1 ('NOERWRPR',ierr)
      call useto1 ('NOCONDPR',ierr)
      call useto1 ('NOTIMRPR',ierr)
      call useto1 ('NOOVERPRINT',ierr)
c
c  initialize file input/output routine common block
      call upinio
c
c  set print unit for file input/output routines
ccc      uu = iutw
c
      if (ibug.eq.1) write (iud,*) 'in ffmain - iud=',iud
c
c  set device unit numbers
      call devnum
c
c  print program and version information
      idsply = 1
      call prnamv (idsply,iutw)
c
c  get options and directory names from environmental variables
      call envfix
c
      if (pgmnam.eq.' ') then
         write (iutw,'(/a)') 'ERROR: variable pgmnam is blank.'
         go to 340
         endif
c
c  set log filename
      appsvar='ffg_log_name'
      lappsvar=lenstr(appsvar)
      call get_apps_defaults (appsvar,lappsvar,appsval,lappsval)
      if (lappsval.gt.0) then
         logfile=appsval
         else
            call ucp2lc (pgmnam,strng,ierr)
            lstrng=lenstr(strng)
ccc            logfile=ofslvl(1:lofsl)//'_'//strng(1:lstrng)//'_log'
ccc            logfile=strng(1:lstrng)//'_log'
            logfile=' '
            appsvar='ffg_log_prefix'
            lappsvar=lenstr(appsvar)
            call get_apps_defaults (appsvar,lappsvar,appsval,lappsval)
            if (lappsval.gt.0) then
               call ucncat (logfile,appsval(1:lappsval),ierr)
               call ucncat (logfile,'_',ierr)
               endif
            call ucncat (logfile,strng(1:lstrng),ierr)
            call ucncat (logfile,'_log',ierr)
         endif
c
c  check if logfile option specified as environmental variables
      if (iupr.eq.iul) then
         call opnlog (ilogopen,logfile,logpath,istat)
         llogpath=lenstr(logpath)
         if (istat.eq.0) then
            iupr = iul
            ipr = iul
            ilogfile = 1
            else
               write (iutw,5) logpath(1:llogpath)
5     format (/ ' ERROR: cannot open file ',a,'.')
               iupr = iutw
               go to 330
            endif
         endif
c
      if (nerr.gt.0) go to 330
c
c  get system date and time
      call udatl (mdy)
      nmo = mdy(3)
      nda = mdy(4)
      nyr = mdy(1)
      nhr = mdy(5)/100
      nmn = mdy(5) - nhr*100
      nsc = mdy(6)/100
c
c  get daylight savings time indicator
      lcptz = 1
      ictz = 0
      call datimz (lcptz,ictz,nmo,nda,nyr,nhr,nmn,kzmo,kzda,kzyr,kzhr,
     +             kzmn,ndawk,idayl,mxday,julda)
c
c  get time zone
      appsvar='TZ'
      lappsvar=lenstr(appsvar)
      call get_apps_defaults (appsvar,lappsvar,timezone,ltimezone)
      if (idayl.eq.1) then
         ltimezone1=5
         ltimezone2=7
         else
            ltimezone1=1
            ltimezone2=3
         endif
c
      write (iutw,10) ffglvl(1:lffgl),ofslvl(1:lofsl)
10    format (/ 20x,'ffg_level=',a,5x,'ofs_level=',a)
      write (iutw,20) nmo,nda,nyr,nhr,nmn,nsc,
     +   timezone(ltimezone1:ltimezone2)
20    format (/ 10x,5x,3x,'RUN DATE = ',i2.2,'/',i2.2,'/',i4,' - ',
     +   i2.2,':',i2.2,':',i2.2,' ',a)
      write (iutw,30) usrpa(1:lusr),
     +                arpa(1:lar),
     +                carypa(1:lcary),
     +                gffpa(1:lgff),
     +                gropa(1:lgro),
     +                hdwpa(1:lhdw),
     +                igpmpa(1:lgpm),
     +                grpppa(1:lgrpp),
     +                outpa(1:lout),
     +                prodpa(1:lprod),
     +                txtpa(1:ltxt),
     +                wsuppa(1:lwsup)
30    format (/
     +        ' directory for user info       = ',a /
     +        ' directory for areas           = ',a /
     +        ' directory for carryovers      = ',a /
     +        ' directory for gridded ffg     = ',a /
     +        ' directory for gridded runoff  = ',a /
     +        ' directory for headwaters      = ',a /
     +        ' directory for runoff adj parm = ',a /
     +        ' directory for groups of prod  = ',a /
     +        ' directory for output          = ',a /
     +        ' directory for products        = ',a /
     +        ' directory for texts           = ',a /
     +        ' directory for water supply    = ',a)
      if (iupr.ne.iutw) then
         idsply = 3
         call prnamv (idsply,iupr)
         write (iupr,10) ofslvl(1:lofsl),ffglvl(1:lffgl)
         write (iupr,20) nmo,nda,nyr,nhr,nmn,nsc,
     +      timezone(ltimezone1:ltimezone2)
         write (iupr,30) usrpa(1:lusr),
     +                   arpa(1:lar),
     +                   carypa(1:lcary),
     +                   gffpa(1:lgff),
     +                   gropa(1:lgro),
     +                   hdwpa(1:lhdw),
     +                   igpmpa(1:lgpm),
     +                   grpppa(1:lgrpp),
     +                   outpa(1:lout),
     +                   prodpa(1:lprod),
     +                   txtpa(1:ltxt),
     +                   wsuppa(1:lwsup)
         if (iofs.gt.0) write (iud,40) basnpa(1:lbasn),ffoppa(1:lffop),
     +                                 rcpa(1:lrc),tspa(1:lts)
40    format (' basnpa=',a / ' ffoppa=',a /
     +        ' rcpa  =',a / ' tspa  =',a )
         endif
c
c  read control info for Preprocessor Parameteric Data Base
      call rpppco (istat)
      if (istat.ne.0) then
         write (iutw,50) 'Preprocessor Parametric',
     +      'RPPPCO',istat
         if (iupr.ne.iutw) write (iupr,50) 'Preprocessor Parametric',
     +      'RPPPCO',istat
50    format (/ ' ERROR: problem reading ',a,' Data Base control ',
     +   'information. Status code from routine ',a,' is ',i2,'.')
        nerr = nerr + 1
        endif
c
c  read control info for Preprocessor Data Base (time series)
      call rpdbci (istat)
      if (istat.ne.0) then
         write (iutw,50) 'Processed','RPDBCI',istat
         if (iupr.ne.iutw) write (iupr,50) 'Processed','RPDBCI',istat
         nerr = nerr + 1
         endif
c
      if (nerr.gt.0) go to 330
c
c  read control info for Forecast Component Rating Curves
      call rcci
c
c  initialize ffg computation date
      lffcpd = -1
c
      if (ibug.eq.1) write (iud,*) 'in ffmain - iupr=',iupr,
     *   ' iutw=',iutw
c
      write (iutw,*)
      if (igdbug.gt.0) write (iutw,70) igdbug
70    format (' DEBUG=',i3)
      if (igerr.gt.0) write (iutw,*) 'ERROR ON'
      if (iupr.eq.iutw) then
         write (iutw,*) 'LOGFILE OFF'
         else
            write (iutw,*) 'LOGFILE ON'
            write (iutw,100) logpath(1:llogpath)
100   format (/ ' NOTE: log information will be written to file ',a,'.')
         endif
c
110   write (iutw,120)
120   format (/ 10x,'COMPUTATIONS MENU')
      write (iutw,130)
130   format (/ 10x,5x,'C - Compute all' /
     +          10x,5x,4x,'Or separately:' /
     +          10x,5x,4x,3x,'A - Area FFG' /
     +          10x,5x,4x,3x,'G - Gridded FFG' /
     +          10x,5x,4x,3x,'H - Headwater FFG' /
ccc     +          10x,5x,4x,3x,'L - Land Slide Guidance' /
     +          10x,5x,4x,3x,'V - Carryover Transfer' /
     +          10x,5x,4x,3x,'W - Water Supply Guidance' /
ccc     +          10x,5x,4x,3x,'Z - ?' /
     +          10x,5x,'O - One identifier run' /
     +          10x,5x,'Q - Quit program' /
     +          10x,5x,'S - Setup Menu')
c
135   write (iutw,140)
140   format (/ ' Select (<return>-exit): ',$)
c
      read (iutr,'(a)',err=110,end=330) cnum
      resp = cnum(1:1)
      if (ibug.eq.1) write (iud,*) 'in ffmain - iutr=',iutr,
     +   ' resp=',resp
      if (resp.eq.' ') go to 330
      resp2 = cnum(1:2)
c
c  reset counters
      narea = 0
      ngrid = 0
      nhead = 0
      nwsup = 0
      nlang = 0
      nvar  = 0
      nerr  = 0
      nwarn = 0
      nearea = 0
      nwarea = 0
      negrid = 0
      nwgrid = 0
      nehwat = 0
      nwhwat = 0
      nevar  = 0
      nwvar  = 0
      newsup = 0
      nwwsup = 0
      nelang = 0
      nwlang = 0
c
c  reset area size variables
      nbarea = 0
      ncarea = 0
c
c  set flag to get gridded guidance from database
      kgridf = 0
c
      icaller = 1
c
c  check option
      if (resp.eq.'C'.or.resp.eq.'c') then
c     compute all
         call chkext (icaller)
         call cpgridx
         call cparea
         call cphed
         call cpsup
         else if (resp.eq.'A'.or.resp.eq.'a') then
c        compute area ffg
            write (iutw,150)
            if (iupr.ne.iutw) write (iupr,150)
150   format (/ ' WARNING: area FFG being run separately. ',
     +   'Gridded FFG should have already been run.')
            call cparea
         else if (resp.eq.'G'.or.resp.eq.'g') then
c        compute gridded ffg
            call chkext (icaller)
            nvar = -1
            call cpgridx
         else if (resp.eq.'H'.or.resp.eq.'h') then
c        compute headwater ffg
            call chkext (icaller)
            call cphed
ccc         else if (resp.eq.'L'.or.resp.eq.'l') then
ccc            call cplang
         else if (resp.eq.'O'.or.resp.eq.'o') then
            write (iutw,160)
160   format (' Enter identifier: ',$)
            read (iutr,'(a)',end=330) singid
            if (singid.eq.' ') singid='none'
            go to 110
         else if (resp.eq.'Q'.or.resp.eq.'q') then
c        quit program
            go to 330
         else if (resp.eq.'V'.or.resp.eq.'v') then
c        carryover transfer
            call cpcary
         else if (resp.eq.'W'.or.resp.eq.'w') then
c        water supply guidance
            call cpsup
         else if (resp.eq.'Z'.or.resp.eq.'z') then
            call chkext (icaller)
            call cphed
            ngrid = -3
            call cpgridx
            call cpsup
         else
            go to 260
         endif
c
c  convert internal time to external, convert 24 hr to 0 hr
      call int2xt (lffcpd,jda,jhr,jm,jd,jy,jh,0,0,code)
      if (ibug.eq.1) write (iud,165) jda,jhr,lffcpd
165   format (' Internal day/hour = ',i6,'/',i2.2,3x,
     +   'Julian hour = ',i6)
c
      ntot=ngrid+narea+nhead+nvar+nwsup
      if (ntot.gt.0) then
         write (iutw,170)
170   format (/ ' Computation Summary:')
         write (iutw,180) jm,jd,jy,jh
180   format (3x,'Date=',2(i2.2,'/'),i4,'-',i2.2,'Z')
         if (ngrid.gt.0) write (iutw,182) ngrid,negrid,nwgrid
182   format (5x,'Grids=     ',i6,'  (Errors=',i5,'  Warnings=',i5,')')
         if (narea.gt.0) write (iutw,184) narea,nearea,nwarea
184   format (5x,'Areas=     ',i6,'  (Errors=',i5,'  Warnings=',i5,')')
         if (nhead.gt.0) write (iutw,186) nhead,nehwat,nwhwat
186   format (5x,'Headwaters=',i6,'  (Errors=',i5,'  Warnings=',i5,')')
         if (nvar.gt.0) write (iutw,190) nvar,nevar,nwvar
190   format (5x,'Carryovers=',i6,'  (Errors=',i5,'  Warnings=',i5,')')
         if (nwsup.gt.0) write (iutw,200) nwsup,newsup,nwwsup
200   format (5x,'WaterSupply',i6,'  (Errors=',i5,'  Warnings=',i5,')')
         if (iupr.ne.iutw) then
            write (iupr,170)
            write (iupr,180) jm,jd,jy,jh
            if (ngrid.gt.0) write (iupr,182) ngrid,negrid,nwgrid
            if (narea.gt.0) write (iupr,184) narea,nearea,nwarea
            if (nhead.gt.0) write (iupr,186) nhead,nehwat,nwhwat
            if (nvar.gt.0) write (iupr,190) nvar,nevar,nwvar
            if (nwsup.gt.0) write (iupr,200) nwsup,newsup,nwwsup
            endif
         endif
c
c  basin and county size statistics
      if (ibsize.eq.1) then
         if (nbarea.gt.0) then
           bmed = bsize(nbarea/2)
           write (iutw,210) nbarea,bavg,bmed
210   format (/ 5x,'Basin Areas (sq mi):  Number=',i5,
     +        3x,'Avg=',f6.0,3x,'Median=',f6.0 /
     +        17x,'Largest',23x,'Smallest')
           if (iupr.ne.iutw) write (iupr,210) nbarea,bavg,bmed
           n = 10
           if (nbarea.lt.10) n = nbarea
           do 230 i=1,n
              j = nbarea + i - n
              write ( iutw,220) i,(bbsid(k,i),k=1,2),bsize(i),
     +                          j,(bbsid(k,j),k=1,2),bsize(j)
220   format (2(10x,i4,2x,2a4,f6.0))
              if (iupr.ne.iutw) write (iupr,220)
     +                             i,(bbsid(k,i),k=1,2),bsize(i),
     +                             j,(bbsid(k,j),k=1,2),bsize(j)
230           continue
            endif
         if (ncarea.gt.0) then
            cmed = csize(ncarea/2)
            write (iutw,240) ncarea,cavg,cmed
240   format (/ 5x,'County Areas (sq mi): Number=',i5,
     +        3x,'Avg=',f6.0,3x,'Median=',f6.0 /
     +        17x,'Largest',23x,'Smallest')
            if (iupr.ne.iutw) write (iupr,220) ncarea,cavg,cmed
            n = 10
            if (ncarea.lt.10) n = ncarea
            do 250 i=1,n
               j = ncarea + i - n
               write (iutw,220) i,(cbsid(k,i),k=1,2),csize(i),
     +                          j,(cbsid(k,j),k=1,2),csize(j)
               if (iupr.ne.iutw)
     +            write (iupr,220) i,(cbsid(k,i),k=1,2),csize(i),
     +                             j,(cbsid(k,j),k=1,2),csize(j)
250            continue
            endif
         endif
c
      go to 110
c
260   if (resp.eq.'S'.or.resp.eq.'s') then
         go to 280
         else if (resp2.eq.'D '.or.resp2.eq.'d ') then
            write (iutw,270)
270   format (' Debug options:' /
     +        4x,'d,d1 - rainfall runoff curves' /
     +        4x,'  d2 - all computations' /
     +        4x,'  d3 - not used' /
     +        4x,'  d4 - i/o accesses' /
     +        4x,'  d5 - check basin and county area sizes')
            igdbug = 1
         else if (resp2.eq.'D1'.or.resp2.eq.'d1') then
c        set debug level 1
            igdbug = 1
         else if (resp2.eq.'D2'.or.resp2.eq.'d2') then
c        set debug level 2
            igdbug = 2
         else if (resp2.eq.'D3'.or.resp2.eq.'d3') then
c        set debug level 3
            igdbug = 3
         else if (resp2.eq.'D4'.or.resp2.eq.'d4') then
c        set debug level 4
            igdbug = 4
         else if (resp2.eq.'D5'.or.resp2.eq.'d5') then
c        set check basin size control
            ibsize = 1
         else if (resp.eq.'E'.or.resp.eq.'e') then
c        set error option
            igerr = 1
         else if (resp.eq.'L'.or.resp.eq.'l') then
            if (ilogfile.eq.0) then
c           open logfile
               call opnlog (ilogopen,logfile,logpath,istat)
               llogpath=lenstr(logpath)
               if (istat.eq.0) then
                  iupr = iul
                  ipr  = iul
                  write (iutw,*) 'LOGFILE ON'
                  write (iutw,100) logpath(1:llogpath)
                  idsply = 1
                  call prnamv (idsply,iul)
                  write (iul,10) ffglvl(1:lffgl),ofslvl(1:lofsl)
                  write (iul,20) nmo,nda,nyr,nhr,nmn,nsc,
     +               timezone(ltimezone1:ltimezone2)
                  write (iul,30) usrpa(1:lusr),
     +                           arpa(1:lar),
     +                           carypa(1:lcary),
     +                           gffpa(1:lgff),
     +                           gropa(1:lgro),
     +                           hdwpa(1:lhdw),
     +                           igpmpa(1:lgpm),
     +                           grpppa(1:lgrpp),
     +                           outpa(1:lout),
     +                           prodpa(1:lprod),
     +                           txtpa(1:ltxt),
     +                           wsuppa(1:lwsup)
                  endif
               else
                  iupr = iutw
                  ipr = iutw
                  ilogfile = 0
                  write (iutw,*) 'LOGFILE=OFF'
               endif
         else if (resp.eq.'T'.or.resp.eq.'t') then
c        set trace option
            igtrac = 1
         else
            write (iutw,275) resp(1:lenstr(resp))
275   format (/ ' ERROR: ',a,' is an invalid option.')
            go to 135
         endif
c
c  reset error and debug units
      if (iupr.ne.iutw) then
         iue = iupr
         iud = iupr
      endif
      go to 110
c
c     -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
c
c  Setup menu

280   write (iutw,290)
290   format (/ 10x,'SETUP MENU')
      write (iutw,300)
300   format (/
     +          10x,5x,'A - Areas' /
     +          10x,5x,'C - Computation Menu (previous menu)' /
     +          10x,5x,'G - Grid Threshold Runoff Parameters' /
ccc     +          10x,5x,'L - Land Slide' /
     +          10x,5x,'H - Headwaters' /
     +          10x,5x,'R - Runoff Adjust for Grids' /
     +          10x,5x,'U - User Controls' /
     +          10x,5x,'W - Water Supply'
     +          )
      if (igdbug.gt.0) then
         write (iutw,310)
310   format (/ 10x,5x,'B - Basin Boundary Line Segments' /
     +          10x,5x,'F - Rainfall-Runoff Curves')
           endif
c
315   write (iutw,320)
320   format (/ ' Select (<return>-exit): ',$)
c
      read (iutr,'(a)',err=280,end=330) cnum
      resp = cnum(1:1)
      if (ibug.eq.1) write (iud,*) 'in ffmain - iutr=',iutr,
     +   ' resp=',resp
c
      if (resp.eq.' ') go to 110
c
c  fill common blocks with data types
      call btype
c
      if (resp.eq.'G'.or.resp.eq.'g') then
         call mgrid
         go to 280
         else if (resp.eq.'U'.or.resp.eq.'u') then
            call usrinf (icaller)
            go to 280
         else if (resp.eq.'C'.or.resp.eq.'c') then
            go to 110
         else if (resp.eq.'B'.or.resp.eq.'b') then
            isl = 2
            call mbbls (isl,mbx,bx,ibx)
            go to 280
         else if (resp.eq.'F'.or.resp.eq.'f') then
            call mrrcv (cidx,mpo,po)
            go to 280
         endif
c
c  add, change, delete, list parameters
      call mffprm (resp,istat)
      if (istat.eq.-1) go to 315
      go to 280
c
c     -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
c
330   strng=' Program '//pgmnam(1:lenstr(pgmnam))//' completed.'
      write (iutw,'(/a)') strng(1:lenstr(strng))
      if (iupr.ne.iutw) write (iupr,'(/a)') strng(1:lenstr(strng))
c
340   if (iupr.ne.iutw) then
         if (igdbug.gt.0) iud = iutw
         call upclos (iupr,bname,istat)
         endif
c
      stop
c
      end
