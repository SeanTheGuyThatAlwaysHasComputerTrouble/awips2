C MODULE WPDC
C-----------------------------------------------------------------------
C
      SUBROUTINE WPDC (ISTAID,ISTNUM,
     *   NDLYTP,IDLYTP,IPPGEN,IPPPTR,IPCHAR,MDRBOX,IPCPCR,IPPMMT,TEMPCF,
     *   NRRSTP,IRRSTP,NVLPOB,NUMOBS,MNODAY,
     *   IPNTRS,LADDTP,IADDTP,NADDTP,LDELTP,DELTP,NDELTP,ISTAT)
C
C  THIS ROUTINE CHANGES A STATION IN THE PREPROCESSOR DATA BASE.
C  IT CHECKS FOR VALID TYPES AND MAKES SURE THERE IS ROOM FOR EACH.
C  VALID TYPES ARE ENTERED AS LONG AS ONE IS VALID AND THERE IS
C  ROOM FOR AT LEAST ONE OF THEM.
C  AN ARRAY OF ANY NEW TYPES THAT WERE ADDED AND AN ARRAY OF ANY
C  OLD TYPES THAT WERE DELETED ARE RETURNED.
C
C  ARGUMENT LIST:
C
C      NAME      TYPE  I/O   DIM    DESCRIPTION
C      ------    ----  ---   ---    -----------
C      ISTAID     A8    I     2     STATION CHARACTER ID
C      ISTNUM     I     I     1     STATION INTEGER ID
C      NDLYTP     I     I     1     NUMBER OF DAILY TYPES
C      IDLYTP     A4    I   NDLYTP  DAILY DATA TYPES
C      IPPGEN     I     I     1     POINTER TO GEN PARMS ON PPPDB
C      IPPPTR     I     I     3     POINTERS TO PP,TM,PE ON PPPDB
C      IPCHAR     I     I     1     POINTER TO CHARACTERISTICS ON PPPDB
C      MDRBOX     I     I     1     MDRBOX NUMBER OR UNDEF IF NOT PP24
C      IPCPCR     I     I     1     PCPN CORRECTION FACTOR CODE
C      IPPMMT     I     I     1     POINTER TO MEAN MONTHLY TEMPS ON PPP
C      TEMPCF     R     I     2     TEMP CORRECTION FACTORS
C      NRRSTP     I     I     1     NUMBER OF RRS TYPES
C      IRRSTP     A4    I   NRRSTP  RRS TYPES
C      NVLPOB     I     I   NRRSTP  NUMBER OF VALUES PER OBS
C      NUMOBS     I     I   NRRSTP  TYPICAL NUMBER OF OBS
C      MNODAY     I     I   NRRSTP  MINIMUM DAYS OF DATA TO BE RETAINED
C      IPNTRS     I     O   NDLYTP+ POINTERS TO DATA OR RECORD
C                           NRRSTP
C      LADDTP     I     I     1     SIZE OF ARRAY IADDTP
C      IADDTP     I     O   LADDTP  ARRAY OF TYPES ADDED
C      NADDTP     I     O     1     NUMBER OF ENTRIES IN IADDTP
C      LDELTP     I     I     1     SIZE OF DELTP ARRAY
C      DELTP      A4    O   LDELTP  ARRAY OF TYPES DELETED
C      NDELTP     I     O     1     NUMBER OF ENTRIES IN DELTP
C      ISTAT      I     O     1     STATUS CODE:
C                                     0=OK
C                                    >0=ERROR
C
      CHARACTER*4 DELTP(LDELTP)
      CHARACTER*8 STAID
      CHARACTER*8 LDELET/'DELETED '/
      PARAMETER (LSIBUF=128)
      INTEGER*2 ISIBUFN(LSIBUF),ISIBUFO(LSIBUF)
      INTEGER*2 IPTREC(32)
C
      DIMENSION ISTAID(2),IDLYTP(1),IPPPTR(3),TEMPCF(2)
      DIMENSION IRRSTP(1),NVLPOB(1),NUMOBS(1),MNODAY(1),IPNTRS(1)
      DIMENSION IPPDLT(2,3),ITADLT(2,3)
      DIMENSION IADDTP(1)
      PARAMETER (MNDADD=30)
      DIMENSION INDADD(MNDADD)
      DIMENSION IRRSHD(48)
C
      INCLUDE 'uiox'
      INCLUDE 'udebug'
      INCLUDE 'pdbcommon/pddtdr'
      INCLUDE 'pdbcommon/pdsifc'
      INCLUDE 'pdbcommon/pdrrsc'
      INCLUDE 'pdbcommon/pdunts'
      INCLUDE 'pdbcommon/pdhshi'
      INCLUDE 'pdbcommon/pdbdta'
      INCLUDE 'pdbcommon/pdi2max'
      
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/db_pdbrw/RCS/wpdc.f,v $
     . $',                                                             '
     .$Id: wpdc.f,v 1.8 2004/09/22 20:58:11 hank Exp $
     . $' /
C    ===================================================================
C
      DATA IPPDLT/4HPP01,1,4HPP03,3,4HPP06,6/
      DATA ITADLT/4HTA01,1,4HTA03,3,4HTA06,6/
C      
C
      IF (IPDTR.GT.0) WRITE (IOGDB,*) 'ENTER WPDC'
C
      ISTAT=0
      ISTAT3=0
      ISTA14=0
      ISTAT4=0
      ISTAT6=0
C      
      NADDTP=0
      NDELTP=0
      IFINDO=0
      IFINDI=0
      IRSETO=0
      ISAVPP=0
      ISAVTA=0
      ITM24=0
      NEWNUM=0
      LRCDD2=LRCPDD*2
      NHEADW=LHDRRS+NRSTAT
C
      CALL UMEMOV (ISTAID,STAID,2)
C
C  CHECK IF STATION IS DEFINED
      CALL PDFNDR (ISTAID,LSIBUF,IFIND,ISTRECO,ISIBUFO,IFREE,IERR)
      IF (IERR.NE.0) GO TO 650
      IF (IFIND.EQ.0) THEN
         ISTAT=1
         GO TO 660
         ENDIF
C
C  GET OLD STATION NUMBER
      ISTNUMO=ISIBUFO(6)
C      
      IF (ISTNUM.EQ.0.AND.ISTNUMO.EQ.0) GO TO 80
C      
C  CHECK IF STATION HAS STATION NUMBER
      IF (ISTNUM.GT.0) THEN
         CALL PDFNDI (ISTNUM,LSIBUF,IFINDI,ISTRECN,ISIBUFN,IFREEI,IERR)
         IF (IERR.NE.0) GO TO 650
         IF (IFINDI.GT.0) THEN
            IF (ISTNUM.NE.ISTNUMO) THEN
               ISTAT=2
               GO TO 660
               ENDIF
C        CHECK SIF RECORDS NUMBERS
            IF (ISTRECO.NE.ISTRECN) THEN
               ISTAT=2
               GO TO 660
               ENDIF
            ENDIF
         IF (ISTNUM.NE.ISTNUMO) THEN            
C        SET INDICATOR THAT HAVE NEW STATION NUMBER
            NEWNUM=1
            ENDIF
         ENDIF
C
C  CHECK IF STATION HAD STATION NUMBER
      IF (ISTNUMO.GT.0) THEN
         CALL PDFNDI (ISTNUMO,LSIBUF,IFINDO,ISTRECN,ISIBUFN,IFREEO,IERR)
         IF (IERR.NE.0) GO TO 650
         IF (IFINDO.EQ.0) THEN
            WRITE (LP,40) ISTNUMO,ISTAID
40    FORMAT ('0**ERROR** IN WPDC - STATION NUMBER IN SIF RECORD (',I5,
     *   ' NOT FOUND IN INTEGER INDEX.')
            ISTAT=7
            GO TO 660
            ENDIF
         IF (ISTRECO.NE.ISTRECN) THEN
C        SIF RECORD NUMBER ARE NOT THE SAME
            WRITE (LP,50) ISTRECO,ISTRECN
50    FORMAT ('0**ERROR** IN WPDC - SIF RECORD FOR ',
     *   'THE STATION IDENTIFIER (',I5,') ',
     *   'IS NOT THE SAME AS FOR ',
     *   'THE STATION NUMBER (',I5,').')
            ISTAT=7
            GO TO 660
            ENDIF
         IF (ISTNUM.NE.ISTNUMO) THEN
C        SET FLAG TO RESET OLD INTEGER HASH SLOT
            IRSETO=1
            ENDIF
         ENDIF
C
80    CALL UMEMS2 (0,ISIBUFN,1,LSIBUF)
      CALL UMEMOV (ISTAID,ISIBUFN(2),2)
      ISIBUFN(6)=ISTNUM
      ISIBUFN(7)=IPPGEN
C
      NBGISI=11      
      NXTISI=NBGISI
C
C      
      IVALTY=0
      IUPDAT=0
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  PROCESS DAILY TYPES
C
      IF (NDLYTP.EQ.0) GO TO 450
C
      DO 210 I=1,NDLYTP
C     FIND TYPE IN DIRECTORY
         J=IPDCDW(IDLYTP(I))
         IF (J.EQ.0) GO TO 90
C     CHECK IF VALID TYPE FOR CREATE - INVALID IF A WRITE ONLY TYPE AND 
C     NUMBER OF WORDS IS 1
         IF (IDDTDR(4,J).LT.0.AND.IDDTDR(6,J).EQ.1) GO TO 90
         IXD=IPDCKD(IDLYTP(I))
         IF (IXD.NE.0) GO TO 100
C        TYPE NOT FOUND
90          ISTAT3=3
            IPNTRS(I)=-2
            GO TO 210
C     MAKE SURE DATA TYPE HAS STATIONS
100      IF (IDDTDR(16,IXD).EQ.0) GO TO 90
         IF (IXD.GT.MNDADD) THEN
            ISTAT=18
            GO TO 660
            ENDIF
         INDADD(IXD)=0
C     SAVE INPUT TYPE ARRAY SUBSCRIPT
         IDDTDR(24,IXD)=I
C     CHECK IF TYPE WAS IN OLD RECORD - IF SO REUSE THE SLOTS
         IOLDT=IPDFDT(ISIBUFO,IDLYTP(I))
         IF (IOLDT.NE.0) GO TO 110
C     NOT THERE - PUT IN ADD ARRAY AND GET NEW SLOT
         IF (NADDTP.GE.LADDTP) GO TO 120
            NADDTP=NADDTP+1
            IADDTP(NADDTP)=IDLYTP(I)
            IF (IXD.GT.MNDADD) THEN
               ISTAT=18
               GO TO 660
               ENDIF
            INDADD(IXD)=1
            GO TO 130
C     THERE IS AN EMPTY SLOT TO REUSE FOR THIS TYPE - SAVE IT IN WORD 23 
C     OF THE DIRECTORY
C     FIGURE OLD PARM SLOT FROM DATA SLOT - FOR PPVR OR TAVR, THIS WORD 
C     WILL BE LT 0 AND IS ONLY A FLAG THAT THE TYPE WAS THERE, VALUE 
C     WILL BE SET LATER
110      IDDTDR(23,IXD)=((IOLDT-1)/IDDTDR(6,IXD))*IDDTDR(5,IXD)+1

C HANK HERR MADE THIS CHANGE (4/2/04)...........
C     IT TURNS OUT THAT THE COMPUTATION ON THE RIGHT CAN BE TOO NEGATIVE
C     WHEN THIS HAPPENS, I MUST DETECT IT IS TOO NEGATIVE AND THEN FOR
C     IDDTDR(23,IXD) TO BE -1, THUS FORCING THAT THE "VALUE WILL BE SET
C     LATER".
         IHDHVAL=((IOLDT-1)/IDDTDR(6,IXD))*IDDTDR(5,IXD)+1
         IF(IHDHVAL.LT.0) THEN
             write (*,*) '####>> FOUND A NEGATIVE VALUE... ',ISTAID(1),
     +           ',',ISTAID(2),'; ',IHDHVAL,' -- ',IDDTDR(23,IXD)
             IDDTDR(23,IXD)=-1
         ENDIF
C END OF HANK'S CHANGE...........

         GO TO 170
C     LADDTP TOO SMALL
120      ISTA14=14
130      IF (IDDTDR(17,IXD)*IDDTDR(5,IXD).EQ.IDDTDR(18,IXD)) GO TO 140
C     READ THROUGH THE POINTER RECORDS LOOKING FOR AN UNUSED SLOT
         CALL PDCKUU (IXD,J,IDDTDR(23,IXD),IERR)
         IF (IERR.NE.0) GO TO 650
         IF (IDDTDR(23,IXD).NE.0) GO TO 170
C     NO UNUSED SLOT, CHECK FOR ROOM FOR NEW ONE
140      IF (IDDTDR(17,IXD).LT.IDDTDR(16,IXD)) GO TO 160
C        NOT ENOUGH ROOM
150         IPNTRS(I)=0
            IDDTDR(24,IXD)=0
            ISTAT4=4
            GO TO 210
C     GET A NEW SLOT FOR POINTERS - CHECK IF MAXIMUM SLOTS EXCEEDED
160      IF ((IDDTDR(18,IXD)+1).GT.(IDDTDR(16,IXD)*IDDTDR(5,IXD)))
     *      GO TO 150
         IDDTDR(23,IXD)=IDDTDR(18,IXD)+1
170      IF (IPDDB.GT.0) WRITE (IOGDB,180) (IDDTDR(K,IXD),K=1,24)
180   FORMAT (' ENTERING TYPE: ',I4,1X,2A2,1X,21I4)
C     IF VR TYPE, CHECK THAT THERE IS ROOM FOR DATA
         IF (IDDTDR(6,IXD).GT.0.OR.IDDTDR(22,IXD).NE.0.OR.
     *      IDDTDR(23,IXD).NE.0) GO TO 200
         NDATA=IDDTDR(6,J)
         MAXDAT=IDDTDR(21,IXD)*LRCDD2
         IF (IPDDB.GT.0) WRITE (IOGDB,190) NDATA,MAXDAT,IDDTDR(2,J),
     *      IDDTDR(3,J),IDDTDR(19,IXD)
190   FORMAT (' NDATA=',I8,' MAXDAT=',I8,' TYPE=',2A2,' DTAPTR=',I8)
         IF (NDATA+IDDTDR(19,IXD).GT.MAXDAT) GO TO 150
200      IF (IDDTDR(22,IXD).EQ.0) IDDTDR(22,IXD)=IDDTDR(19,IXD)+1
         IF (IPDDB.GT.0) WRITE (IOGDB,180) (IDDTDR(K,IXD),K=1,24)
C     INCREMENT VALID TYPE COUNTER AND SET POINTER IN INPUT TYPE ARRAY
         IVALTY=IVALTY+1
         IPNTRS(I)=IDDTDR(23,IXD)
210      CONTINUE
C
C  CHECK PCPN
      IPPVR=IPDCKD('PPVR')
      IF (IDDTDR(24,IPPVR).EQ.0) GO TO 230
      IPP24=IPDCKD('PP24')
      IF (IDDTDR(24,IPP24).EQ.0) GO TO 220
C
C  USE THE 24 HOUR PINTER TO GET POINTER TO LT24 HOUR POINTERS
C  24 HOUR POINTER IS IS SOT 23, NEED TO READ THE RECORD TO GET IT
C  CHECK IF HAD PPVR IN OLD RECORD, IF 23 IS GE ZERO DIDNT EXECUTE LINE
C  AT STATEMENT 26 WHICH PUT IN NEGATIVE NUMBER FOR PPVR
      IF (IDDTDR(23,IPPVR).GE.0) GO TO 230
      ISLOT=IDDTDR(23,IPP24)+2
      NREC=IUNRCD(ISLOT,LRCDD2)-1
      JSLOT=ISLOT-(NREC*LRCDD2)
      IREC=NREC+IDDTDR(14,IPP24)
      CALL UREADT (KPDDDF(IDDTDR(4,IPP24)),IREC,IPTREC,IERR)
      IF (IERR.NE.0) GO TO 650
      IDDTDR(23,IPPVR)=IPTREC(JSLOT)
      IPNTRS(IDDTDR(24,IPPVR))=IPTREC(JSLOT)
      GO TO 230
C
C  HAVE A PPVR BUT NO PP24
220   ISTAT6=6
      I=IDDTDR(24,IPPVR)
      IPNTRS(I)=0
      IVALTY=IVALTY-1
      IDDTDR(24,IPPVR)=0
C
C  CHECK TEMP
230   ITAVR=IPDCKD('TAVR')
      IF (IDDTDR(24,ITAVR).EQ.0) GO TO 250
      ITM24=IPDCKD('TM24')
      IF (IDDTDR(24,ITM24).EQ.0) GO TO 240
C
C  USE THE 24 HOUR POINTER TO GET POINTER TO LT24 HOUR POINTERS.
C  24 HOUR POINTER IS IS SLOT 23, NEED TO READ THE RECORD TO GET IT.
C  CHECK IF HAD TAVR IN OLD RECORD. IF SLOT 23 IS GE, ZERO DID NOT PUT 
C  IN NEGATIVE NUMBER FOR TAVR.
      IF (IDDTDR(23,ITAVR).GE.0) GO TO 250
      ISLOT=IDDTDR(23,ITM24)+2
      NREC=IUNRCD(ISLOT,LRCDD2)-1
      JSLOT=ISLOT-(NREC*LRCDD2)
      IREC=NREC+IDDTDR(14,ITM24)
      CALL UREADT (KPDDDF(IDDTDR(4,ITM24)),IREC,IPTREC,IERR)
      IF (IERR.NE.0) GO TO 650
      IDDTDR(23,ITAVR)=IPTREC(JSLOT)
      IPNTRS(IDDTDR(24,ITAVR))=IPTREC(JSLOT)
      GO TO 250
C
C  HAVE A TAVR BUT NO TM24
240   ISTAT6=6
      I=IDDTDR(24,ITAVR)
      IPNTRS(I)=0
      IVALTY=IVALTY-1
      IDDTDR(24,ITAVR)=0
C
C  CHECK FUTURE TEMP
250   ITF24=IPDCKD('TF24')
      IF (IDDTDR(24,ITF24).EQ.0) GO TO 260
      IF (ITM24.EQ.0) ITM24=IPDCKD('TM24')
      IF (IDDTDR(24,ITM24).NE.0) GO TO 260
C
C  HAVE TF24 BUT NO TM24
      ISTAT6=6
      I=IDDTDR(24,ITF24)
      IPNTRS(I)=0
      IVALTY=IVALTY-1
      IDDTDR(24,ITF24)=0
C
C  CHECK IF ANY VALID TYPES
260    IF (IVALTY.EQ.0) GO TO 450
C
C  CHECK ALL DAILY TYPES
      DO 440 I=1,NMDTYP
C     CHECK IF NEED TO UPDATE POINTERS      
         IF (IDDTDR(24,I).EQ.0) GO TO 440
C     GET POINTER RECORD
         ISLOT=IDDTDR(23,I)
         IDTAPT=((ISLOT-1)/IDDTDR(5,I))*IDDTDR(6,I)+1
         IREC=IUNRCD(ISLOT,LRCDD2)+IDDTDR(14,I)-1
         IFILE=IDDTDR(4,I)
         CALL UREADT (KPDDDF(IFILE),IREC,IPTREC,IERR)
         IF (IERR.NE.0) GO TO 650
C     JSLOT IS THE POINTER WITHIN ONE RECORD (1-LRCDD2)
         JSLOT=ISLOT-(IREC-IDDTDR(14,I))*LRCDD2
         IF (IPDDB.GT.0) WRITE (IOGDB,*) 
     *      ' ISLOT=',ISLOT,
     *      ' IREC=',IREC,
     *      ' IFILE=',IFILE,
     *      ' JSLOT=',JSLOT,
     *      ' '
C     CHECK PP24 POINTERS
         CALL UCMPAR (IDDTDR(2,I),'PP24',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IVALUE=IPPPTR(1)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=IPCHAR
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        SAVE OLD PPVR POINTER IN CASE NEED TO RESET
            ISAVPP=IPTREC(JSLOT)
            IVALUE=IDDTDR(23,IPPVR)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            IF (IPTREC(JSLOT).EQ.0) THEN
               IVALUE=-IPPGEN
               CALL PDCKI2 (IVALUE,IERR)
               IF (IERR.NE.0) GO TO 655
               IPTREC(JSLOT)=IVALUE
               ENDIF
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=IPCPCR
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=MDRBOX
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            ISIBUFN(8)=IDTAPT
            GO TO 410
            ENDIF
C     CHECK IF TM24 POINTERS
         CALL UCMPAR (IDDTDR(2,I),'TM24',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IVALUE=IPPPTR(2)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=IPPMMT
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        SAVE OLD TAVR POINTER IN CASE NEED TO RESET
            DP1=0.5
            ISAVTA=IPTREC(JSLOT)
            IVALUE=IDDTDR(23,ITAVR)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=TEMPCF(1)*100.0+SIGN(DP1,TEMPCF(1))
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=TEMPCF(2)*100.0+SIGN(DP1,TEMPCF(2))
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            ISIBUFN(9)=IDTAPT
            GO TO 410
            ENDIF
C     CHECK IF EA24 POINTERS            
         CALL UCMPAR (IDDTDR(2,I),'EA24',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IVALUE=IPPPTR(3)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PDUPSI ('EA24',IDTAPT,LSIBUF,ISIBUFN,NXTISI,IERR)
            IF (IERR.GT.0) GO TO 645
            GO TO 410
            ENDIF
C     CHECK IF PPVR POINTERS
         CALL UCMPAR (IDDTDR(2,I),'PPVR',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IVALUE=IPPGEN
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
            IVALUE=IDDTDR(23,IPP24)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        GET TIME INTERVAL FOR PPVR
            KK=IDDTDR(24,I)
            DO 310 K=1,3
               IF (IDLYTP(KK).EQ.IPPDLT(1,K)) GO TO 320
310            CONTINUE
            ISTAT3=3
            GO TO 440
320         IVALUE=IPPDLT(2,K)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            IDELTA=IPPDLT(2,K)
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        FIND OLD SLOT AGAIN TO CHECK IF CAN REUSE
            IDTAPT=IPDFDT(ISIBUFO,IDLYTP(KK))
            IF (IDTAPT.EQ.0) IDTAPT=IDDTDR(22,I)
            IVALUE=IDTAPT
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PDUPSI (IDLYTP(KK),IDTAPT,LSIBUF,ISIBUFN,NXTISI,IERR)
            IF (IERR.GT.0) GO TO 645
            GO TO 410
            ENDIF
C     CHECK IF PPVR POINTERS
         CALL UCMPAR (IDDTDR(2,I),'TAVR',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IVALUE=IDDTDR(23,ITM24)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        GET TIME INTERVAL FOR TAVR
            KK=IDDTDR(24,I)
            DO 350 K=1,3
               IF (IDLYTP(KK).EQ.ITADLT(1,K)) GO TO 360
350            CONTINUE
            ISTAT3=3
            GO TO 440
360         IVALUE=ITADLT(2,K)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            IDELTA=ITADLT(2,K)
            CALL PGTNXP (I,JSLOT,IPTREC,IREC,IERR)
            IF (IERR.NE.0) GO TO 650
C        FIND OLD SLOT AGAIN TO CHECK IF CAN REUSE
            IDTAPT=IPDFDT(ISIBUFO,IDLYTP(KK))
            IF (IDTAPT.EQ.0) IDTAPT=IDDTDR(22,I)
            IVALUE=IDTAPT
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PDUPSI (IDLYTP(KK),IDTAPT,LSIBUF,ISIBUFN,NXTISI,IERR)
            IF (IERR.GT.0) GO TO 645
            GO TO 410
            ENDIF
C     CHECK IF TF24 POINTERS
         CALL UCMPAR (IDDTDR(2,I),'TF24',1,IMATCH)
         IF (IMATCH.EQ.0) THEN
            IF (ITM24.EQ.0) ITM24=IPDCKD('TM24')
            IVALUE=IDDTDR(23,ITM24)
            CALL PDCKI2 (IVALUE,IERR)
            IF (IERR.NE.0) GO TO 655
            IPTREC(JSLOT)=IVALUE
            CALL PDUPSI ('TF24',IDTAPT,LSIBUF,ISIBUFN,NXTISI,IERR)
            IF (IERR.GT.0) GO TO 645
            GO TO 410
            ENDIF
C     INVALID TYPE
         ISTAT3=3
         IF (IPDDB.GT.0) WRITE (IOGDB,400) (IDDTDR(L,I),L=1,24)
400   FORMAT (' INVALID TYPE IN DIRECTORY'/
     *   I4,1X,2A2,1X,21I4)
         GO TO 440
C     WRITE POINTER RECORD
410      CALL UWRITT (KPDDDF(IFILE),IREC,IPTREC,IERR)
         IF (IERR.NE.0) GO TO 650
C     UPDATE POINTERS
         IF (IDDTDR(6,I).GT.0) GO TO 420
         IF (IDTAPT.LT.IDDTDR(19,I)) GO TO 430
         IDDTDR(19,I)=IDDTDR(19,I)+24/IDELTA
         IF (ISLOT.LT.IDDTDR(18,I)) GO TO 430
         IDDTDR(18,I)=IDDTDR(18,I)+IDDTDR(5,I)
         GO TO 430
C     REGULAR DATA - NOT VARIABLE TIME INTERVAL
C     IF REUSING PARM AND DATA RECORD, DO NOT UPDATE LAST USED
420      IF (ISLOT.LE.IDDTDR(18,I)) GO TO 430
            IDDTDR(18,I)=IDDTDR(18,I)+IDDTDR(5,I)
            IDDTDR(19,I)=IDDTDR(19,I)+IDDTDR(6,I)            
430      IF (INDADD(I).EQ.1) THEN
            IDDTDR(17,I)=IDDTDR(17,I)+1
            IF (IPDDB.GT.0) WRITE (IOGDB,*) 'IN WPDC - I=',I,
     *         ' IDDTDR(17,I)=',IDDTDR(17,I)
            ENDIF
440      CONTINUE
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  PROCESS RRS TYPES
C
450   IRX=NDLYTP+1
C
      ICGRRS=0
C
      IF (NRRSTP.EQ.0) GO TO 580
C
      DO 570 I=1,NRRSTP
C     CHECK FOR VALID RRS TYPE
         IXD=IPDCKR(IRRSTP(I))
         IF (IXD.NE.0) GO TO 470
460         IPNTRS(IRX)=-2
            ISTAT3=3
            GO TO 560
470      NWORDS=NVLPOB(I)*NUMOBS(I)+NHEADW
         NREC=IUNRCD(NWORDS,LRCPDR)
C     CHECK IF RRS TYPE ALREADY DEFINED
         IREC=IPDFDT(ISIBUFO,IRRSTP(I))
CMGM 4/2002 THE RRS RECORD NUMBER (IREC) MAY BE STORED IN THE ISIBUF
C    ARRAY AS A NEGATIVE NUMBER. THIS ALLOWS TWICE AS MANY RECORD 
C    NUMBERS IN THE I2 ARRAY. CONVERT IREC TO A POSITIVE RECORD NUMBER
C    IREC2 TO READ/WRITE (UREADT/UWRITT) THE KPDRRS FILE.
CMGM
         IREC2=IREC
         IF(IREC2.LT.0)IREC2=IREC2+2*I2MAX
         IF (IREC.EQ.0) GO TO 480
C     CHECK IF CAN USE SAME SPACE
         CALL UREADT (KPDRRS,IREC2,IRRSHD,IERR)
         IF (IERR.NE.0) GO TO 650
C     CHECK NEW AND OLD NUMBER OF VALUES PER OBSERVATION
         IF (NVLPOB(I).NE.IRRSHD(14)) GO TO 460
C     CHECK IF NEW RRS RECORD IS BIGGER THAN OLD
         IF (NUMOBS(I).LE.IRRSHD(7)) GO TO 550
C        NOT ENOUGH ROOM - MUST ADD NEW RECORD - CHECK SPACE
            IF (LXRRSR+NREC.GT.MXRRSF) GO TO 510
C        DELETE OLD RECORD            
            CALL UMEMOV (LDELET,IRRSHD(2),2)
            CALL UWRITT (KPDRRS,IREC2,IRRSHD,IERR)
            IF (IERR.NE.0) GO TO 650
            IREC=0
            ICGRRS=1
            GO TO 520
480      IF (NADDTP.GE.LADDTP) GO TO 490
            NADDTP=NADDTP+1
            IADDTP(NADDTP)=IRRSTP(I)
            ICGRRS=1
            GO TO 500
490      ISTA14=14
500      IF (LXRRSR+NREC.LE.MXRRSF) GO TO 520
510      ISTAT4=4
         IPNTRS(IRX)=0
         GO TO 560
C     THERE IS ROOM
520      CALL UMEMST (0,IRRSHD,48)
C     CHECK IF NUMBER OF WORDS AND NUM OBS SHOULD BE INCREASED BECAUSE
C     THERE ARE MORE WORDS IN RECORD
         NAVAIL=NREC*LRCPDR-NHEADW
         NOB=NAVAIL/NVLPOB(I)
         IF (NOB.LE.NUMOBS(I)) GO TO 530
C        RESET NUMBER OF WORDS
            NWORDS=NVLPOB(I)*NOB+NHEADW
530      IRRSHD(1)=NWORDS
         CALL UMEMOV (ISTAID,IRRSHD(2),2)
         IRRSHD(4)=ISTNUM
         IRRSHD(5)=IRRSTP(I)
         IRRSHD(6)=MNODAY(I)
         IRRSHD(7)=NOB
         IRRSHD(14)=NVLPOB(I)
         IRRSHD(17)=NRSTAT
         IF (IREC.NE.0) GO TO 540
         IREC=LXRRSR+1
	 IREC2=IREC
         LXRRSR=LXRRSR+NREC
540      NRECH=IUNRCD(NHEADW,LRCPDR)
C     WRITES RECORD TO FILE
         CALL WVLRCD (KPDRRS,IREC,NRECH,IRRSHD,LRCPDR,IERR)
         IF (IERR.NE.0) GO TO 650
CMGM  4/2002 IF IREC IS GREATER THEN I2MAX THEN CONVERT IREC TO A 
C     NEGATIVE NUMBER TO STORE IN THE ISIBUF ARRAY (AN I2 ARRAY). 
C     IF IREC IS GREATER THEN 2*I2MAX THEN YOU HAVE USED ALL POSITIVE 
C     AND NEGATIVE NUMBERS IN THE ISIBUF ARRAY AND CAN NOT ADD ANY 
C     MORE RRS RECORDS. 
C     PDUPSI WRITES THE RECORD TO AN I2 ARRAY (IREC LIMITED TO I2)
         IF(IREC2.GT.2*I2MAX)GO TO 657
550      IF(IREC2.GT.I2MAX)IREC2=IREC2-2*I2MAX
         CALL PDUPSI (IRRSTP(I),IREC2,LSIBUF,ISIBUFN,NXTISI,IERR)
         IF (IERR.GT.0) GO TO 645
         IPNTRS(IRX)=-1
         IVALTY=IVALTY+1
C     SET SIZE OF LARGEST RRS RECORD IF THIS IS BIGGEST
         N=NREC*LRCPDR
         IF (N.GT.MAXRSZ) MAXRSZ=N
560      IRX=IRX+1
570      CONTINUE
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C  CHECK IF ANY VALID TYPES
580   IF (IVALTY.EQ.0) THEN
         IF (ISTAT3.NE.0) ISTAT=3
         IF (ISTAT6.NE.0) ISTAT=7
         IF (ISTAT4.NE.0) ISTAT=5
         GO TO 660
         ENDIF
C
C  SOME VALID TYPES
      IF (ISTAT.NE.0) GO TO 660
      IF (ISTAT3.NE.0) ISTAT=3
      IF (ISTAT4.NE.0.AND.ISTAT.EQ.0) ISTAT=4
      IF (ISTAT6.NE.0.AND.ISTAT.EQ.0) ISTAT=6
      IF (ISTAT.NE.0) THEN
         IF (ISTAT3.NE.0.AND.ISTAT4.NE.0.AND.ISTAT6.EQ.0) ISTAT=9
         IF (ISTAT3.NE.0.AND.ISTAT4.EQ.0.AND.ISTAT6.NE.0) ISTAT=10
         IF (ISTAT3.EQ.0.AND.ISTAT4.NE.0.AND.ISTAT6.NE.0) ISTAT=11
         IF (ISTAT3.NE.0.AND.ISTAT4.NE.0.AND.ISTAT6.NE.0) ISTAT=12
         IF (ISTAT.EQ.0) ISTAT=ISTA14
         ENDIF
C
C  SET LENGTH OF SIF ARRAY
      ISIBUFN(1)=NXTISI-1
C
C  CHECK IF NEED TO COPY PP24 STATISTICS FROM OLD RECORD
      IF (ISIBUFO(8).NE.0.AND.ISIBUFN(8).NE.0) THEN
         IBEG=NBGISI+ISIBUFO(10)*3
         ICHK=IBEG+NDSTAT-1
         IF (ICHK.GT.ISIBUFO(1)) THEN
            WRITE (LP,625) STAID,ISIBUFO(1),ICHK
625   FORMAT ('0*** WARNING - IN WPDC - STATION ',A,' HAS PP24 DATA ',
     *   'BUT NUMBER OF WORDS IN SIF RECORD (',I2,') IS LESS THAN ',
     *   'EXPECTED (',I2,').')
            CALL UWARN (LP,0,-1)
            IUPDAT=1
            ELSE
               CALL UMEMOV (ISIBUFO(IBEG),ISIBUFN(NXTISI),NDSTAT)
            ENDIF
         ENDIF
C
C  CHECK IF NEED TO UPDATED RECORD LENGTH FOR PP24 STATISTICS
      IF (ISIBUFN(8).NE.0) ISIBUFN(1)=ISIBUFN(1)+NDSTAT
C      
C  CHECK TYPES IN OLD AND NEW DEFINITION TO GET DELETED TYPES
      CALL PDCOLD (ISIBUFO,ISIBUFN,LDELTP,DELTP,NDELTP,
     *   ISAVPP,ISAVTA,IERR)
      IF (ISTAT.EQ.0.AND.IERR.NE.0) ISTAT=8
C         
C  CHECK IF ANY CHANGES MADE         
      IF (ISTNUM.EQ.ISTNUMO.AND.
     *    NADDTP.EQ.0.AND.
     *    NDELTP.EQ.0.AND.
     *    ICGRRS.EQ.0.AND.
     *    IUPDAT.EQ.0) THEN
         ISTAT=16
         GO TO 660
         ENDIF
C
C  ENTER NEW STATION NUMBER IN HASH ARRAY
      IF (NEWNUM.EQ.1) IPDHSI(IFREEI)=ISTRECO
C
C  CHECK IF NEED TO RESET NUMERIC ID IN INTEGER HASH ARRAY
      IF (IFINDO.NE.0.AND.IRSETO.EQ.1) IPDHSI(IFINDO)=-1
C
C  COMPUTE NUMBER OF NEW AND OLD SIF RECORDS
      LRCPD2=LRCPDI*2
      NWORDN=ISIBUFN(1)
      NWORDO=ISIBUFO(1)
      IPOS=NWORDO+1
      IF (ISIBUFO(IPOS).GT.0) NWORDO=ISIBUFO(IPOS)
      NRECN=IUNRCD(NWORDN,LRCPD2)
      NRECO=IUNRCD(NWORDO,LRCPD2)
C      
C  CHECK IF SIF RECORD CAN GO IN SAME PLACE
      IF (NRECN.LE.NRECO) THEN
         IPOS=NWORDN+1
         IF (NRECN.LT.NRECO) THEN
C        SET NUMBER OF WORDS IN OLD RECORD
            IF (ISIBUFN(IPOS).EQ.0) THEN
               ISIBUFN(IPOS)=NWORDO
               ENDIF
            ENDIF
         IF (NRECN.EQ.NRECO) THEN
C        RESET NUMBER OF WORDS IN OLD RECORD
            IF (ISIBUFN(IPOS).GT.0) ISIBUFN(IPOS)=0
            ENDIF
         CALL WVLRCD (KPDSIF,ISTRECO,NRECO,ISIBUFN,LRCPDI,IERR)
         IF (IERR.NE.0) GO TO 650
         GO TO 660
         ENDIF
C         
C  WRITE NEW SIF RECORD
      IF (IPDDB.GT.0) WRITE (IOGDB,*) 'IN WPDC - STAID=',STAID,
     *   ' NWORDO=',NWORDO,' NWORDN=',NWORDN
      CALL PDPUTR (ISIBUFN,IFIND,IFINDI,IERR)
      IF (IERR.EQ.0) GO TO 630
      IF (IERR.EQ.1) GO TO 650
      IF (IERR.EQ.2) ISTAT=15      
      GO TO 660
C
C  MARK OLD RECORD DELETED
630   CALL UMEMOV (LDELET,ISIBUFO(2),2)
      CALL UWRITT (KPDSIF,ISTRECO,ISIBUFO,IERR)
      IF (IERR.NE.0) GO TO 650
      GO TO 660
C
C  SIF ARRAY TOO SMALL
645   ISTAT=17
      GO TO 660
C
C  READ OR WRITE ERROR
650   ISTAT=13
      GO TO 660
C
C  INTEGER*4 VALUE CAN NOT BE STORED AS INTEGER*2
655   ISTAT=19
      GO TO 660
C
C  RRS RECORD NUMBER GREATER THEN 2*I2MAX (EXCEEDED ALL AVAILABLE 
C  POSITIVE AND NEGATIVE RECORD NUMBERS)
657   ISTAT=20
      GO TO 660      
C
C  RESET VARIABLES IN COMMON BLOCK
660   DO 670 I=1,NMDTYP
         IDDTDR(22,I)=0
         IDDTDR(23,I)=0
         IDDTDR(24,I)=0
670      CONTINUE
C
      IF (IPDTR.GT.0) WRITE (IOGDB,680) ISTAID,ISTNUM,ISTAT
680   FORMAT (' EXIT WPDC - ',
     *   'ISTAID=',2A4,3X,'ISTNUM=',I5,3X,'ISTAT=',I2)
C
      RETURN
C
      END
