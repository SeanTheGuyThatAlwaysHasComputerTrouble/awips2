C MEMBER UDTYPE
C-----------------------------------------------------------------------
C
      SUBROUTINE UDTYPE (SRCH,MTYPE,NTYPE,TYPE,DIMN,UNIT,MISS,
     *   NVAL,TIME,NADD,IWRT,ISTAT)
C
C
C  ROUTINE UDTYPE READS A FILE CONTAINING THE VALID NWSRFS DATA TYPE
C  CODES AND THE ATTRIBUTES ASSOCIATED WITH EACH TYPE.
C
C
C  INPUT ARGUMENTS:
C
C       SRCH  - FOUR CHARACTER SEARCH CODE
C                 'ALL'  = RETURN ALL DATA TYPES
C                 'CALB' = RETURN ALL CALIBRATION SYSTEM DATA TYPES
C                 'FCST' = RETURN ALL FORECAST SYSTEM DATA TYPES
C                 'BOTH' = RETURN ALL DATA TYPES USED IN BOTH THE
C                          CALIBRATION AND FORECAST SYSTEMS
C       MTYPE - MAXIMUM NUMBER OF DATA TYPES THAT CAN BE STORED IN
C               CALLING PROGRAM
C
C
C  OUTPUT ARGUMENTS:
C
C       NTYPE - NUMBER OF DATA TYPES FOUND
C       TYPE  - VALID DATA TYPE CODES (4-CHARACTER)
C       DIMN  - DIMENSION CODE FOR EACH DATA TYPE (4-CHARACTER).
C               IF DIMN(1)='NONE' WHEN UDTYPE IS CALLED, ARRAY WILL NOT

C               BE FILLED.
C       UNIT  - CODE FOR THE STANDARD FORECAST SYSTEM INTERNAL UNITS
C               FOR EACH DATA TYPE (4-CHARACTER).
C               IF UNIT(1)='NONE' WHEN UDTYPE IS CALLED, ARRAY WILL NOT

C               BE FILLED.
C       MISS  - MISSING DATA INDICATOR FOR EACH DATA TYPE.
C               IF MISS(1)=-99 WHEN UDTYPE IS CALLED, ARRAY WILL NOT
C               BE FILLED. IF FILLED, VALUES ARE AS FOLLOWS:
C                0 = NO MISSING DATA ALLOWED
C                1 = MISSING DATA ALLOWED
C       NVAL  - NUMBER OF VALUES PER TIME INTERVAL FOR EACH DATA TYPE
C               IF NVAL(1)=-99 WHEN UDTYPE IS CALLED, ARRAY WILL NOT
C               BE FILLED. IF FILLED, VALUES ARE AS FOLLOWS:
C               >-1= NUMBER OF VALUES
C               -1 = NUMBER MAY VARY
C       TIME  - CODE FOR TIME SCALE OF EACH DATA TYPE (4-CHARACTER).
C               IF TIME(1)='NONE' WHEN UDTYPE IS CALLED, ARRAY WILL NOT

C               BE FILLED.
C       NADD  - NUMBER OF PIECES OF ADDITIONAL INFORMATION THAT ARE
C               ASSOCIATED WITH EACH DATA TYPE.
C               IF NADD(1)=-99 WHEN UDTYPE IS CALLED, ARRAY WILL NOT
C               BE FILLED.
C       IWRT  - INDICATOR SPECIFYING WHICH COMPONENT CAN WRITE EACH
C               DATA TYPE.
C               IF IWRT(1)=-99 WHEN UDTYPE IS CALLED, ARRAY WILL NOT
C               BE FILLED. IF FILLED, VALUES ARE AS FOLLOWS:
C               -1 = NOT DEFINED
C                0 = PREPROCESSOR
C                1 = FORECAST
C       ISTAT - STATUS INDICATOR
C                0 = NO ERROR
C                1 = MAXIMUM DATA TYPES EXCEEDED
C                2 = INVALID SEARCH CODE
C                3 = ERROR IN DECODING INPUT FILE
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      CHARACTER*2 CODE1,CODE2
      CHARACTER*2 UNIT1,UNIT2
      CHARACTER*4 SRCH
      CHARACTER*4 APPL,XFCST,XCALB
      CHARACTER*4 XTYPE,XDIMN,XUNIT,XTIME,XMISS,XWRT
      CHARACTER*4 TYPE(1),DIMN(1),UNIT(1),TIME(1)
      CHARACTER*4 TYPE1,TYPE2,TYPE3,TYPE4
      CHARACTER*8 TMBR
      CHARACTER*8 DDNAME/' '/
      CHARACTER*8 MBR/'DATATYPE'/
      CHARACTER*8 SEQ1,SEQ2,SEQ3,SEQ4
      CHARACTER*20 DESC1,DESC2,DESC3
      CHARACTER*72 CARD
      CHARACTER*80 REC
      DIMENSION MISS(1),NVAL(1),NADD(1),IWRT(1)
C
      INCLUDE 'uiox'
      INCLUDE 'ucmdbx'
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/calb/src/gen/RCS/udtype.f,v $
     . $',                                                             '
     .$Id: udtype.f,v 1.1 1995/09/17 19:51:21 dws Exp $
     . $' /
C    ===================================================================
C
C
C
      IF (ICMTRC.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,150)
         ENDIF
C
      ISTAT=0
C
      NTYPE=0
      NTYPEA=0
      NUMREC=0
C
C  CHECK FOR VALID SEARCH CODE
      IF (SRCH.NE.'ALL'.AND.SRCH.NE.'BOTH'.AND.
     *    SRCH.NE.'CALB'.AND.SRCH.NE.'FCST') THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,260) SRCH
         ISTAT=2
         GO TO 120
         ENDIF
C
C  CHECK FOR INDICATOR NOT TO FILL ARRAYS
      IDIMN=1
      IF (DIMN(1).EQ.'NONE') IDIMN=0
      IF (ICMDBG.GT.1.AND.IDIMN.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'DIMN'
         ENDIF
      IUNIT=1
      IF (UNIT(1).EQ.'NONE') IUNIT=0
      IF (ICMDBG.GT.1.AND.IUNIT.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'UNIT'
         ENDIF
      IMISS=1
      IF (MISS(1).EQ.-99) IMISS=0
      IF (ICMDBG.GT.1.AND.IMISS.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'MISS'
         ENDIF
      INVAL=1
      IF (NVAL(1).EQ.-99) INVAL=0
      IF (ICMDBG.GT.1.AND.INVAL.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'NVAL'
         ENDIF
      ITIME=1
      IF (TIME(1).EQ.'NONE') ITIME=0
      IF (ICMDBG.GT.1.AND.ITIME.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'TIME'
         ENDIF
      INADD=1
      IF (NADD(1).EQ.-99) INADD=0
      IF (ICMDBG.GT.1.AND.INADD.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'NADD'
         ENDIF
      IIWRT=1
      IF (IWRT(1).EQ.-99) IIWRT=0
      IF (ICMDBG.GT.1.AND.IIWRT.EQ.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,180) 'IWRT'
         ENDIF
C
      DO 10 I=1,MTYPE
         TYPE(I)='----'
         IF (IDIMN.EQ.1) DIMN(I)='----'
         IF (IUNIT.EQ.1) UNIT(I)='----'
         IF (IMISS.EQ.1) MISS(I)=-1
         IF (INVAL.EQ.1) NVAL(I)=-1
         IF (ITIME.EQ.1) TIME(I)='----'
         IF (INADD.EQ.1) NADD(I)=-1
         IF (IIWRT.EQ.1) IWRT(I)=-1
10       CONTINUE
C
C  CHECK IF DATA SET IS ALLOCATED
      IPRERR=1
      CALL UDDNST (DDNAME,LSYS,IPRERR,IERR)
      IF (IERR.GT.0) THEN
         ISTAT=1
         GO TO 140
         ENDIF
C
      IPRERR=0
      IF (ICMDBG.GT.3) IPRERR=1
      TMBR=MBR
C
C  READ DATA TYPE FILE
20    CALL URDPDS (DDNAME,TMBR,IPRERR,REC,LRECL,NUMREC,IFLAG,IRCPDS)
      IF (ICMDBG.GT.0) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,160) REC
         ENDIF
      IF (IRCPDS.EQ.0.OR.IRCPDS.EQ.2) GO TO 30
         CALL UEROR (LP,1,-1)
         WRITE (LP,170) IRCPDS
         GO TO 130
C
C  CHECK FOR BLANK RECORD
30    IF (REC(1:72).EQ.' ') THEN
         IF (IRCPDS.EQ.2) GO TO 130
         GO TO 20
         ENDIF
C
C  CHECK FOR COMMENT CARD
      IF (REC(1:1).EQ.'*'.OR.REC(1:1).EQ.'$') THEN
         IF (ICMDBG.GT.0) THEN
            CALL SUBSTR (REC,1,72,CARD,1)
            CALL SUBSTR (REC,73,LEN(SEQ1),SEQ1,1)
            CALL ULINE (ICMPRU,1)
            WRITE (ICMPRU,190) SEQ1,CARD
            ENDIF
         IF (IRCPDS.EQ.2) GO TO 130
         GO TO 20
         ENDIF
C
C  MOVE DATA FROM RECORD INTO VARIABLES
      CALL SUBSTR (REC,1,4,TYPE1,1)
      IF (ICMDBG.GT.1) THEN
         CALL SUBSTR (REC,6,20,DESC1,1)
         CALL SUBSTR (REC,26,20,DESC2,1)
         CALL SUBSTR (REC,46,20,DESC3,1)
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,200) SEQ1,TYPE1,DESC1,DESC2,DESC3
         ENDIF
C
C  READ TYPE, DIMENSION, SPACE, TIME, AND APPLICATION CODE AND NUMBER
C  OF VALUES PER TIME INTERVAL
40    CALL URDPDS (DDNAME,TMBR,IPRERR,REC,LRECL,NUMREC,IFLAG,IRCPDS)
      IPRERR=1
      CALL SUBSTR (REC,1,4,TYPE2,1)
      CALL SUBSTR (REC,6,4,XDIMN,1)
      CALL SUBSTR (REC,11,4,SPACE,1)
      CALL SUBSTR (REC,16,4,XTIME,1)
      CALL SUBSTR (REC,21,4,APPL,1)
      CALL UFA2I (REC,27,1,NVALX,IPRERR,LP,IERR)
      CALL SUBSTR (REC,73,LEN(SEQ2),SEQ2,1)
      IF (ICMDBG.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,210) SEQ2,TYPE2,XDIMN,SPACE,
     *      XTIME,APPL,NVALX
         ENDIF
      IF (TYPE1.NE.TYPE2) THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,220) TYPE2,SEQ2,TYPE1,SEQ1
         ISTAT=3
         ENDIF
      IF (APPL.NE.'CALB'.AND.APPL.NE.'FCST'.AND.APPL.NE.'BOTH') THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,230) APPL,TYPE1,SEQ2
         ISTAT=3
         ENDIF
C
      IF (APPL.NE.'FCST'.AND.APPL.NE.'BOTH') GO TO 60
C
C  READ TYPE, APPLICATION, STANDARD UNITS, MISSING DATA, AND PROCESS
C  CODES FOR FORECAST SYSTEM
      IPRERR=0
      CALL URDPDS (DDNAME,TMBR,IPRERR,REC,LRECL,NUMREC,IFLAG,IRCPDS)
      CALL SUBSTR (REC,1,4,TYPE3,1)
      CALL SUBSTR (REC,6,4,XFCST,1)
      CALL SUBSTR (REC,11,4,XUNIT,1)
      CALL SUBSTR (REC,16,4,XMISS,1)
      CALL SUBSTR (REC,21,4,XWRT,1)
      IPRERR=1
      CALL UFA2I (REC,27,1,NADDX,IPRERR,LP,IERR)
      CALL SUBSTR (REC,73,LEN(SEQ3),SEQ3,1)
      IF (ICMDBG.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,240) SEQ3,TYPE3,XFCST,XUNIT,
     *      XMISS,XWRT,NADDX
         ENDIF
      IF (TYPE1.NE.TYPE3) THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,220) TYPE3,SEQ3,TYPE1,SEQ2
         ISTAT=3
         ENDIF
      IF (XFCST.NE.'FCST') THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,230) XFCST,TYPE1,SEQ3
         ISTAT=3
         ENDIF
C
60    IF (APPL.NE.'CALB'.AND.APPL.NE.'BOTH') GO TO 70
C
C  READ TYPE, APPLICATION, UNITS, AND STANDARD CARD FORMAT CODE FOR
C  CALIBRATION SYSTEM
      IPRERR=0
      CALL URDPDS (DDNAME,TMBR,IPRERR,REC,LRECL,NUMREC,IFLAG,IRCPDS)
      CALL SUBSTR (REC,1,4,TYPE4,1)
      CALL SUBSTR (REC,6,4,XCALB,1)
      CALL SUBSTR (REC,11,LEN(UNIT1),UNIT1,-1)
      CALL SUBSTR (REC,16,LEN(CODE1),CODE1,-1)
      CALL SUBSTR (REC,21,LEN(UNIT2),UNIT2,-1)
      CALL SUBSTR (REC,26,LEN(CODE2),CODE2,-1)
      CALL SUBSTR (REC,73,LEN(SEQ4),SEQ4,1)
      IF (ICMDBG.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,250) SEQ4,TYPE4,XCALB,UNIT1,CODE1,
     *      UNIT2,CODE2
         ENDIF
      IF (TYPE1.NE.TYPE4) THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,220) TYPE4,SEQ4,TYPE1,SEQ3
         ISTAT=3
         ENDIF
      IF (XCALB.NE.'CALB') THEN
         CALL UEROR (LP,1,-1)
         WRITE (LP,230) XCALB,TYPE1,SEQ4
         ISTAT=3
         ENDIF
C
70    IF (SRCH.EQ.'ALL') GO TO 80
      IF (APPL.NE.SRCH.AND.APPL.NE.'BOTH') GO TO 110
C
C  CHECK FOR MAXIMUM NUMBER OF DATA TYPES THAT CAN BE STORED
80    IF (NTYPE+1.GT.MTYPE) THEN
         IF (NTYPEA.EQ.0) THEN
            CALL UEROR (LP,1,-1)
            WRITE (LP,270) MTYPE
            ENDIF
         NTYPEA=NTYPEA+1
         ISTAT=1
         GO TO 110
         ENDIF
C
C  STORE TYPE CODE AND ATTRIBUTES IN ARRAYS
      NTYPE=NTYPE+1
      TYPE(NTYPE)=TYPE1
      IF (IDIMN.EQ.1.AND.XDIMN.NE.' ') DIMN(NTYPE)=XDIMN
      IF (IUNIT.EQ.1.AND.XUNIT.NE.' ') UNIT(NTYPE)=XUNIT
      IF (ITIME.EQ.1) TIME(NTYPE)=XTIME
      IF (INVAL.EQ.1) NVAL(NTYPE)=NVALX
      IF (INADD.EQ.1) NADD(NTYPE)=NADDX
C
C  FILL MISSING DATA INDICATOR ARRAY
      IF (IMISS.EQ.0) GO TO 90
      IF (XMISS.EQ.'YES') MISS(NTYPE)=1
      IF (XMISS.EQ.'NO') MISS(NTYPE)=0
      IF (MISS(NTYPE).GE.0) GO TO 90
         IF (SRCH.EQ.'CALB') GO TO 90
            CALL UEROR (LP,1,-1)
            WRITE (LP,280) XMISS,TYPE1,SEQ3
            ISTAT=3
C
C  FILL WRITE INDICATOR ARRAY
90    IF (IIWRT.EQ.0) GO TO 100
      IF (XWRT.EQ.'PP') IWRT(NTYPE)=0
      IF (XWRT.EQ.'FC') IWRT(NTYPE)=1
      IF (IWRT(NTYPE).GE.0) GO TO 100
         IF (SRCH.EQ.'CALB') GO TO 100
            CALL UEROR (LP,1,-1)
            WRITE (LP,290) XWRT,TYPE1,SEQ3
           ISTAT=3
C
100   IF (ICMDBG.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,300) TYPE1
         ENDIF
C
110   IF (IRCPDS.EQ.2) GO TO 120
         GO TO 20
C
120   IF (ISTAT.NE.1) GO TO 140
         NTYPET=NTYPE+NTYPEA
         WRITE (ICMPRU,310) NTYPET,SRCH,NTYPEA
C
C  CLOSE DATA SET
130   TMBR=' '
      IPRERR=1
      CALL URDPDS (DDNAME,TMBR,IPRERR,REC,LRECL,NUMREC,IFLAG,IRCPDS)
C
140   IF (ICMTRC.GT.1) THEN
         CALL ULINE (ICMPRU,1)
         WRITE (ICMPRU,320)
         ENDIF
C
      CALL CLFILE ( 'DATATYPE ', 0, ierr )
      RETURN
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
150   FORMAT (' *** ENTER UDTYPE')
160   FORMAT (' REC=',A)
170   FORMAT ('+*** ERROR - IN UDTYPE - URDPDS STATUS CODE=',I3)
180   FORMAT ('0*** NOTE - ',A,' ARRAY WILL NOT BE FILLED')
190   FORMAT (' ',A,1X,A)
200   FORMAT (' ',A,1X,A,1X,3(A))
210   FORMAT (' ',A,1X,5(A,1X),I2)
220   FORMAT ('+*** ERROR - IN UDTYPE - DATA TYPE ',A,' AT ',
     *  'LINE ',A,' DOES NOT MATCH DATA TYPE ',A,' AT ',
     *  'LINE ',A,' OF INPUT.')
230   FORMAT ('+*** ERROR - IN UDTYPE - INVALID APPLICATION CODE ',
     *   A,' FOR DATA TYPE ',A,' AT LINE ',A,
     *  ' OF INPUT.')
240   FORMAT (' ',A,1X,5(A,1X),I2)
250   FORMAT (' ',A,1X,2(A,1X),2(A,1X,A,1X))
260   FORMAT ('+*** ERROR - IN UDTYPE - INVALID SEARCH CODE SPECIFIED ',
     *  ': ',A)
270   FORMAT ('+*** ERROR - IN UDTYPE - MAXIMUM NUMBER OF DATA TYPES (',
     *   I3,') EXCEEDED.')
280   FORMAT ('+*** ERROR - IN UDTYPE - INVALID CODE FOR MISSING ',
     *  'DATA ALLOWED ',A,' FOR DATA TYPE ',A,' AT ',
     *  'LINE ',A,' OF INPUT.')
290   FORMAT ('+*** ERROR - IN UDTYPE - INVALID PROCESS CODE ',A,
     *   ' FOR TYPE ',A,' AT LINE ',A,' OF INPUT.')
300   FORMAT (' DATA TYPE ',A,' SUCCESSFULLY PROCESSED')
310   FORMAT ('0*** NOTE - IN UDTYPE - ',I3,' DATA TYPES FOUND TO ',
     *  'MATCH SEARCH CODE ',A,'. ',
     *   I3,' DATA TYPES NOT PROCESSED.')
320   FORMAT (' *** EXIT UDTYPE')
C
      END
