C MODULE URELCH
C-----------------------------------------------------------------------
C
      SUBROUTINE URELCH (REAL,MCHAR,CHAR,NUMDEC,NFILL,ISTAT)
C
C  ROUTINE TO A CONVERT A REAL VALUE TO CHARACTER VALUE
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C     ARGUMENT LIST
C
C       REAL - INPUT  - THE REAL VALUE TO BE CONVERTED
C      MCHAR - INPUT  - THE MAXIMUM NUMBER OF CHARACTERS THAT
C                       CHAR CAN HOLD
C                       IF NEGATIVE, RIGHTMOST ZEROS WILL NOT BE REMOVED
C       CHAR - OUTPUT - THE ARRAY CONTAINING THE CHARACTER
C                       REPRESENTATION OF VALUE
C     NUMDEC - INPUT  - THE NUMBER OF DECIMAL PLACES TO BE FILLED
C                         THE MAX VALUE OF NUMDEC IS 9
C                         IF NUMDEC=0 THE DECIMAL POINT IS THE
C                            RIGHTMOST CHARACTER IN CHAR
C                         IF NUMDEC=-1 NO DECIMAL POINT IS
C                            STORED IN CHAR
C      NFILL - OUTPUT - THE TOTAL NUMBER OF CHARACTERS FILLED
C                       IN CHAR
C      ISTAT - OUTPUT - STATUS CODE
C                         0=NORMAL RETURN
C                         1=MCHAR NOT LARGE ENOUGH TO HOLD VALUE
C                         2=NUMDEC GT 9 - NUMDEC RESET TO 9
C                           AND CHAR FILLED
C                         3=VALUE OUT OF VALID RANGE
C
C  THE RANGE OF REAL VALUES THAT CAN BE INPUT IS ABS(VAL)<(2**31-1)
C
C  THE MAXIMUM NUMBER OF DECIMAL PLACES THAT CAN BE REQUESTED IS 9
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      REAL*8 VALUE
C
      CHARACTER*1 CHAR(MCHAR)
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/util/src/util_gen3/RCS/urelch.f,v $
     . $',                                                             '
     .$Id: urelch.f,v 1.3 2002/02/11 13:13:42 michaelo Exp $
     . $' /
C    ===================================================================
C
      INCLUDE 'uiox'
      INCLUDE 'ucmdbx'
C
C
      IF (ICMTRC.GT.0) WRITE (ICMPRU,*) 'ENTER URELCH'
C
      IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'REAL=',REAL,
     *   ' MCHAR=',MCHAR
C
      ISTAT=0
C
      NFILL=0
C
      INEG=0
      IF (REAL.LT.0.) INEG=1
C
      VALUE=REAL
      IF (INEG.EQ.1) VALUE=-REAL
C
      IZEROS=0
      IF (MCHAR.LT.0) IZEROS=1
C
      IMCHAR=IABS(MCHAR)
      LPUT=IMCHAR
C
C  FILL CHAR WITH BLANKS
      IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'INEG=',INEG,
     *   ' IMCHAR=',IMCHAR,
     *   ' IZEROS=',IZEROS
      CALL UREPET (' ',CHAR,IMCHAR)
C
C  CHECK NUMBER OF DECIMAL PLACES REQUESTED
      IF (NUMDEC) 10,20,40
C
C  LESS THAN ZERO - NUMBER MUST BE -1 OR IT IS AN ERROR
10    IF (NUMDEC.EQ.-1) GO TO 30
      ISTAT=1
      GO TO 100
C
C  NUMDEC IS -1, WANT NO DECIMAL PLACES WITHOUT A DECIMAL POINT AS
C  THE RIGHTMOST CHARACTER
C
C  EQUAL TO ZERO, WANT NO DECIMAL PLACES WITH A DECIMAL POINT AS
C  THE RIGHTMOST CHARACTER
20    CHAR(LPUT)='.'
      LPUT=LPUT-1
      NFILL=NFILL+1
C
C  ROUND VALUE TO NEAREST WHOLE NUMBER
30    VALUE=VALUE+0.5
      GO TO 90
C
C  GREATER THAN ZERO, WANT NUMDEC DECIMAL PLACES
C  CHECK THAT NUMDEC IS LESS THAN LPUT
40    IF (NUMDEC.GT.LPUT) THEN
         ISTAT=1
         GO TO 100
         ENDIF
C
C  MAXIMUM NUMBER OF DECIMAL PLACES ALLOWED IS 9
C  ALGORITHM TO COMPUTE CHARACTERS FOR DECIMAL PORTION
C  BREAKS DOWN BECAUSE LARGEST ALLOWABLE INTEGER IS
C  APPROX 2*10E10 AND ALLOWING 10 DECIMAL PLACES MAY EXCEED THIS
      IF (NUMDEC.GT.9) THEN
         ISTAT=2
         NUMDEC=9
         ENDIF
C
C  ROUND VALUE BY ADDING .5 AT DECIMAL PLACE TO THE END
      VALUE=VALUE+0.501*10.**(-NUMDEC)
C
C  VALUE MUST BE LESS THAN (2**31-1) TO BE A VALID INTEGER
      IMAX=2147483647
      IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'IMAX=',IMAX
      IF (VALUE.GT.IMAX) THEN
         ISTAT=3
         GO TO 100
         ENDIF
C
C  SET DECIMAL PART OF NUMBER
      IDECML=IDINT((VALUE-IDINT(VALUE))*10**NUMDEC)
      ISTDEC=LPUT-NUMDEC+1
      CALL UINTCH (IDECML,NUMDEC,CHAR(ISTDEC),IFILL,IERR)
      IF (IERR.GT.0) THEN
         ISTAT=1
         GO TO 100
         ENDIF
C
C  IF IFILL LT NUMDEC THE LEFTMOST NUMDEC-IFILL CHARACTERS ARE
C  BLANKS.  THE BLANKS MUST BE REPLACED WITH ZEROES.
      IF (NUMDEC.EQ.IFILL) GO TO 60
C
      NUMFIL=NUMDEC-IFILL
      DO 50 I=1,NUMFIL
         CHAR(ISTDEC+I-1)='0'
50       CONTINUE
C
60    IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'NUMDEC=',NUMDEC,
     *   ' IZEROS=',IZEROS
      IF (NUMDEC.EQ.1) GO TO 80
      IF (IZEROS.EQ.1) GO TO 80
C
C  REPLACE RIGHTMOST ZEROES WITH BLANKS
      IEND=NUMDEC-1
      DO 70 I=IMCHAR,ISTDEC,-1
         IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'I=',I,
     *      ' CHAR(I)=',CHAR(I)
         IF (CHAR(I).NE.'0') GO TO 80
         CHAR(I)=' '
70       CONTINUE
C
C  ENTER DECIMAL POINT
80    NFILL=NFILL+NUMDEC
      LPUT=LPUT-NUMDEC
      CHAR(LPUT)='.'
      LPUT=LPUT-1
      NFILL=NFILL+1
C
C  PACK THE WHOLE NUMBER PORTION OF VALUE INTO CHAR
90    IWHOLE=IDINT(VALUE)
      CALL UINTCH (IWHOLE,LPUT,CHAR,IFILL,IERR)
      NFILL=NFILL+IFILL
      IF (IERR.EQ.1) ISTAT=1
C
C  CHECK IF NEGATIVE VALUE
      IF (INEG.EQ.1) THEN
         IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'NFILL=',NFILL,
     *      ' IMCHAR=',IMCHAR
         IF (IMCHAR-NFILL.LE.0) THEN
            ISTAT=1
            GO TO 100
            ENDIF
         CHAR(IMCHAR-NFILL)='-'
         NFILL=NFILL+1
        ENDIF
C
C  RIGHT JUSTIFY CHARACTER STRING
      CALL URGHTC (CHAR,IMCHAR,LBEGIN)
      NFILL=IMCHAR-LBEGIN+1
      IF (ICMDBG.GT.0) WRITE (ICMPRU,*) 'IMCHAR=',IMCHAR,
     *   ' LBEGIN=',LBEGIN,
     *   ' NFILL=',NFILL
C
100   IF (ICMDBG.GT.0) WRITE (ICMPRU,110) NFILL,(CHAR(I),I=1,NFILL)
110   FORMAT (' NFILL=',I2,3X,'CHAR=',100A1)
C
      IF (ICMTRC.GT.0) WRITE (ICMPRU,*) 'EXIT URELCH'
C
      RETURN
C
      END
