/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/

package com.raytheon.uf.edex.plugin.qc;

import java.io.File;
import java.util.Arrays;
import java.util.Date;
import java.util.Map;
import java.util.regex.Pattern;

import ucar.ma2.Array;
import ucar.ma2.ArrayChar;
import ucar.ma2.Section;
import ucar.nc2.Attribute;
import ucar.nc2.NetcdfFile;
import ucar.nc2.Variable;

import com.raytheon.uf.common.dataplugin.PluginDataObject;
import com.raytheon.uf.common.dataplugin.PluginException;
import com.raytheon.uf.common.dataplugin.qc.QCRecord;
import com.raytheon.uf.common.pointdata.spatial.SurfaceObsLocation;
import com.raytheon.uf.common.status.IUFStatusHandler;
import com.raytheon.uf.common.status.UFStatus;
import com.raytheon.uf.common.time.DataTime;
import com.raytheon.uf.edex.database.plugin.PluginFactory;
import com.raytheon.uf.edex.plugin.qc.dao.QCDao;
import com.raytheon.uf.edex.plugin.qc.internal.QCPaths;

/**
 * Scans NetCDF files generated by A1 legacy applications and generates QCRecord
 * instances that refer to their records.
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * 
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Dec 03, 2010 4775       D. Friedman Initial version
 * Mar 07, 2013 15842      D. Friedman Use Java NetCDF library instead of
 *                                     pupynere
 * May 16, 2013 1869       bsteffen    Remove DataURI column from qc.
 * Aug 30, 2013 2298       rjpeter     Make getPluginName abstract
 * Feb 20, 2014 DR 17098   D. Friedman Filter out invalid lat/lon values.
 * Jul 23, 2014 3410       bclement    location changed to floats
 * 
 * </pre>
 * 
 * @author dfriedma
 * @version 1.0
 */
public class QCScanner {
    private static final transient IUFStatusHandler statusHandler = UFStatus
            .getHandler(QCScanner.class);

    private Integer maxRecordsInChunk;

    private IQCScannerTarget target;

    public QCScanner() {

    }

    public void scanInChunks() throws Exception {
        Map<String, File> paths = QCPaths.getPaths();

        for (Map.Entry<String, File> entry : paths.entrySet()) {
            String type = entry.getKey();
            File directory = entry.getValue();
            QCDirectoryScanner scanner = new QCDirectoryScanner(type, directory);
            scanner.scan();
        }
    }

    /**
     * @return the maxRecordsInChunk
     */
    public Integer getMaxRecordsInChunk() {
        return maxRecordsInChunk;
    }

    /**
     * @param maxRecordsInChunk
     *            the maxRecordsInChunk to set
     */
    public void setMaxRecordsInChunk(Integer maxRecordsInChunk) {
        this.maxRecordsInChunk = maxRecordsInChunk;
    }

    /**
     * @return the target
     */
    public IQCScannerTarget getTarget() {
        return target;
    }

    /**
     * @param target
     *            the target to set
     */
    public void setTarget(IQCScannerTarget target) {
        this.target = target;
    }

    private static final Pattern filePattern = Pattern.compile("^\\d+_\\d+$");

    // Approximate total max length of vars listed in idVariables attributes.
    private static final int ID_LENGTH = 24;

    private class QCDirectoryScanner {
        private final String qcType;

        private final File directory;

        private QCDao qcDao;

        public QCDirectoryScanner(String qcType, File directory) {
            this.qcType = qcType;
            this.directory = directory;
        }

        public void scan() throws PluginException {
            qcDao = (QCDao) PluginFactory.getInstance().getPluginDao("qc");

            for (String fn : directory.list()) {
                if (filePattern.matcher(fn).matches()) {
                    try {
                        scanFile(fn);
                    } catch (Exception e) {
                        statusHandler.error(String.format(
                                "error reading %s/%s: %s", directory, fn,
                                e.getMessage()), e);
                    }
                }
            }
        }

        private void scanFile(String fn) throws Exception {
            NetcdfFile nc = NetcdfFile.open(new File(directory, fn).toString());
            try {
                int index = qcDao.getMaxRecordIndex(qcType, fn);
                if (index < 0) {
                    index = 0;
                } else {
                    index += 1;
                }
                int nRecords = nc.getUnlimitedDimension().getLength();
                if (index >= nRecords) {
                    return;
                }
                String[] idVariablesNames = nc
                        .findGlobalAttribute("idVariables").getStringValue()
                        .split(",");
                String[] timeVariableNames = nc
                        .findGlobalAttribute("timeVariables").getStringValue()
                        .split(",");
                Variable[] idVariables = new Variable[idVariablesNames.length];
                for (int i = 0; i < idVariables.length; ++i) {
                    idVariables[i] = nc.findVariable(idVariablesNames[i]);
                }
                Variable vObsTime = nc.findVariable(timeVariableNames[0]);
                double vObsTimeFillValue = vObsTime.findAttribute("_FillValue")
                        .getNumericValue().doubleValue();
                Double vObsTimeMissingValue = null;
                Attribute a = vObsTime.findAttribute("missing_value");
                if (a != null) {
                    vObsTimeMissingValue = a.getNumericValue().doubleValue();
                }
                Variable vLat = nc.findVariable("latitude");
                Variable vLon = nc.findVariable("longitude");
                Variable vElev = nc.findVariable("elevation");

                while (index < nRecords) {
                    PluginDataObject[] records = new PluginDataObject[Math.min(
                            maxRecordsInChunk, nRecords - index)];
                    int[] ofs = new int[] { index };
                    int[] len = new int[] { records.length };
                    Section sec = new Section();
                    sec.appendRange(index, (index + records.length) - 1);
                    sec.appendRange();
                    Array dObsTime = vObsTime.read(ofs, len);
                    Array dLat = vLat.read(ofs, len);
                    Array dLon = vLon.read(ofs, len);
                    Array dElev = vElev.read(ofs, len);
                    ArrayChar[] dIDs = new ArrayChar[idVariables.length];
                    for (int i = 0; i < dIDs.length; ++i) {
                        dIDs[i] = (ArrayChar) idVariables[i].read(sec);
                    }
                    int ri = 0;
                    int oi = 0;
                    while (ri < records.length) {
                        QCRecord r = new QCRecord();
                        double obsTime = dObsTime.getDouble(ri);
                        float lat = dLat.getFloat(ri);
                        float lon = dLon.getFloat(ri);
                        if ((obsTime != vObsTimeFillValue)
                                && ((vObsTimeMissingValue == null) || (vObsTimeMissingValue != obsTime))
                                && Math.abs(lon) <= 180 && Math.abs(lat) <= 90) {
                            r.setDataTime(new DataTime(new Date(
                                    (long) (obsTime * 1000))));
                            SurfaceObsLocation loc = new SurfaceObsLocation();
                            loc.assignLocation(lat, lon);
                            loc.setElevation(dElev.getInt(ri));
                            StringBuilder stationId = new StringBuilder(
                                    ID_LENGTH);
                            for (ArrayChar idArray : dIDs) {
                                stationId.append(idArray.getString(ri));
                            }
                            loc.setStationId(stationId.toString());
                            r.setLocation(loc);
                            r.setNcSet(fn);
                            r.setNcIndex(index);
                            r.setQcType(qcType);
                            records[oi++] = r;
                        }
                        ++index;
                        ++ri;
                    }
                    if (oi > 0) {
                        if (oi < records.length) {
                            records = Arrays.copyOf(records, oi);
                        }
                        target.acceptRecords(records);
                    }
                }
            } finally {
                nc.close();
            }
        }
    }
}
