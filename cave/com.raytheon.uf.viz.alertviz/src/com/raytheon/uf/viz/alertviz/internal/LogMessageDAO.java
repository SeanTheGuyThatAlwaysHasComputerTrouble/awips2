/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.viz.alertviz.internal;

import java.io.File;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.raytheon.uf.common.message.StatusMessage;
import com.raytheon.uf.common.status.UFStatus.Priority;
import com.raytheon.uf.viz.alertviz.AlertvizException;
import com.raytheon.uf.viz.alertviz.Container;
import com.raytheon.uf.viz.alertviz.LogUtil.Order;
import com.raytheon.uf.viz.alertviz.config.Category;
import com.raytheon.uf.viz.core.VizApp;
import com.raytheon.uf.viz.core.localization.LocalizationManager;

/**
 * Stores the log messages in an internal derby database
 * 
 * <pre>
 * SOFTWARE HISTORY
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Sep 11, 2008 1433       chammack    Initial creation
 * </pre>
 * 
 * @author chammack
 * @version 1.0
 */

public class LogMessageDAO {

    private static final int VERSION = 1;

    private static final String SELECT_ALL_QUERY = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log";

    private static final String SELECT_ALL_QUERY_BY_PK = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE pk = ?";

    private static final String PURGE_TIME_QUERY = "SELECT purge_time FROM dbMetadata";

    private static final String PURGE_TIME_UPDATE = "UPDATE dbMetadata SET purge_time = ?";

    private static final String DATA_RANGE_QUERY = "SELECT MIN(pk), MAX(pk) FROM log";

    private static final String SELECT_ALL_BY_DATE_AND_SOURCE_AFTER = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE event_time > ?";

    private static final String SELECT_ALL_BY_DATE_AND_SOURCE_BEFORE = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE event_time < ?";

    private static final String SELECT_LAST_INSERT_ID = "SELECT IDENTITY_VAL_LOCAL() FROM log";

    private static final String INSERT_PREPARED_STATEMENT = "INSERT INTO log(event_time, category, priority, message, details, source) values (?, ?, ?, ?, ?, ?)";

    private static final String DB_CREATE = "CREATE TABLE log(pk INT NOT NULL GENERATED BY DEFAULT AS IDENTITY, event_time TIMESTAMP, category VARCHAR(64), source VARCHAR(64), priority INT, message VARCHAR(32672), details VARCHAR(32672), acknowledgedBy VARCHAR(32), acknowledgedAt TIMESTAMP)";

    private static final String PURGE_STATEMENT = "DELETE FROM log WHERE event_time < ?";

    private static final String METADATA_CREATE = "CREATE TABLE dbMetadata(purge_time TIMESTAMP, version INT)";

    private static final String ACKNOWLEDGE = "UPDATE log SET acknowledgedAt = ? , acknowledgedBy = ? WHERE pk = ?";

    private static final String METADATA_INSERT = "INSERT INTO dbMetadata(version, purge_time) values("
            + VERSION
            + ",'"
            + new Timestamp(System.currentTimeMillis()).toString() + "')";

    private Connection connection;

    private PreparedStatement saveStatement;

    private PreparedStatement getLastStatement;

    private static final String driver = "org.apache.derby.jdbc.EmbeddedDriver";

    private static final String startDatabase;

    private static final String stopDatabase;

    private static final String databaseDir;

    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");

    static {
        databaseDir = LocalizationManager.getUserDir() + File.separator
                + "logs" + File.separator + VizApp.getHostName();
        startDatabase = "jdbc:derby:directory:" + databaseDir + ";create=true";
        stopDatabase = "jdbc:derby:directory:" + databaseDir + ";shutdown=true";
    }

    private static LogMessageDAO instance = new LogMessageDAO();

    public static LogMessageDAO getInstance() {
        return instance;
    }

    private LogMessageDAO() {
    }

    private synchronized Connection getConnection() throws AlertvizException {
        if (connection != null) {
            try {
                if (connection.isClosed()) {
                    closeConnection();
                }
            } catch (SQLException e) {
                Container
                        .logInternal(
                                Priority.ERROR,
                                "Failed to connect to the AlertViz internal logging DB",
                                e);
                closeConnection();
            }
        }
        if (connection == null) {
            try {
                createConnection();
            } catch (Exception e) {
                // unable to create a connection, move alertViz log dir and
                // recreate
                Container
                        .logInternal(
                                Priority.ERROR,
                                "Unable to create connection to database, moving database dir to bad, and recreating from scratch",
                                e);
                moveLogDirToBackup();
                createConnection();
            }
        }

        return connection;
    }

    private void createConnection() throws AlertvizException {
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Class.forName(driver).newInstance();
            connection = DriverManager.getConnection(startDatabase);
            DatabaseMetaData dmd = connection.getMetaData();
            ResultSet tables = dmd.getTables(null, null, null,
                    new String[] { "TABLE" });
            boolean needCreation = true;

            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                if (tableName.equalsIgnoreCase("log")) {
                    needCreation = false;
                    break;
                }
            }

            if (needCreation) {
                statement = connection.createStatement();
                statement.execute(DB_CREATE);
                statement.execute(METADATA_CREATE);
                statement.execute(METADATA_INSERT);
            }
            connection.commit();
        } catch (Exception e1) {
            errorOccurred = true;
            throw new AlertvizException("Error setting up logging system", e1);
        } finally {
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    private void closeConnection() {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                // ignore
            }
            connection = null;
        }

        try {
            DriverManager.getConnection(stopDatabase);
        } catch (SQLException e) {
            // ignore as stop database will always throw an exception
        }
    }

    private void closeStatement(Statement statement) {
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void closeResultSet(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void moveLogDirToBackup() {
        File oldDir = new File(databaseDir);
        File newDir = null;
        synchronized (sdf) {
            boolean notFound = true;
            int count = 0;
            String basePath = databaseDir + "_bad_" + sdf.format(new Date())
                    + "_";
            while (notFound) {
                newDir = new File(basePath + count++);
                if (!newDir.exists()) {
                    notFound = false;
                }
            }
        }
        oldDir.renameTo(newDir);
    }

    public void save(StatusMessage sm) throws AlertvizException {
        Container.logInternal(sm);
        synchronized (this) {
            boolean errorOccurred = false;
            ResultSet rs = null;
            try {
                Connection conn = getConnection();
                if (saveStatement == null) {
                    saveStatement = conn
                            .prepareStatement(INSERT_PREPARED_STATEMENT);
                }

                saveStatement.setTimestamp(1, new Timestamp(sm.getEventTime()
                        .getTime()));
                saveStatement.setString(2, sm.getCategory());
                saveStatement.setInt(3, sm.getPriority().ordinal());
                saveStatement.setString(4, sm.getMessage());
                saveStatement.setString(5, sm.getDetails());
                saveStatement.setString(6, sm.getSourceKey());
                saveStatement.executeUpdate();

                if (getLastStatement == null) {
                    getLastStatement = conn
                            .prepareStatement(SELECT_LAST_INSERT_ID);
                }

                rs = getLastStatement.executeQuery();
                if (rs.next()) {
                    int id = rs.getInt(1);
                    sm.setPk(id);
                }
                conn.commit();
            } catch (Exception e) {
                errorOccurred = true;
                throw new AlertvizException("Save failed", e);
            } finally {
                if (errorOccurred) {
                    closeStatement(saveStatement);
                    saveStatement = null;
                    closeStatement(getLastStatement);
                    getLastStatement = null;
                    closeConnection();
                }
            }
        }
    }

    public void acknowledge(StatusMessage sm, String username)
            throws AlertvizException {
        PreparedStatement updateStatement = null;
        synchronized (this) {
            boolean errorOccurred = false;
            try {
                Connection conn = getConnection();
                updateStatement = conn.prepareStatement(ACKNOWLEDGE);

                long ackTime = System.currentTimeMillis();
                updateStatement.setTimestamp(1, new Timestamp(ackTime));
                updateStatement.setString(2, username);
                updateStatement.setInt(3, sm.getPk());
                updateStatement.executeUpdate();
                sm.setAcknowledgedBy(username);
                sm.setAcknowledgedAt(new Date(ackTime));
                conn.commit();
            } catch (SQLException e) {
                errorOccurred = true;
                throw new AlertvizException("Acknowledge Failed", e);
            } finally {
                closeStatement(updateStatement);
                if (errorOccurred) {
                    closeConnection();
                }
            }
        }
    }

    public StatusMessage loadByPk(int pk) throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(SELECT_ALL_QUERY_BY_PK);
            statement.setInt(1, pk);

            rs = statement.executeQuery();

            conn.commit();
            return reconstituteResults(rs)[0];
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + pk, e);
        } catch (RuntimeException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading " + pk, e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public StatusMessage[] load(int count) throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(count);
            rs = statement.executeQuery(SELECT_ALL_QUERY);
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public StatusMessage[] load(int count, Timestamp filter, Order order)
            throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            if (order == Order.BEFORE)
                statement = conn
                        .prepareStatement(SELECT_ALL_BY_DATE_AND_SOURCE_BEFORE);
            else if (order == Order.AFTER)
                statement = conn
                        .prepareStatement(SELECT_ALL_BY_DATE_AND_SOURCE_AFTER);
            else
                throw new IllegalArgumentException("Unsupported order : "
                        + order);

            statement.setMaxFieldSize(count);
            statement.setTimestamp(1, filter);
            rs = statement.executeQuery();
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public StatusMessage[] load(int count, Category[] filter)
            throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            StringBuffer sb = new StringBuffer();
            sb.append("SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log  ");

            boolean first = true;
            for (Category cat : filter) {
                if (first) {
                    sb.append("WHERE ");
                    first = false;
                } else {
                    sb.append(" OR ");
                }

                sb.append("category = '" + cat.getCategoryName() + "'");

            }
            sb.append(" ORDER BY event_time");
            rs = statement.executeQuery(sb.toString());
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public void purge(Timestamp filter) throws AlertvizException {
        PreparedStatement statement = null;
        PreparedStatement updateStatement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(PURGE_STATEMENT);
            statement.setTimestamp(1, filter);
            statement.executeUpdate();

            updateStatement = conn.prepareStatement(PURGE_TIME_UPDATE);
            updateStatement.setTimestamp(1,
                    new Timestamp(System.currentTimeMillis()));
            updateStatement.executeUpdate();
            conn.commit();
            return;
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeStatement(statement);
            closeStatement(updateStatement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public int[] getLogRange() throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(1);
            rs = statement.executeQuery(DATA_RANGE_QUERY);
            if (rs.next()) {
                int min = rs.getInt(1);
                int max = rs.getInt(2);

                return new int[] { min, max };
            }
            conn.commit();
            return null;
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error getting time range ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    public Timestamp getLastPurgeTime() throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        boolean errorOccurred = false;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(1);
            rs = statement.executeQuery(PURGE_TIME_QUERY);
            if (rs.next()) {
                return rs.getTimestamp("purge_time");
            }
            conn.commit();
            return null;
        } catch (SQLException e) {
            errorOccurred = true;
            throw new AlertvizException("Error getting last purge time ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection();
            }
        }
    }

    private StatusMessage[] reconstituteResults(ResultSet rs)
            throws SQLException {
        List<StatusMessage> retVal = new ArrayList<StatusMessage>();
        while (rs.next()) {
            StatusMessage sm = new StatusMessage();
            sm.setEventTime(rs.getTimestamp(1));
            sm.setCategory(rs.getString(2));
            sm.setPriority(Priority.values()[rs.getInt(3)]);
            sm.setMessage(rs.getString(4));
            sm.setDetails(rs.getString(5));
            sm.setSourceKey(rs.getString(6));
            sm.setPk(rs.getInt(7));
            sm.setAcknowledgedBy(rs.getString(8));

            Timestamp ts = rs.getTimestamp(9);
            if (ts != null)
                sm.setAcknowledgedAt(new Date(ts.getTime()));

            retVal.add(sm);
        }

        return retVal.toArray(new StatusMessage[retVal.size()]);
    }
}
